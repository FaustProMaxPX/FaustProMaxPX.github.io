<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta property="og:type" content="article">
<meta property="og:title" content="Rust —— 基础篇">
<meta property="og:url" content="http://faustpromaxpx.github.io/2023/04/09/rust/index.html">
<meta property="og:site_name" content="狂奔的蜗牛">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-b771fe4cfc6ebd63d9aff42840eb8e67_1440w.jpg">
<meta property="article:published_time" content="2023-04-09T03:36:22.000Z">
<meta property="article:modified_time" content="2023-04-19T07:02:28.402Z">
<meta property="article:author" content="Zephyr">
<meta property="article:tag" content="Rust">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic1.zhimg.com/80/v2-b771fe4cfc6ebd63d9aff42840eb8e67_1440w.jpg">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>Rust —— 基础篇</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/probberechts">项目</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2023/05/06/rust-ad1/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2023/03/09/netty/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://faustpromaxpx.github.io/2023/04/09/rust/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://faustpromaxpx.github.io/2023/04/09/rust/&text=Rust —— 基础篇"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://faustpromaxpx.github.io/2023/04/09/rust/&title=Rust —— 基础篇"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://faustpromaxpx.github.io/2023/04/09/rust/&is_video=false&description=Rust —— 基础篇"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Rust —— 基础篇&body=Check out this article: http://faustpromaxpx.github.io/2023/04/09/rust/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://faustpromaxpx.github.io/2023/04/09/rust/&title=Rust —— 基础篇"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://faustpromaxpx.github.io/2023/04/09/rust/&title=Rust —— 基础篇"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://faustpromaxpx.github.io/2023/04/09/rust/&title=Rust —— 基础篇"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://faustpromaxpx.github.io/2023/04/09/rust/&title=Rust —— 基础篇"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://faustpromaxpx.github.io/2023/04/09/rust/&name=Rust —— 基础篇&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://faustpromaxpx.github.io/2023/04/09/rust/&t=Rust —— 基础篇"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Hello-Wrold"><span class="toc-number">1.</span> <span class="toc-text">Hello Wrold</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%BB%91%E5%AE%9A%E4%B8%8E%E8%A7%A3%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">变量绑定与解构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">基本类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">整数类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">浮点数类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97"><span class="toc-number">3.3.</span> <span class="toc-text">序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E7%90%86%E6%95%B0%E5%92%8C%E8%B4%9F%E6%95%B0"><span class="toc-number">3.4.</span> <span class="toc-text">有理数和负数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.5.</span> <span class="toc-text">字符类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.6.</span> <span class="toc-text">单元类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E5%8F%A5%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.7.</span> <span class="toc-text">语句和表达式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E6%9D%83%E5%92%8C%E5%80%9F%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">所有权和借用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E6%9D%83"><span class="toc-number">4.1.</span> <span class="toc-text">所有权</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E4%B8%8E%E5%80%9F%E7%94%A8"><span class="toc-number">4.2.</span> <span class="toc-text">引用与借用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.</span> <span class="toc-text">复合类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%87%E7%89%87"><span class="toc-number">5.1.</span> <span class="toc-text">切片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.2.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">5.3.</span> <span class="toc-text">结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">5.4.</span> <span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">5.5.</span> <span class="toc-text">数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">6.</span> <span class="toc-text">模式匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#match%E5%8C%B9%E9%85%8D"><span class="toc-number">6.1.</span> <span class="toc-text">match匹配</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">7.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">8.</span> <span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%89%B9%E5%BE%81"><span class="toc-number">9.</span> <span class="toc-text">特征</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E5%BE%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">9.1.</span> <span class="toc-text">特征对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E5%BE%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%86%E5%8F%91"><span class="toc-number">9.2.</span> <span class="toc-text">特征对象的动态分发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E5%BE%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">9.3.</span> <span class="toc-text">特征对象的限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.4.</span> <span class="toc-text">关联类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-number">9.5.</span> <span class="toc-text">特殊的方法调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E5%BE%81%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E7%89%B9%E5%BE%81%E7%BA%A6%E6%9D%9F"><span class="toc-number">9.6.</span> <span class="toc-text">特征定义中的特征约束</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E5%A4%96%E9%83%A8%E7%B1%BB%E5%9E%8B%E4%B8%8A%E5%AE%9E%E7%8E%B0%E5%A4%96%E9%83%A8%E7%89%B9%E5%BE%81"><span class="toc-number">9.7.</span> <span class="toc-text">在外部类型上实现外部特征</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vec"><span class="toc-number">10.</span> <span class="toc-text">Vec</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">11.</span> <span class="toc-text">生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%80%9F%E7%94%A8%E6%A3%80%E6%9F%A5"><span class="toc-number">11.1.</span> <span class="toc-text">借用检查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">11.2.</span> <span class="toc-text">函数中的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">11.3.</span> <span class="toc-text">结构体中的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B6%88%E9%99%A4"><span class="toc-number">11.4.</span> <span class="toc-text">生命周期消除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">11.5.</span> <span class="toc-text">静态生命周期</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">12.</span> <span class="toc-text">错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#panic"><span class="toc-number">12.1.</span> <span class="toc-text">panic</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E6%92%AD%E9%94%99%E8%AF%AF"><span class="toc-number">12.2.</span> <span class="toc-text">传播错误</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%85%E5%92%8C%E6%A8%A1%E5%9D%97"><span class="toc-number">13.</span> <span class="toc-text">包和模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Crate"><span class="toc-number">13.1.</span> <span class="toc-text">Crate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Package"><span class="toc-number">13.2.</span> <span class="toc-text">Package</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97"><span class="toc-number">13.3.</span> <span class="toc-text">模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">13.4.</span> <span class="toc-text">可见性</span></a></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        Rust —— 基础篇
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">Zephyr</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-04-09T03:36:22.000Z" class="dt-published" itemprop="datePublished">2023-04-09</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>
    </div>


      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/Rust/" rel="tag">Rust</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1 id="Hello-Wrold"><a href="#Hello-Wrold" class="headerlink" title="Hello Wrold"></a>Hello Wrold</h1><p><strong>创建一个项目</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cargo new hello_world<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>该项目的结构和配置文件都是由cargo生成</p>
<p><strong>运行项目</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cargo run

<span class="token comment"># 相当于运行下面的代码</span>
cargo build
./target/debug/hello_world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个命令会运行当前所在文件夹的项目，它首先会对项目进行编译，然后执行。</p>
<p>可以看到生成的代码放在debug文件夹下，这是因为rust在默认情况下，会按照debug模式运行，这种情况下编译速度会非常快，但运行速度比较慢。</p>
<p>因此在生产环境中，我们会使用release模式运行代码，确保运行速度。操作也很简单，只需要在运行/编译命令中添加<code>--release</code>参数即可。</p>
<p>在项目大了之后，上面两个命令的速度不可避免的会变慢，此时我们可以改用<code>cargo check</code>命令，它会快速检查代码能否编译通过。</p>
<p><strong>项目管理</strong></p>
<p>Cargo.toml和Cargo.lock是cargo的核心文件。前者是cargo特有的项目数据描述文件。他存储所有项目配置的元数据。后者则是cargo工具根据同一项目下的toml文件生成的项目依赖清单。</p>
<p>定义项目依赖：</p>
<ul>
<li>基于 Rust 官方仓库&nbsp;<code>crates.io</code>，通过版本说明来描述</li>
<li>基于项目源代码的 git 仓库地址，通过 URL 来描述</li>
<li>基于本地项目的绝对路径或者相对路径，通过类 Unix 模式的路径来描述</li>
</ul>
<pre class="line-numbers language-toml" data-language="toml"><code class="language-toml"><span class="token punctuation">[</span><span class="token table class-name">dependencies</span><span class="token punctuation">]</span>
<span class="token key property">rand</span> <span class="token punctuation">=</span> <span class="token string">"0.3"</span>
<span class="token key property">hammer</span> <span class="token punctuation">=</span> <span class="token punctuation">{</span> <span class="token key property">version</span> <span class="token punctuation">=</span> <span class="token string">"0.5.0"</span><span class="token punctuation">}</span>
<span class="token key property">color</span> <span class="token punctuation">=</span> <span class="token punctuation">{</span> <span class="token key property">git</span> <span class="token punctuation">=</span> <span class="token string">"https://github.com/bjz/color-rs"</span> <span class="token punctuation">}</span>
<span class="token key property">geometry</span> <span class="token punctuation">=</span> <span class="token punctuation">{</span> <span class="token key property">path</span> <span class="token punctuation">=</span> <span class="token string">"crates/geometry"</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>强化一下 Hello World</strong></p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// println!("Hello, world!");</span>
    <span class="token function">greet_world</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">greet_world</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> chinese <span class="token operator">=</span> <span class="token string">"你好世界"</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> english <span class="token operator">=</span> <span class="token string">"Hello world"</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> regions <span class="token operator">=</span> <span class="token punctuation">[</span>chinese<span class="token punctuation">,</span> english<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> ele <span class="token keyword">in</span> regions<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ele<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>变量声明，函数声明等等都和其他语言基本一致。主要需要关注一下println之后的!，在Rust中，它是红操作符，我们目前可以认为宏是一特殊类型函数。</p>
<p><strong>Hello World PLUS</strong></p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">funny</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> penguin_data <span class="token operator">=</span> <span class="token string">"\
   common name,length (cm)
   Little penguin,33
   Yellow-eyed penguin,65
   Fiordland penguin,60
   Invalid,data
   "</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> records <span class="token operator">=</span> penguin_data<span class="token punctuation">.</span><span class="token function">lines</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 获取数组中的下标以及对应元素</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> record<span class="token punctuation">)</span> <span class="token keyword">in</span> records<span class="token punctuation">.</span><span class="token function">enumerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> record<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
		<span class="token comment">// 声明一个变量，类型是Vector，里面的类型由编译器自行判断</span>
		<span class="token comment">// map的参数为一个lambada表达式</span>
        <span class="token keyword">let</span> fields<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span>_<span class="token operator">&gt;</span> <span class="token operator">=</span> record<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token char">','</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>field<span class="token closure-punctuation punctuation">|</span></span> field<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// 启用debug模式时开启</span>
        <span class="token keyword">if</span> <span class="token macro property">cfg!</span><span class="token punctuation">(</span>debug_assertions<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token macro property">eprintln!</span><span class="token punctuation">(</span><span class="token string">"debug: {:?} -&gt; {:?}"</span><span class="token punctuation">,</span> record<span class="token punctuation">,</span> fields<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
		
        <span class="token keyword">let</span> name <span class="token operator">=</span> fields<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">// 尝试将切片中的某个元素转换为f32类型，如果转换成功，这个变量会被赋值给length</span>
        <span class="token comment">// 右边的部分如果执行成功会返回一个Ok(f32)类型，如果失败，则会返回一个Err(e)类型，if let 的作用就是仅匹配Ok的情况</span>
        <span class="token comment">// 然后if let还会做一次解构匹配，通过 Ok(length) 去匹配右边的 Ok(f32)，最终把相应的 f32 值赋给 length</span>
        <span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Ok</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span> <span class="token operator">=</span> fields<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">::</span><span class="token operator">&lt;</span><span class="token keyword">f32</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}, {}cm"</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h1 id="变量绑定与解构"><a href="#变量绑定与解构" class="headerlink" title="变量绑定与解构"></a>变量绑定与解构</h1><p><strong>变量绑定</strong></p>
<hr>
<p>在其他语言中的赋值操作，在Rust中被称为变量绑定。这里面涉及Rust的核心原则 —— <strong>所有权</strong>。通俗来说就是，每块内存对象都是有主人的，并且一般情况下，它完全属于它的主人。所谓的绑定就是让某个变量称为指定对象的主人<br><strong>敲重点：这里的意思就是如果某个内存对象被赋值给了另一个变量，就代表原来的变量失去了它的所有权。这就代表着不存在引用泄露的问题，因为一个内存对象最多同时被一个变量所有。</strong></p>
<p><strong>变量可变性</strong></p>
<hr>
<p>Rust的变量默认情况下是<strong>不可变</strong>的。也就是说一个变量不能被多次赋值。这可以显著提高代码的安全性，并且性能也更好，因为不可变对象不需要runtime期间的一些检查。同时，它也能帮我们避免变量在不知情的情况下被修改。</p>
<p>但不可变变量也有一定的问题，如果每次改变都需要重新生成一个对象，那显然会带来大量的内存拷贝。因此，Rust同样支持可变变量，只需要在声明时加上<code>mut</code>即可。</p>
<p>通常情况下，对于一些庞大的数据结构，修改它的内部内容显示是更加高效的。而对于一些比较小的结构，通过牺牲一定的性能换取安全性是值得的。</p>
<p><strong>变量解构</strong></p>
<hr>
<p>定义：从一个相对复杂的变量中，匹配出该变量的一部分内容</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token keyword">mut</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token keyword">bool</span><span class="token punctuation">,</span><span class="token keyword">bool</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// a = true,不可变; b = false，可变</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"a = {:?}, b = {:?}"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>

    b <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>变量遮蔽</strong></p>
<hr>
<p>Rust允许声明相同的变量名，在后面声明的变量会遮蔽前面声明的。它的作用在于，如果在某个作用域内无需再使用之前的变量，就可以重复使用之前使用过的变量名。</p>
<h1 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h1><h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><table>
<thead>
<tr>
<th>长度</th>
<th>有符号类型</th>
<th>无符号类型</th>
</tr>
</thead>
<tbody><tr>
<td>8位</td>
<td>i8</td>
<td>u8</td>
</tr>
<tr>
<td>16位</td>
<td>i16</td>
<td>u16</td>
</tr>
<tr>
<td>32位</td>
<td>i32</td>
<td>u32</td>
</tr>
<tr>
<td>64位</td>
<td>i64</td>
<td>u64</td>
</tr>
<tr>
<td>128位</td>
<td>i128</td>
<td>u128</td>
</tr>
<tr>
<td>视架构而定</td>
<td>isize</td>
<td>usize</td>
</tr>
</tbody></table>
<p>Rust整型默认用<code>i32</code>。它的性能一般也是最好的。</p>
<p><strong>整型溢出</strong></p>
<p>Rust在debug模式下会检测整型溢出，而在release模式下不会。默认情况下，Rust会按照补码循环溢出的规则处理。<br>如果要显示处理可能的溢出，可以使用标准库相关函数</p>
<ul>
<li>使用&nbsp;<code>wrapping_*</code>&nbsp;方法在所有模式下都按照补码循环溢出规则处理，例如&nbsp;<code>wrapping_add</code></li>
<li>如果使用&nbsp;<code>checked_*</code>&nbsp;方法时发生溢出，则返回&nbsp;<code>None</code>&nbsp;值</li>
<li>使用&nbsp;<code>overflowing_*</code>&nbsp;方法返回该值和一个指示是否存在溢出的布尔值</li>
<li>使用&nbsp;<code>saturating_*</code>&nbsp;方法使值达到最小值或最大值</li>
</ul>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> a <span class="token punctuation">:</span> <span class="token keyword">u8</span> <span class="token operator">=</span> <span class="token number">255</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> b <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">wrapping_add</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 19</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h2><p>浮点类型数字是带有小数点的数字，在Rust中有两种<code>f32</code>和<code>f64</code></p>
<p><strong>浮点数陷阱</strong></p>
<ol>
<li>浮点数往往是想要数字的近似表达</li>
<li>浮点数具备一些反直觉的特性，浮点数的比较运算实现的是<code>std::cmp::PartialEq</code>而非<code>std::cmp::Eq</code>。后者是其他数据类型进行相等比较使用的。</li>
</ol>
<h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h2><p>Rust提供了序列用来生成连续的数值，例如<code>1..5</code>代表生成1-4的连续数字，<code>1..=5</code>生成1-5。序列只允许用于数字或字符，原因是他们可以连续，并且可以在编译期检查序列是否为空</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">1</span><span class="token punctuation">..=</span><span class="token number">5</span> <span class="token punctuation">{</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="有理数和负数"><a href="#有理数和负数" class="headerlink" title="有理数和负数"></a>有理数和负数</h2><p>Rust提供了num数值库，它可以处理有理数和复数。要想使用num库，首先需要在toml文件中的dependencies中添加一行 <code>num = 0.4.0</code></p>
<p>然后编写代码</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">num<span class="token punctuation">::</span></span><span class="token class-name">Complex</span><span class="token punctuation">;</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token class-name">Complex</span> <span class="token punctuation">{</span>re<span class="token punctuation">:</span> <span class="token number">2.1</span><span class="token punctuation">,</span> im<span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">1.2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token class-name">Complex</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token number">11.1</span><span class="token punctuation">,</span> <span class="token number">22.2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> result <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
    <span class="token macro property">print!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h2><p>Rust的字符不仅仅包含ASCII，所有的Unicode字符都可以作为Rust的字符。由于Unicode字符是4个字节编码，因此字符类型也是占用4个字节。</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token char">'中'</span><span class="token punctuation">;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"字符'中'占用了{}字节的内存大小"</span><span class="token punctuation">,</span><span class="token namespace">std<span class="token punctuation">::</span>mem<span class="token punctuation">::</span></span><span class="token function">size_of_val</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="单元类型"><a href="#单元类型" class="headerlink" title="单元类型"></a>单元类型</h2><p>Rust中的单元类型就是<code>()</code>，它的唯一取值也就是<code>()</code>。main函数的返回值就是单元类型，因此它并不算是一个无返回值的函数，在Rust中，无返回值的函数有单独定义：<strong>发散函数</strong></p>
<p>()也可以用作map的值，表示不关注具体的值，只关注key。这种用法类似Go的struct{}，特点是不占用任何内存。</p>
<blockquote>
<p>发散函数：把  <code>!</code> 用作返回值的函数就称作发散函数，这类函数永远不会返回，它通常用在一些会导致程序崩溃的函数。</p>
</blockquote>
<h2 id="语句和表达式"><a href="#语句和表达式" class="headerlink" title="语句和表达式"></a>语句和表达式</h2><p>语句是执行一系列操作，但最后不会有返回值。而表达式会在求值后返回一个值。</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">add_with_extra</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">i32</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 语句</span>
    <span class="token keyword">let</span> y <span class="token operator">=</span> y <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// 语句</span>
    x <span class="token operator">+</span> y <span class="token comment">// 表达式</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>调用一个函数是表达式，因为会返回一个值，调用宏也是表达式，用花括号包裹一段代码块，且这段代码块里有返回值也代表它是一个表达式。</p>
<p>PS：表达式不能包含分号</p>
<p>最后，如果编译器发现某个表达式不返回任何值，就会让他隐式返回一个<code>()</code></p>
<h1 id="所有权和借用"><a href="#所有权和借用" class="headerlink" title="所有权和借用"></a>所有权和借用</h1><h2 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h2><p>所有权规则：</p>
<ol>
<li>Rust中每一个值都只被一个变量所拥有，该变量称为值的所有者。</li>
<li>一个值在同一时间只能被一个变量拥有</li>
<li>当所有者离开作用域后，这个<strong>值</strong>就会被丢弃。（这样就不需要GC了）</li>
</ol>
<p><strong>转移所有权</strong></p>
<hr>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>上面的代码首先将5绑定到变量x，接着拷贝x的值赋给y，最终x和y都等于5。这看上去与我们的所有权规则有点冲突，但实际上，因为基本类型的大小都是已知的，所以他们都会分配在栈上。而对于值在栈上的变量，因为一旦离开作用域就会被回收掉，所以并不需要利用所有权进行跟踪。</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>但上面的这段代码就有点区别了，因为String是一种复杂类型，编译期无法知晓它最终的大小，因此它黑背分配到堆上。而对于堆上的值，所有权就有用武之地了。当s1被赋给s2之后，s1就失去了对应值的所有权，也就无法在程序中接着使用他了。</p>
<blockquote>
<p>如果一个值可以有多个所有者，那么在变量离开作用域之后可能就会导致多次内存释放，这会导致内存污染。因此Rust采取了所有者规则来解决这个问题。</p>
</blockquote>
<p><strong>深拷贝</strong></p>
<hr>
<p>Rust永远不会自动创建数据的深拷贝，因此任何自动的复制操作都不会对内存有较大影响。如果我们确实需要深拷贝，那么可以调用对应的clone()方法。此时会在堆上分配一块新的内存空间，并将所有权交给新的变量，对原来变量的所有权没有影响。</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"s1 = {}, s2 = {}"</span><span class="token punctuation">,</span> s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>浅拷贝</strong></p>
<hr>
<p>浅拷贝只会发生在栈上，所有在编译时已知大小的类型，都会被分配在栈上。因此栈上基本类型的拷贝并不会导致所有权丢失，因为所有权针对的是堆中的数据。</p>
<p>Rust有一个叫Copy的特征，它可以用在可以在栈中存储的类型，如果一个类型拥有Copy特征，就代表它的拷贝不会导致所有权的移动，拷贝以及原值都可以继续使用。</p>
<p><strong>函数传值与返回</strong></p>
<hr>
<p>将值传递给函数，也会发生移动或复制</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// s 进入作用域</span>

    <span class="token function">takes_ownership</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// s 的值移动到函数里 ...</span>
                                    <span class="token comment">// ... 所以到这里不再有效</span>

    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>                      <span class="token comment">// x 进入作用域</span>

    <span class="token function">makes_copy</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// x 应该移动函数里，</span>
                                    <span class="token comment">// 但 i32 是 Copy 的，所以在后面可继续使用 x</span>

<span class="token punctuation">}</span> <span class="token comment">// 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，</span>
  <span class="token comment">// 所以不会有特殊操作</span>

<span class="token keyword">fn</span> <span class="token function-definition function">takes_ownership</span><span class="token punctuation">(</span>some_string<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// some_string 进入作用域</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> some_string<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token comment">// 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放</span>

<span class="token keyword">fn</span> <span class="token function-definition function">makes_copy</span><span class="token punctuation">(</span>some_integer<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// some_integer 进入作用域</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> some_integer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token comment">// 这里，some_integer 移出作用域。不会有特殊操作</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>部分move</strong></p>
<p>Rust还有一个概念叫部分move，如果一个复杂类型P中包含其他复杂类型A，B，C，那么如果其中某一个变量的所有权丢失了，我们就无法访问P这个整体。但我们仍可以直接访问那些没有丢失所有权的部分。</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">
<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token attribute attr-name">#[derive(Debug)]</span>
    <span class="token keyword">struct</span> <span class="token type-definition class-name">Person</span> <span class="token punctuation">{</span>
        name<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span>
        age<span class="token punctuation">:</span> <span class="token class-name">Box</span><span class="token operator">&lt;</span><span class="token keyword">u8</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
        name<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"Alice"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        age<span class="token punctuation">:</span> <span class="token class-name">Box</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment">// 通过这种解构式模式匹配，person.name 的所有权被转移给新的变量 `name`</span>
    <span class="token comment">// 但是，这里 `age` 变量却是对 person.age 的引用, 这里 ref 的使用相当于: let age = &amp;person.age </span>
    <span class="token keyword">let</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span> name<span class="token punctuation">,</span> <span class="token keyword">ref</span> age <span class="token punctuation">}</span> <span class="token operator">=</span> person<span class="token punctuation">;</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The person's age is {}"</span><span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The person's name is {}"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Error! 原因是 person 的一部分已经被转移了所有权，因此我们无法再使用它</span>
    <span class="token comment">//println!("The person struct is {:?}", person);</span>

    <span class="token comment">// 虽然 `person` 作为一个整体无法再被使用，但是 `person.age` 依然可以使用</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The person's age from person struct is {}"</span><span class="token punctuation">,</span> person<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="引用与借用"><a href="#引用与借用" class="headerlink" title="引用与借用"></a>引用与借用</h2><p>如果Rust仅仅支持转移所有权来传递一个值，那显然是非常低效的，并且会让程序变得格外复杂。因此Rust引入了引用和借用。</p>
<p>常规的引用就是一个普通的指针类型，它指向了对象存储的内存地址，但并不具有指向对象的所有权。因此这不会导致我们在传递参数时就丢失指定对象的所有权，因为指针类型属于直接分配在栈上的基本类型，因此他在拷贝时不会涉及所有权的转移。下面是引用的一般用法。</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> len <span class="token operator">=</span> <span class="token function">calculate_length</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The length of '{}' is {}."</span><span class="token punctuation">,</span> s1<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">calculate_length</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">usize</span> <span class="token punctuation">{</span>
    s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>一般来说，引用都是不可变引用，也就是他们无法修改指向对象中的内容。</p>
<p>但Rust同样也支持可变引用，只需要确保引用指向的内容是可变的，并且该引用被声明为可变引用。这样我们就可以通过引用进行修改。</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">change</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">change</span><span class="token punctuation">(</span>some_string<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    some_string<span class="token punctuation">.</span><span class="token function">push_str</span><span class="token punctuation">(</span><span class="token string">", world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>但要注意的是，特定数据的可变引用在相同作用域内只能存在一个。这种限制的好处在于可以<strong>避免数据竞争</strong>。通常情况下，我们会用大括号手动限制引用的作用域，离开作用域后我们就可以创建一个新的引用。</p>
<p>可变引用还有一个限制就是不可以和不可变引用在相同作用域中同时存在，因为不可变引用显然不希望有谁在自己的作用域内对目标进行修改。</p>
<blockquote>
<p>Rust中引用的作用域是从它创建开始，到它被最后一次使用截止。不像变量那样以函数或花括号为界限。</p>
</blockquote>
<p>Rust还对悬垂引用做了限制，如果一个指针指向的值已经被释放，那么Rust编译器会直接报错。</p>
<h1 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h1><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片允许我们引用集合中部分连续的元素序列，而不是引用整个集合。而在字符串中，切片就是对String类型中某一部分的引用。</p>
<p>切片引用通常占用2个字（64位系统中就是16字节）大小的空间。切片的第一个字是指向数据的指针，第二个字是切片的长度。</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"Hello, World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> hello <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> world <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> hello<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> world<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>在对字符串使用切片时必须格外小心，因为Rust字符串使用UTF-8编码，因此如果字符串中有中文，必须按照1个中文3个字节的方式截取。</p>
</blockquote>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">
<span class="token attribute attr-name">#![allow(unused)]</span>
<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">"中国人"</span><span class="token punctuation">;</span>
 <span class="token comment">// 这里会报错，因为一个中文占3个字节，只截取两个字节无法正确解码</span>
 <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">..</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串就是由字符组成的连续集合，Rust中字符串是UTF-8编码。</p>
<p>Rust在语言级别只有一种字符串类型：<code>str</code>，它通常以引用类型出现，也就是字符串切片。str类型是硬编码进可执行文件，无法被修改的类型。但是<code>String</code>类型则是可修改，可增长的字符串类型。</p>
<p>二者的转换方式：</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// &amp;str转String</span>
    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// String转&amp;str</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">as_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    s <span class="token operator">=</span> <span class="token operator">&amp;</span>a
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>PS：Rust的字符串不提供索引，因为Rust字符串底层使用u8类型存储字符的编码，也就是说对于不同的字符，我们的访问方式也会不同。例如：英文字符串与中文字符串同时访问索引为0的位置，前者可以获取一个英文字母而后者只是获取了某个字的组成部分。</p>
<p>字符串的具体操作比较多，这里不多赘述，需要的时候直接查询即可 <a target="_blank" rel="noopener" href="https://course.rs/basic/compound-type/string-slice.html#%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2">操作字符串</a>。要注意的一点是，字符串的所有操作全都基于底层的字节数组，因此如果操作涉及_索引_（虽然Rust没有索引，但这里懂什么意思就行），就必须要考虑存储字符的编码。</p>
<p><strong>操作UTF-8字符串</strong></p>
<hr>
<p>字符</p>
<p>如果要以Unicode字符的方式遍历字符串，最好使用<code>chars</code>方法</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">for</span> c <span class="token keyword">in</span> <span class="token string">"中国人"</span><span class="token punctuation">.</span><span class="token function">chars</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>字节</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">for</span> b <span class="token keyword">in</span> <span class="token string">"中国人"</span><span class="token punctuation">.</span><span class="token function">bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>获取子串</p>
<p>如果想要准确的从UTF-8字符串中获取子串，需要使用额外的库 <a target="_blank" rel="noopener" href="https://crates.io/crates/utf8_slice">utf8_slice</a></p>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>定义结构体</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">struct</span> <span class="token type-definition class-name">User</span> <span class="token punctuation">{</span>
	active<span class="token punctuation">:</span> <span class="token keyword">bool</span><span class="token punctuation">,</span>
	username<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span>
	email<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span>
	sign_in_count<span class="token punctuation">:</span> <span class="token keyword">u64</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建结构体实例</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> user1 <span class="token operator">=</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
	email<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"someone@example.com"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	username<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"someusername123"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	active<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
	sign_in_count<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>PS：<strong>初始化实例时每个字段都要初始化</strong></p>
<p>如果结构体字段与传入的参数名相同，可以进行简化</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token comment">// 简化前</span>
<span class="token keyword">fn</span> <span class="token function-definition function">build_user</span><span class="token punctuation">(</span>email<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> username<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
    <span class="token class-name">User</span> <span class="token punctuation">{</span>
        email<span class="token punctuation">:</span> email<span class="token punctuation">,</span>
        username<span class="token punctuation">:</span> username<span class="token punctuation">,</span>
        active<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
        sign_in_count<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 简化后</span>
<span class="token keyword">fn</span> <span class="token function-definition function">build_user</span><span class="token punctuation">(</span>email<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> username<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
    <span class="token class-name">User</span> <span class="token punctuation">{</span>
        email<span class="token punctuation">,</span>
        username<span class="token punctuation">,</span>
        active<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
        sign_in_count<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>结构体更新语法，如果我们想通过同类型的结构体实例来创建一个新的结构体实例，可以使用一种简化的语法。</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token comment">// 简化前</span>
<span class="token keyword">let</span> user2 <span class="token operator">=</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
        active<span class="token punctuation">:</span> user1<span class="token punctuation">.</span>active<span class="token punctuation">,</span>
        username<span class="token punctuation">:</span> user1<span class="token punctuation">.</span>username<span class="token punctuation">,</span>
        email<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"another@example.com"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        sign_in_count<span class="token punctuation">:</span> user1<span class="token punctuation">.</span>sign_in_count<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 简化后</span>
<span class="token keyword">let</span> user2 <span class="token operator">=</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
        email<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"another@example.com"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">..</span>user1
    <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>..</code>表示凡是没有显式声明的字段，都从user1中获取（这中间会发生所有权转移哦）。</p>
<p><strong>元组结构体</strong></p>
<hr>
<p>结构体必须要有名称，但结构体的字段不一定要有名称，因此没有字段名称的结构体就是元组结构体，他们通常用在我们希望结构体有一个整体名称，但又不需要字段名的时候</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">struct</span> <span class="token type-definition class-name">Color</span><span class="token punctuation">(</span><span class="token keyword">i32</span><span class="token punctuation">,</span> <span class="token keyword">i32</span><span class="token punctuation">,</span> <span class="token keyword">i32</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token type-definition class-name">Point</span><span class="token punctuation">(</span><span class="token keyword">i32</span><span class="token punctuation">,</span> <span class="token keyword">i32</span><span class="token punctuation">,</span> <span class="token keyword">i32</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> black <span class="token operator">=</span> <span class="token class-name">Color</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> origin <span class="token operator">=</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p><strong>单元结构体</strong></p>
<hr>
<p>如果我们不关心结构体需要的字段，只关心它的行为，就可以使用单元结构体。</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">struct</span> <span class="token type-definition class-name">AlwaysEqual</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> subject <span class="token operator">=</span> <span class="token class-name">AlwaysEqual</span><span class="token punctuation">;</span>

<span class="token comment">// 我们不关心 AlwaysEqual 的字段数据，只关心它的行为，因此将它声明为单元结构体，然后再为它实现某个特征</span>
<span class="token keyword">impl</span> <span class="token class-name">SomeTrait</span> <span class="token keyword">for</span> <span class="token class-name">AlwaysEqual</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p><strong>结构体数据的所有权</strong></p>
<hr>
<p>很多情况下我们希望结构体能够拥有专属于自身的值，而不是从其他结构体里借用一个值。如果一定要借用，我们必须要添上声明周期，避免借用值的生命周期比借用者小。</p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举类型是一个类型，包含所有可能的枚举成员，枚举中的内容可以看成是一系列基础类型和复杂类型的集合。</p>
<p>Rust中的枚举可以直接将信息关联到枚举成员上</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">enum</span> <span class="token type-definition class-name">PokerCard</span> <span class="token punctuation">{</span>
    <span class="token class-name">Clubs</span><span class="token punctuation">(</span><span class="token keyword">u8</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token class-name">Spades</span><span class="token punctuation">(</span><span class="token keyword">u8</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token class-name">Diamonds</span><span class="token punctuation">(</span><span class="token keyword">u8</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token class-name">Hearts</span><span class="token punctuation">(</span><span class="token keyword">u8</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>并且每个枚举成员关联的信息类型还可以有所不同。任何类型的数据都可以放入枚举中</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">enum</span> <span class="token type-definition class-name">Message</span> <span class="token punctuation">{</span>
    <span class="token class-name">Quit</span><span class="token punctuation">,</span>
    <span class="token class-name">Move</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token keyword">i32</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token class-name">Write</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token class-name">ChangeColor</span><span class="token punctuation">(</span><span class="token keyword">i32</span><span class="token punctuation">,</span> <span class="token keyword">i32</span><span class="token punctuation">,</span> <span class="token keyword">i32</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>Option枚举</strong></p>
<p>Option枚举是Rust中用于处理空值的一种手段，它的定义如下：</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">enum</span> <span class="token type-definition class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token class-name">None</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>相比于null，Option的优势在于，它可以让可能会出现空指针异常的情况直接在编译期就被察觉。例如 a + b这个简单的运算，如果二者中有一个为空，就会导致程序出现异常，但如果使用Option，因为它不可以与其他类型进行加法运算，因此我们必须先从里面取出值，期间需要判断是否是有效值。这就保证了所有参与程序运算的值都是有效值，而被Option包裹的则可能是无效值。</p>
<p>一个简单的链表实现</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token class-name">List</span><span class="token punctuation">::</span><span class="token operator">*</span><span class="token punctuation">;</span>

<span class="token keyword">pub</span> <span class="token keyword">enum</span> <span class="token type-definition class-name">List</span> <span class="token punctuation">{</span>
    <span class="token class-name">Cons</span><span class="token punctuation">(</span><span class="token keyword">u32</span><span class="token punctuation">,</span> <span class="token class-name">Box</span><span class="token operator">&lt;</span><span class="token class-name">List</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token class-name">Nil</span>
<span class="token punctuation">}</span>

<span class="token comment">// 为链表添加功能</span>
<span class="token keyword">impl</span> <span class="token class-name">List</span> <span class="token punctuation">{</span>
    <span class="token comment">// 创建一个空链表</span>
    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">List</span> <span class="token punctuation">{</span>
        <span class="token class-name">Nil</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">prepend</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> elem<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">List</span> <span class="token punctuation">{</span>
        <span class="token comment">// 头插法，此时传入的是一个链表的值，以及待插入的元素</span>
        <span class="token comment">// 返回一个新结点，并将self的所有权交给新的Box</span>
        <span class="token class-name">Cons</span><span class="token punctuation">(</span>elem<span class="token punctuation">,</span> <span class="token class-name">Box</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">len</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">u32</span> <span class="token punctuation">{</span>
        <span class="token comment">// &amp;self是一个&amp;List，因此这里需要解除引用</span>
        <span class="token comment">// 此时self里面存储的就是持有所有权的实际值,但我们不能拿走后一个节点的所有权,</span>
        <span class="token comment">// 不然会导致他被drop掉,因此使用引用来处理</span>

        <span class="token comment">// 如果我们不解除引用,那么就不必加上ref,因为此时的tail直接就是一个引用了</span>
        <span class="token keyword">match</span> <span class="token operator">*</span><span class="token keyword">self</span> <span class="token punctuation">{</span>
            <span class="token class-name">Cons</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> <span class="token keyword">ref</span> tail<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token number">1</span> <span class="token operator">+</span> tail<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token class-name">Nil</span> <span class="token operator">=&gt;</span> <span class="token number">0</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">stringify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">String</span> <span class="token punctuation">{</span>
        <span class="token keyword">match</span> <span class="token operator">*</span><span class="token keyword">self</span> <span class="token punctuation">{</span>
            <span class="token class-name">Cons</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> <span class="token keyword">ref</span> tail<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token macro property">format!</span><span class="token punctuation">(</span><span class="token string">"{}, {}"</span><span class="token punctuation">,</span> head<span class="token punctuation">,</span> tail<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span>
            <span class="token class-name">Nil</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token macro property">format!</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>Rust中的数组直接分配在栈上，因此拥有非常优秀的性能，但缺点就是无法扩容，这也代表着我们数组的长度必须在编译期已知，也就是我们不能通过获取运行时参数来创建数组。与之相对的，还有动态数组<code>Vec</code>，它具备动态扩容的能力，被分配在堆上。</p>
<p>数组类型声明</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> a<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token keyword">i32</span><span class="token punctuation">;</span> <span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 初始化一个某个值重复出现N次的数组</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">;</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 3这个元素出现5次</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果数组元素不是基本类型，那么就需要注意了</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面这段代码会抛出错误，因为数组的这种语法是通过Copy特征来实现的，但是对于复杂类型，由于他们没有实现Copy特征，因此不能使用这种语法。</p>
<p>而解决方案就是使用<code>std::array::from_fn</code>函数</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> array<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">String</span><span class="token punctuation">;</span> <span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token namespace">core<span class="token punctuation">::</span>array<span class="token punctuation">::</span></span><span class="token function">from_fn</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>i<span class="token closure-punctuation punctuation">|</span></span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"rust is good!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<h1 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h1><h2 id="match匹配"><a href="#match匹配" class="headerlink" title="match匹配"></a>match匹配</h2><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">match</span> target <span class="token punctuation">{</span>
    模式<span class="token number">1</span> <span class="token operator">=&gt;</span> 表达式<span class="token number">1</span><span class="token punctuation">,</span>
    模式<span class="token number">2</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        语句<span class="token number">1</span><span class="token punctuation">;</span>
        语句<span class="token number">2</span><span class="token punctuation">;</span>
        表达式<span class="token number">2</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    _ <span class="token operator">=&gt;</span> 表达式<span class="token number">3</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>将模式与target匹配，即为模式匹配。match后紧跟的是一个表达式，这和if很像，但是if要求表达式的返回值必须是bool。而match则可以接收任何返回值的表达式，只要能和模式进行匹配即可。</p>
<p>PS：match本身也是个表达式，因此可以用它来赋值。</p>
<p><strong>模式绑定</strong></p>
<hr>
<p>模式匹配的另一个功能是从模式中取出绑定的值。</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">enum</span> <span class="token type-definition class-name">Action</span> <span class="token punctuation">{</span>
    <span class="token class-name">Say</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token class-name">MoveTo</span><span class="token punctuation">(</span><span class="token keyword">i32</span><span class="token punctuation">,</span> <span class="token keyword">i32</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token class-name">ChangeColorRGB</span><span class="token punctuation">(</span><span class="token keyword">u16</span><span class="token punctuation">,</span> <span class="token keyword">u16</span><span class="token punctuation">,</span> <span class="token keyword">u16</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> actions <span class="token operator">=</span> <span class="token punctuation">[</span>
        <span class="token class-name">Action</span><span class="token punctuation">::</span><span class="token class-name">Say</span><span class="token punctuation">(</span><span class="token string">"Hello Rust"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token class-name">Action</span><span class="token punctuation">::</span><span class="token class-name">MoveTo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token class-name">Action</span><span class="token punctuation">::</span><span class="token class-name">ChangeColorRGB</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> action <span class="token keyword">in</span> actions <span class="token punctuation">{</span>
        <span class="token keyword">match</span> action <span class="token punctuation">{</span>
            <span class="token class-name">Action</span><span class="token punctuation">::</span><span class="token class-name">Say</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span>
            <span class="token class-name">Action</span><span class="token punctuation">::</span><span class="token class-name">MoveTo</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"point from (0, 0) move to ({}, {})"</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span>
            <span class="token class-name">Action</span><span class="token punctuation">::</span><span class="token class-name">ChangeColorRGB</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> g<span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"change color into '(r:{}, g:{}, b:0)', 'b' has been ignored"</span><span class="token punctuation">,</span>
                    r<span class="token punctuation">,</span> g<span class="token punctuation">,</span>
                <span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面的代码中，如果action匹配<code>Action::Say</code>，就会将里面的值绑定到s中。注意，<strong>这里也会发生所有权转移</strong></p>
<p>Rust中match要求穷尽匹配，也就是匹配出target的所有可能结果，如果我们不需要匹配出所有的可能性，那么可以使用<code>_</code>进行匹配，它会自动匹配所有没有提到的模式。</p>
<p><strong>if let匹配</strong></p>
<p>如果我们只有一个匹配条件，那么可以使用if let实现，而不需要使用match。</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token number">3u8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=</span> v <span class="token punctuation">{</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"three"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>和if let类似的一种匹配语法是<code>while let</code>，它会一直匹配到模式无法匹配的时候</p>
<p><strong>matches!宏</strong></p>
<p>Rust中提供了matches!宏，它可以将一个表达式跟模式匹配，然后返回匹配结果。</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> foo <span class="token operator">=</span> <span class="token char">'f'</span><span class="token punctuation">;</span>
<span class="token macro property">assert!</span><span class="token punctuation">(</span><span class="token macro property">matches!</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> <span class="token char">'A'</span><span class="token punctuation">..=</span><span class="token char">'Z'</span> <span class="token operator">|</span> <span class="token char">'a'</span><span class="token punctuation">..=</span><span class="token char">'z'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> bar <span class="token operator">=</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property">assert!</span><span class="token punctuation">(</span><span class="token macro property">matches!</span><span class="token punctuation">(</span>bar<span class="token punctuation">,</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">if</span> x <span class="token operator">&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>@绑定</strong></p>
<p>如果我们想要在match中对结构体中的字段进行变量绑定，方法在上文中已经提到。但如果我们想在绑定变量的同时还要限定分支范围，就需要用到@绑定</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">enum</span> <span class="token type-definition class-name">Message</span> <span class="token punctuation">{</span>
    <span class="token class-name">Hello</span> <span class="token punctuation">{</span> id<span class="token punctuation">:</span> <span class="token keyword">i32</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> msg <span class="token operator">=</span> <span class="token class-name">Message</span><span class="token punctuation">::</span><span class="token class-name">Hello</span> <span class="token punctuation">{</span> id<span class="token punctuation">:</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">match</span> msg <span class="token punctuation">{</span>
	<span class="token comment">// 这里首先匹配id是否在3到7之内，接着将这个字段绑定到id_variable上</span>
    <span class="token class-name">Message</span><span class="token punctuation">::</span><span class="token class-name">Hello</span> <span class="token punctuation">{</span> id<span class="token punctuation">:</span> id_variable <span class="token operator">@</span> <span class="token number">3</span><span class="token punctuation">..=</span><span class="token number">7</span> <span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Found an id in range: {}"</span><span class="token punctuation">,</span> id_variable<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token class-name">Message</span><span class="token punctuation">::</span><span class="token class-name">Hello</span> <span class="token punctuation">{</span> id<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">..=</span><span class="token number">12</span> <span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Found an id in another range"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 这里直接将id绑定到局部变量id上</span>
    <span class="token class-name">Message</span><span class="token punctuation">::</span><span class="token class-name">Hello</span> <span class="token punctuation">{</span> id <span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Found some other id: {}"</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>Rust的方法通常与结构体，枚举以及特征一起使用。示例如下：</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">struct</span> <span class="token type-definition class-name">Circle</span> <span class="token punctuation">{</span>
    x<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span>
    y<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span>
    radius<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> <span class="token class-name">Circle</span> <span class="token punctuation">{</span>
    <span class="token comment">// new是Circle的关联函数，因为它的第一个参数不是self，且new并不是关键字</span>
    <span class="token comment">// 这种方法往往用于初始化当前结构体的实例</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">new</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">,</span> radius<span class="token punctuation">:</span> <span class="token keyword">f64</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Circle</span> <span class="token punctuation">{</span>
        <span class="token class-name">Circle</span> <span class="token punctuation">{</span>
            x<span class="token punctuation">:</span> x<span class="token punctuation">,</span>
            y<span class="token punctuation">:</span> y<span class="token punctuation">,</span>
            radius<span class="token punctuation">:</span> radius<span class="token punctuation">,</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Circle的方法，&amp;self表示借用当前的Circle结构体</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">area</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">f64</span> <span class="token punctuation">{</span>
        <span class="token namespace">std<span class="token punctuation">::</span></span><span class="token keyword">f64</span><span class="token punctuation">::</span><span class="token namespace">consts<span class="token punctuation">::</span></span><span class="token constant">PI</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>radius <span class="token operator">*</span> <span class="token keyword">self</span><span class="token punctuation">.</span>radius<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到，Rust中对象和方法的定义是分离的，这给我们提供了更多的灵活性（感觉有点问题）。</p>
<p>如果要让一个方法与某个特定的实例绑定，那就需要在参数中添加<code>self</code>，<code>&amp;self</code>，<code>&amp;mut self</code>。这个参数就代表着要执行当前方法的对应实例。而实例对应的类型则是<code>Self</code>。因此<code>self</code>实际上就是<code>self: Self</code>的简写，这里同样涉及到所有权的转移。</p>
<p>如果我们想要调用某个方法，可以直接使用<code>.</code>运算符，而不需要关注作用的对象是否是引用，因为Rust会自动引用或解引用。</p>
<p>在上面的例子中，我们还看到<code>new</code>方法的参数中没有<code>self</code>，这代表它是结构体的关联函数，可以类比为静态方法。通常，我们用new作为构造器方法的名称。</p>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p><strong>函数中使用泛型</strong></p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">largest</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>list<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span><span class="token class-name">T</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">T</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果我们想要在函数中进行比较操作，那么还需要确保泛型是可以比较的，在Rust中就是要求传入的类型实现了对应的特征。</p>
<p><strong>结构体中使用泛型</strong></p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">struct</span> <span class="token type-definition class-name">Point</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    x<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">,</span>
    y<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>方法中使用泛型</strong></p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">struct</span> <span class="token type-definition class-name">Point</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    x<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">,</span>
    y<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token class-name">Point</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">x</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token class-name">T</span> <span class="token punctuation">{</span>
        <span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">.</span>x
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 为具体的泛型定义方法</span>
<span class="token keyword">impl</span> <span class="token class-name">Point</span><span class="token operator">&lt;</span><span class="token keyword">f32</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">distance_from_origin</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">f32</span> <span class="token punctuation">{</span>
        <span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>x<span class="token punctuation">.</span><span class="token function">powi</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">self</span><span class="token punctuation">.</span>y<span class="token punctuation">.</span><span class="token function">powi</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// ----------------</span>

<span class="token keyword">struct</span> <span class="token type-definition class-name">Point</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">U</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    x<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">,</span>
    y<span class="token punctuation">:</span> <span class="token class-name">U</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>


<span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">U</span><span class="token operator">&gt;</span> <span class="token class-name">Point</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">U</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
<span class="token comment">// 方法中也可以增加额外的泛型参数</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">mixup</span><span class="token operator">&lt;</span><span class="token class-name">V</span><span class="token punctuation">,</span> <span class="token class-name">W</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token class-name">Point</span><span class="token operator">&lt;</span><span class="token class-name">V</span><span class="token punctuation">,</span> <span class="token class-name">W</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Point</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">W</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
        <span class="token class-name">Point</span> <span class="token punctuation">{</span>
            x<span class="token punctuation">:</span> <span class="token keyword">self</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span>
            y<span class="token punctuation">:</span> other<span class="token punctuation">.</span>y<span class="token punctuation">,</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Rust中的泛型对于运行时效率几乎没有任何影响，因为它是通过单态化实现的。编译器在编译时会获取泛型所有可能的取值，然后为他们生成对应的对象。例如<code>Option&lt;T&gt;</code>，如果我使用到了<code>Option&lt;i32&gt;</code>，那么编译器就会生成Option_i32这个数据结构。</p>
<p>这样做的好处是对运行时效率几乎没有任何影响，而缺点是降低了编译速度，并且增大了最终生成文件的大小。</p>
<p><strong>默认泛型类型参数</strong></p>
<hr>
<p>Rust中使用泛型参数时，可以为其指定一个默认的具体类型</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">trait</span> <span class="token type-definition class-name">Add</span><span class="token operator">&lt;</span><span class="token constant">RHS</span><span class="token operator">=</span><span class="token keyword">Self</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
	<span class="token keyword">type</span> <span class="token type-definition class-name">Output</span><span class="token punctuation">;</span>
	<span class="token keyword">fn</span> <span class="token function-definition function">add</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> rhs<span class="token punctuation">:</span> <span class="token constant">RHS</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">Self</span><span class="token punctuation">::</span><span class="token class-name">Output</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里Add里面添加了默认的泛型参数，默认就是调用者的类型</p>
<p><strong>const泛型</strong></p>
<p><a target="_blank" rel="noopener" href="https://zh.practice.rs/generics-traits/const-generics.html#%E7%A4%BA%E4%BE%8B">参考资料1</a>  <a target="_blank" rel="noopener" href="https://course.rs/basic/trait/generic.html#const-%E6%B3%9B%E5%9E%8Brust-151-%E7%89%88%E6%9C%AC%E5%BC%95%E5%85%A5%E7%9A%84%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7">参考资料2</a></p>
<h1 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h1><p>Rust中的接口用于将某些行为抽象出来，作用类似于接口。比如上面的加法泛型函数，我们需要限定传入参数都实现了加法特征</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">add</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token namespace">std<span class="token punctuation">::</span>ops<span class="token punctuation">::</span></span><span class="token class-name">Add</span><span class="token operator">&lt;</span><span class="token class-name">Output</span> <span class="token operator">=</span> <span class="token class-name">T</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">(</span>a<span class="token punctuation">:</span><span class="token class-name">T</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span><span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">T</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p> 特征定义了一组可以被共享的行为，只要实现了特征就可以使用这组行为。</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> <span class="token type-definition class-name">FileOp</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">read</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span><span class="token class-name">String</span><span class="token punctuation">;</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">write</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token type-definition class-name">A</span> <span class="token punctuation">{</span>
    name<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> <span class="token class-name">FileOp</span> <span class="token keyword">for</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">read</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span><span class="token class-name">String</span> <span class="token punctuation">{</span>
        <span class="token macro property">format!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> t <span class="token operator">=</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"ok"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>特征定义与实现的位置</strong></p>
<p>如果想要为类型A实现特征T，那么A或者T至少有一个是在当前作用域定义的（所谓当前作用域似乎可以理解为自己写的代码）。这样做的目的是确保他人的代码对于自己只起到增强的作用，而非修改的作用。因为特征与实现中至少有一个是应用在自己这的，不会影响其他部分。</p>
<p>Rust中的特征可以有默认实现，他的语法同普通的方法定一样。这么做的价值在于，实现类没有必要实现那些自己不需要的，或者实现类共用的部分。</p>
<p><strong>使用特征作为函数参数</strong></p>
<p>相当于将接口传递给方法，他的语法如下：</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">notify</span><span class="token punctuation">(</span>item<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">impl</span> <span class="token class-name">Summary</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token punctuation">...</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>特征约束</strong></p>
<p>上面的那种写法仅是一种语法糖，并且它的缺陷在于传入的参数可以是任意的实现类，我们无法实现类似要求多个相同类型实现类的能力。此时就要转用完整格式，他的完整格式如下：</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">notify</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">Summary</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>item<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token punctuation">...</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>&lt;T: Summary&gt;就是特征约束，他表示这个泛型必须是Summary的实现类。</p>
<p>多重约束</p>
<hr>
<p>如果我们想要指定多个约束条件，可以使用如下语法：</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">notify</span><span class="token punctuation">(</span>item<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token keyword">impl</span> <span class="token class-name">Summary</span> <span class="token operator">+</span> <span class="token class-name">Display</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">// 或</span>
<span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">notify</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">Summary</span> <span class="token operator">+</span> <span class="token class-name">Display</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>item<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>Where 约束</p>
<hr>
<p>当约束条件变得很多时，函数的签名就会变得比较复杂，此时可以改用Where约束来进行简化</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">some_function</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">Display</span> <span class="token operator">+</span> <span class="token class-name">Clone</span><span class="token punctuation">,</span> <span class="token class-name">U</span><span class="token punctuation">:</span> <span class="token class-name">Clone</span> <span class="token operator">+</span> <span class="token class-name">Debug</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>t<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">T</span><span class="token punctuation">,</span> u<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">U</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">i32</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">// --&gt;</span>

<span class="token keyword">fn</span> <span class="token function-definition function">some_function</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">U</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>t<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">,</span> u<span class="token punctuation">:</span> <span class="token class-name">U</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">i32</span>
	<span class="token keyword">where</span> <span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">Display</span> <span class="token operator">+</span> <span class="token class-name">Clone</span><span class="token punctuation">,</span>
		  <span class="token class-name">U</span><span class="token punctuation">:</span> <span class="token class-name">Clone</span> <span class="token operator">+</span> <span class="token class-name">Debug</span>
<span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>有条件的实现特征</p>
<hr>
<p>标准库为任何实现了Display特征的类型实现了ToString特性。这可以让所有实现了Display特征的类型同时实现ToString特征。</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">Display</span><span class="token operator">&gt;</span> <span class="token class-name">ToString</span> <span class="token keyword">for</span> <span class="token class-name">T</span> <span class="token punctuation">{</span>
	<span class="token punctuation">...</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>


<p><strong>函数中返回特征实现</strong></p>
<p>可以通过<code>impl Trait</code>来说明一个函数返回了一个实现了某个特征的类型</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">impl</span> <span class="token class-name">Summary</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这就类似于多态，不过在Rust中，这个方法只能返回同种类型的值。如果在某种条件下返回了A，某种条件下返回B。那么即使他们都实现了需要的特征，也无法通过编译。</p>
<p><strong>通过derive派生特征</strong></p>
<p>derive会让编译器帮助我们自动派生出想要的特性，提供的是rust的默认实现。</p>
<h2 id="特征对象"><a href="#特征对象" class="headerlink" title="特征对象"></a>特征对象</h2><p>在上面的内容中讲到，Rust无法在函数中返回多种实现类，同样的，在泛型中也不能直接应用到多种实现类上。究其原因是实现类的大小不确定，如果有多种实现类，Rust无法计算出自己究竟该分配多少内存空间。</p>
<p>因此在需要多种返回值，且类型不确定或者不在当前作用域时可以使用特征对象来实现功能（如果满足上面的条件可以考虑枚举）。</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">trait</span> <span class="token type-definition class-name">Draw</span> <span class="token punctuation">{</span>
	<span class="token keyword">fn</span> <span class="token function-definition function">draw</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">String</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> <span class="token class-name">Draw</span> <span class="token keyword">for</span> <span class="token keyword">u8</span> <span class="token punctuation">{</span>
	<span class="token keyword">fn</span> <span class="token function-definition function">draw</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">String</span> <span class="token punctuation">{</span>
		<span class="token macro property">format!</span><span class="token punctuation">(</span><span class="token string">"u8: {}"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token keyword">self</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> <span class="token class-name">Draw</span> <span class="token keyword">for</span> <span class="token keyword">f32</span> <span class="token punctuation">{</span>
	<span class="token keyword">fn</span> <span class="token function-definition function">draw</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">String</span> <span class="token punctuation">{</span>
		<span class="token macro property">format!</span><span class="token punctuation">(</span><span class="token string">"f32: {}"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token keyword">self</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">draw1</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token class-name">Box</span><span class="token operator">&lt;</span><span class="token keyword">dyn</span> <span class="token class-name">Draw</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	x<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">draw2</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">dyn</span> <span class="token class-name">Draw</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	x<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>dyn</strong>的作用就是表明这是一个特征对象，他会将映射关系存储在一个表中，他可以在运行时通过特征对象查找到具体调用的方法。</p>
<p>不过dyn只需要在特征对象的类型声明上，他也不能单独作为特征对象的定义，因为&amp;和Box的大小都是确定的但dyn修饰的对象没有确定大小，因此它不可以单独出现。</p>
<h2 id="特征对象的动态分发"><a href="#特征对象的动态分发" class="headerlink" title="特征对象的动态分发"></a>特征对象的动态分发</h2><p>Rust的泛型是用静态分发实现的，也就是在编译期为每个泛型类型参数对应的具体类型生成一份代码，整个过程都是在编译期完成的，对于运行时性能没有影响。</p>
<p>与之相对的就是动态分发，dyn使用的就是这种方式。因为编译器无法知晓所有可能用于特征对象代码的类型，也就不知道要调用哪个类型的方法。Rust在运行时使用特征对象中的指针来知晓要调用哪个方法。</p>
<p><img src="https://pic1.zhimg.com/80/v2-b771fe4cfc6ebd63d9aff42840eb8e67_1440w.jpg" alt="动态分发"></p>
<p>特征对象中，<code>ptr</code>指向实现了特征的实际类型。<code>vptr</code>指向虚表<code>vtable</code>，他保存了实现了特征的具体类型的对应方法，当要调用时Rust就到虚标中查找对应的对象与实现。</p>
<p>PS：此时程序只知道它指向了一个具有某个特征的对象，但不了解他具体是什么，因此这里只能调用特征的方法。</p>
<h2 id="特征对象的限制"><a href="#特征对象的限制" class="headerlink" title="特征对象的限制"></a>特征对象的限制</h2><p>不是所有特征都能拥有特征对象，只有对象安全的特征才行。当一个特征的所有方法都有如下属性时，他的对象才是安全的：</p>
<ul>
<li>方法的返回类型不能是Self<br>  有了特征对象就不需要知道实现该特征的具体类型是什么。如果使用了Self，而特征对象忘记了真正的类型，就会出现问题。（这tm是什么情况）</li>
<li>方法没有任何泛型参数<br>  泛型使用静态分发实现，而特征对象在进行动态分发时会抹去集体类型，也就无从得知放入泛型参数的类型是什么。</li>
</ul>
<h2 id="关联类型"><a href="#关联类型" class="headerlink" title="关联类型"></a>关联类型</h2><p>关联类型是在特征定义的语句块中，申明一个自定义类型，就可以在特征的方法签名中使用该类型</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> <span class="token type-definition class-name">Iterator</span> <span class="token punctuation">{</span>
	<span class="token keyword">type</span> <span class="token type-definition class-name">Item</span><span class="token punctuation">;</span>

	<span class="token keyword">fn</span> <span class="token function-definition function">next</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>must <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token keyword">Self</span><span class="token punctuation">::</span><span class="token class-name">Item</span><span class="token operator">&gt;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Self是指调用者的具体类型，Self::Item就是指该类型中定义的Item类型。</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">impl</span> <span class="token class-name">Iterator</span> <span class="token keyword">for</span> <span class="token class-name">Counter</span> <span class="token punctuation">{</span>
	<span class="token keyword">type</span> <span class="token type-definition class-name">Item</span> <span class="token operator">=</span> <span class="token keyword">u32</span><span class="token punctuation">;</span>

	<span class="token keyword">fn</span> <span class="token function-definition function">next</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token keyword">Self</span><span class="token punctuation">::</span><span class="token class-name">Item</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
		<span class="token punctuation">...</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="特殊的方法调用"><a href="#特殊的方法调用" class="headerlink" title="特殊的方法调用"></a>特殊的方法调用</h2><p>不同特征很可能有同名的方法，在Rust中，他会优先调用调用者自身实现的方法。如果我们希望调用它实现的某个特征的方法，例如Human有方法A，但他又实现了特征B定义的A方法，此时如果想要调用特征B的语法，就需要用<code>B::A(&amp;human)</code>，Rust会根据传入的引用类型寻找对应的实现。</p>
<p>除此之外，关联函数也有可能出现同名的情况，但由于关联函数没有self参数，因此上面的语法就行不通了，此时就要使用完全限定语法。<code>&lt;Human as B&gt;::A(...)</code>。</p>
<h2 id="特征定义中的特征约束"><a href="#特征定义中的特征约束" class="headerlink" title="特征定义中的特征约束"></a>特征定义中的特征约束</h2><p>有时我们希望实现某些特征的类已经实现了需要的特征。比如我想要有一个能够以各种形式输出的特征，实现这个特征的前提是已经实现了Display特征，可以转为字符串。</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">trait</span> <span class="token type-definition class-name">OutlinePrint</span><span class="token punctuation">:</span> <span class="token class-name">Display</span> <span class="token punctuation">{</span>
	<span class="token keyword">fn</span> <span class="token function-definition function">outline_print</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">let</span> t <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">...</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面的例子要求实现OutlinePrint的类实现了Display特征</p>
<h2 id="在外部类型上实现外部特征"><a href="#在外部类型上实现外部特征" class="headerlink" title="在外部类型上实现外部特征"></a>在外部类型上实现外部特征</h2><p>前文提到Rust特征与实现类需要遵循孤儿原则，以此避免本地代码与库的相互侵入。但如果我们确实需要绕开孤儿原则，比如给Vec实现Display特征，那我们可以给Vec进行一层封装，创建一个Wrapper结构体，然后让它去实现Display特征。</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span></span>fmt<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token type-definition class-name">Wrapper</span><span class="token punctuation">(</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">impl</span> <span class="token namespace">fmt<span class="token punctuation">::</span></span><span class="token class-name">Display</span> <span class="token keyword">for</span> <span class="token class-name">Wrapper</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">fmt</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> f<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token namespace">fmt<span class="token punctuation">::</span></span><span class="token class-name">Formatter</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token namespace">fmt<span class="token punctuation">::</span></span><span class="token class-name">Result</span> <span class="token punctuation">{</span>
        <span class="token macro property">write!</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token string">"[{}]"</span><span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token number">0</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">", "</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> w <span class="token operator">=</span> <span class="token class-name">Wrapper</span><span class="token punctuation">(</span><span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"w = {}"</span><span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>new type模式非常灵活，唯一的缺点就是调用语句略显繁琐，每次都要用self.0获取内部存储的具体数据。不过Rust提供了Deref特征，实现了它的结构可以自动封装或解包。</p>
<h1 id="Vec"><a href="#Vec" class="headerlink" title="Vec"></a>Vec</h1><p>Rust中的Vec是一种动态数组。</p>
<p><strong>新建vector</strong></p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> v<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token class-name">Vec</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// vec![]创建</span>
<span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>因为使用关联方法new创建对象时，编译器不知道里面究竟会存储什么元素，因此需要指定类型。</p>
<p><strong>更新vector</strong></p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> <span class="token keyword">mut</span> v <span class="token operator">=</span> <span class="token class-name">Vec</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
v<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>这里不需要声明的原因是，编译器可以通过下面的插入代码推断出里面存储什么元素。</p>
<p><strong>读取vector</strong></p>
<p>可以通过索引或get方法获取存储在vector中的值，区别在于索引的方式会出现数组越界的问题，而get方法返回一个Option，更加安全。</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> third<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">i32</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>v<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The third element is {third}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> third<span class="token punctuation">:</span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token operator">&amp;</span><span class="token keyword">i32</span><span class="token operator">&gt;</span> <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">match</span> third <span class="token punctuation">{</span>
        <span class="token class-name">Some</span><span class="token punctuation">(</span>third<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The third element is {third}"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token class-name">None</span> <span class="token operator">=&gt;</span> <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"There is no third element."</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>tricks：</p>
<p>在对vector的读取和更新时也要考虑到所有权和借用规则，比如下面一段代码</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> v <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> first <span class="token operator">=</span> <span class="token operator">&amp;</span>v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    v<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The first element is: {first}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面的代码中，first获取了一个不可变引用，它的作用域持续到了println语句，而在中间vec尝试获取了一个可变引用，这显然破坏了借用规则，所以无法通过编译。虽然这个限制看着非常无理，但实际上，因为vec插入元素可能导致扩容，此时会让之前获取到的引用失效，因此这个限制是很有必要的。</p>
<p><strong>遍历vector</strong></p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">57</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token operator">&amp;</span>v <span class="token punctuation">{</span>
	<span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{i}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> <span class="token keyword">mut</span> v <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">57</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> v <span class="token punctuation">{</span>
	<span class="token operator">*</span>i <span class="token operator">+=</span> <span class="token number">50</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>无论可变还是不可变地遍历一个vector都是安全的，因为一旦获取到了vector中的引用，那么就相当于获取到了一把锁，如果要对vector进行修改，会发现还有可变/不可变引用在作用域内。可变引用不可与不可变引用处于同一作用域，相同作用域中不能有多个可变引用。</p>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><h2 id="借用检查"><a href="#借用检查" class="headerlink" title="借用检查"></a>借用检查</h2><p>为了保证Rust的所有权和借用的正确性，Rust使用借用检查器来确保借用的正确性。当我们将一个引用赋给某个变量之后，编译器会检查这个引用变量的作用域是否小于引用对应的值的作用域，以此来避免出现悬挂引用。</p>
<h2 id="函数中的生命周期"><a href="#函数中的生命周期" class="headerlink" title="函数中的生命周期"></a>函数中的生命周期</h2><p>下面来看一个特殊的例子</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">longest</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token keyword">str</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> x<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> y<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    y
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面这段代码看起来非常完美，但实际上编译器会报错，表示函数的返回值来自于函数的参数，但对他而言无法确定返回值的生命周期是否小于借用参数的生命周期。</p>
<p>也就是说，我们必须让编译器知道这里的返回值的生命周期与借用值的生命周期，这样他才能确保调用后的引用生命周期分析。但实际情况是，即使是人也不知道返回值的生命周期，因为究竟返回哪一个值是运行时决定的。</p>
<p>但实际上我们未必要确切推导出实际的生命周期，我们只要让编译器知道，函数参数会活的比返回值更久即可。因此Rust引入了生命周期标注语法。</p>
<p><strong>重点！！！ 生命周期标注并不会改变任何引用的实际作用域。 它的唯一作用是让编译器了解到多个引用之间的关系，对于实际的作用域不会产生任何影响。</strong></p>
<p>修改上面的函数</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">longest</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'a</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'a</span> <span class="token keyword">str</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'a</span> <span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'a</span> <span class="token keyword">str</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> x<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> y<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    y
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>首先我们声明了一个生命周期&lt;‘a&gt;，然后标记x和y以及返回值的生命周期大于等于’a。这里’a究竟有多久并不重要，因为编译器可以根据这个标注推断出返回值的作用域会与两个参数中较小作用域的那个一致。</p>
<h2 id="结构体中的生命周期"><a href="#结构体中的生命周期" class="headerlink" title="结构体中的生命周期"></a>结构体中的生命周期</h2><p>之前我们在使用结构体时基本就没有用过引用类型的字段，因为非引用类型可以直接将所有权转移到结构体内，从而就不必关心生命周期的问题。</p>
<p>不过要想使用引用类型也并非不可，只需要给结构体中的引用标注上生命周期即可。</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">struct</span> <span class="token type-definition class-name">Excerpt</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'a</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
	part<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'a</span> <span class="token keyword">str</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>上面的这段结构体声明表示，part字段的生命周期大于等于’a，也就是它的生命周期大于结构体的生命周期。</p>
<h2 id="生命周期消除"><a href="#生命周期消除" class="headerlink" title="生命周期消除"></a>生命周期消除</h2><p>参数的生命周期被称为输入生命周期，返回值的生命周期被称为输出生命周期</p>
<p><strong>消除规则</strong></p>
<p>编译器按照3条消除规则来确定哪些场景不需要显示标注生命周期：</p>
<ol>
<li>每一个引用都参数会获取独自的生命周期。对于没有标注生命周期的参数，编译器会给他们每一个都分配一个生命周期。</li>
<li>如果只有一个输入生命周期，则该生命周期会被赋给所有输出生命周期</li>
<li>若存在多个生命周期，且其中有<code>&amp;self</code>或<code>&amp;mut self</code>。就会将self的生命周期赋给所有输出生命周期。</li>
</ol>
<p>如果以上规则无法确定生命周期，就会要求用户手动指定生命周期</p>
<h2 id="静态生命周期"><a href="#静态生命周期" class="headerlink" title="静态生命周期"></a>静态生命周期</h2><p>Rust中有一种特殊的生命周期<code>'static</code>，被他标注的引用的生命周期和整个程序一样久（实际上可能没那么久）</p>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><h2 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h2><p>程序一旦抛出了panic异常，代表它碰到了不可恢复错误，只能终止程序运行。如果我们想要主动抛出panic，可以调用<code>panic!</code>，当这个宏被调用时，程序会打印出一个错误信息，然后展开函数的调用栈，最后退出程序。</p>
<p><strong>panic的使用时机</strong></p>
<ol>
<li>示例，原型，测试：如果正处于开发阶段，那么我们肯定希望优先加快编码速度，因此可以不专门处理错误，直接让程序被动触发panic</li>
<li>确定程序正确：当能够确定某个程序流是正确的时，可以直接用panic</li>
<li>可能导致全局有害状态<ol>
<li>非预期的错误</li>
<li>后续代码的运行受到显著影响</li>
<li>可能导致内存安全问题，比如数组越界</li>
</ol>
</li>
</ol>
<p><strong>panic原理</strong></p>
<ol>
<li>格式化&nbsp;<code>panic</code>&nbsp;信息，然后使用该信息作为参数，调用&nbsp;<code>std::panic::panic_any()</code>&nbsp;函数</li>
<li><code>panic_any</code>&nbsp;会检查应用是否使用了&nbsp;<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/panic/fn.set_hook.html"><code>panic hook</code></a>，如果使用了，该&nbsp;<code>hook</code>&nbsp;函数就会被调用（<code>hook</code>&nbsp;是一个钩子函数，是外部代码设置的，用于在&nbsp;<code>panic</code>&nbsp;触发时，执行外部代码所需的功能）</li>
<li>当&nbsp;<code>hook</code>&nbsp;函数返回后，当前的线程就开始进行栈展开：从&nbsp;<code>panic_any</code>&nbsp;开始，如果寄存器或者栈因为某些原因信息错乱了，那很可能该展开会发生异常，最终线程会直接停止，展开也无法继续进行</li>
<li>展开的过程是一帧一帧的去回溯整个栈，每个帧的数据都会随之被丢弃，但是在展开过程中，你可能会遇到被用户标记为&nbsp;<code>catching</code>&nbsp;的帧（通过&nbsp;<code>std::panic::catch_unwind()</code>&nbsp;函数标记），此时用户提供的&nbsp;<code>catch</code>&nbsp;函数会被调用，展开也随之停止：当然，如果&nbsp;<code>catch</code>&nbsp;选择在内部调用&nbsp;<code>std::panic::resume_unwind()</code>&nbsp;函数，则展开还会继续。</li>
</ol>
<h2 id="传播错误"><a href="#传播错误" class="headerlink" title="传播错误"></a>传播错误</h2><p>Rust定义了一个宏<code>?</code>用于错误传播，因为在程序中很多地方我们面对的并不是不可恢复错误，这时就需要用Result进行处理。</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">panic_test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Result</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token namespace">io<span class="token punctuation">::</span></span><span class="token class-name">Error</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
	<span class="token keyword">let</span> f <span class="token operator">=</span> <span class="token class-name">File</span><span class="token punctuation">::</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"a.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">let</span> <span class="token keyword">mut</span> f <span class="token operator">=</span> <span class="token keyword">match</span> f <span class="token punctuation">{</span>
		<span class="token class-name">Ok</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> f<span class="token punctuation">,</span>
		<span class="token class-name">Err</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">return</span> <span class="token class-name">Err</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">let</span> res <span class="token operator">=</span> f<span class="token punctuation">.</span><span class="token function">read_to_string</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">match</span> res <span class="token punctuation">{</span>
		<span class="token class-name">Ok</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token class-name">Ok</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span>
		<span class="token class-name">Err</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">return</span> <span class="token class-name">Err</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面的代码展示了如何用Result进行错误传播，可以看到代码还是非常繁琐的，并且最关键的问题是我们必须知道要调用的函数都会返回什么错误类型，这又会导致非常繁琐的错误类型转换。</p>
<p>因此接下来我们将介绍<code>?</code>的作用，它可以大幅简化上面的代码</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">panic_test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Result</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Box</span><span class="token operator">&lt;</span><span class="token keyword">dyn</span> <span class="token namespace">std<span class="token punctuation">::</span>error<span class="token punctuation">::</span></span><span class="token class-name">Error</span><span class="token operator">&gt;&gt;</span> <span class="token punctuation">{</span>
	<span class="token keyword">let</span> <span class="token keyword">mut</span> f <span class="token operator">=</span> <span class="token class-name">File</span><span class="token punctuation">::</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"a.txt"</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">;</span>
	<span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	f<span class="token punctuation">.</span><span class="token function">read_to_string</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> s<span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">;</span>
	<span class="token class-name">Ok</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里<code>?</code>的作用就相当于是上面那一大段match的作用，与此同时，<code>?</code>还提供自动转型的功能，也就是说我们只要用一个足够大的错误类型包含所有可能返回的错误类型即可，<code>?</code>会自动替我们转换类型。</p>
<p><code>?</code>除了用于处理Result之外，还可以用于Option的处理，如果返回错误，那么就直接返回一个None。</p>
<p>tips：<code>?</code>必须要有一个变量来承载调用成功的返回值，只有碰到错误值时，他才会直接返回。</p>
<h1 id="包和模块"><a href="#包和模块" class="headerlink" title="包和模块"></a>包和模块</h1><h2 id="Crate"><a href="#Crate" class="headerlink" title="Crate"></a>Crate</h2><p>在Rust中，包是一个独立的可编译单元，它编译后会生成一个可执行文件或一个库</p>
<p>一个包会将相关联的功能打包在一起，方便该功能在多个项目中共享。</p>
<h2 id="Package"><a href="#Package" class="headerlink" title="Package"></a>Package</h2><p>Rust中的Package就是指一个项目，包含独立的<code>Cargo.toml</code>文件，以及因为功能性被组织在一起的一个或多个包。一个Package中只能包含一个库类型的包，但可以包含多个二进制可执行类型的包。</p>
<p>一个Package中可能有多个二进制包，他们往往放在src/bin下，文件名就是包名。</p>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>Rust中创建模块的语法是</p>
<pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">mod</span> <span class="token module-declaration namespace">front_of_house</span> <span class="token punctuation">{</span>
    <span class="token keyword">mod</span> <span class="token module-declaration namespace">hosting</span> <span class="token punctuation">{</span>
        <span class="token keyword">fn</span> <span class="token function-definition function">add_to_waitlist</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

        <span class="token keyword">fn</span> <span class="token function-definition function">seat_at_table</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">mod</span> <span class="token module-declaration namespace">serving</span> <span class="token punctuation">{</span>
        <span class="token keyword">fn</span> <span class="token function-definition function">take_order</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

        <span class="token keyword">fn</span> <span class="token function-definition function">serve_order</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

        <span class="token keyword">fn</span> <span class="token function-definition function">take_payment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过mod关键字来创建模块，再模块中可以定义结构体，函数，方法等。这样我们可以将功能想的代码被组织在一起。</p>
<p>src/main.rs与src/lib.rs是包的根，他们共同构成一个叫<code>crate</code>的模块。因此如果我们要用绝对路径引入<code>front_of_house</code>，对应的语法是<code>use crate::front_of_house</code>。</p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>Rust规定，默认情况下，所有类型都是私有的，甚至模块本身也是私有的。但是父模块对于子模块来说是完全可见的，不过父模块无法访问子模块的私有项。</p>
<p>如果要对外暴露，可以使用pub关键字，需要注意的是，pub修饰枚举之外的东西，都只代表外部可以引用这个东西本身，它内部的方法或变量并不会暴露出去。</p>
<blockquote>
<p>Rust查找模块的逻辑<br>从crate开始查找，看当前所处的包下有没有对应模块名的文件，如果有，那么这个文件就是要找的模块。如果模块被放在一个文件夹里，那么就会到模块名所在的文件夹内查找mod.rs文件或是与模块同名的文件，如果能找到，就代表它是要找的模块</p>
</blockquote>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">首页</a></li>
        
          <li><a href="/about/">关于</a></li>
        
          <li><a href="/archives/">归档</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/probberechts">项目</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Hello-Wrold"><span class="toc-number">1.</span> <span class="toc-text">Hello Wrold</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%BB%91%E5%AE%9A%E4%B8%8E%E8%A7%A3%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">变量绑定与解构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">基本类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">整数类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">浮点数类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97"><span class="toc-number">3.3.</span> <span class="toc-text">序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E7%90%86%E6%95%B0%E5%92%8C%E8%B4%9F%E6%95%B0"><span class="toc-number">3.4.</span> <span class="toc-text">有理数和负数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.5.</span> <span class="toc-text">字符类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.6.</span> <span class="toc-text">单元类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E5%8F%A5%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.7.</span> <span class="toc-text">语句和表达式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E6%9D%83%E5%92%8C%E5%80%9F%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">所有权和借用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E6%9D%83"><span class="toc-number">4.1.</span> <span class="toc-text">所有权</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E4%B8%8E%E5%80%9F%E7%94%A8"><span class="toc-number">4.2.</span> <span class="toc-text">引用与借用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.</span> <span class="toc-text">复合类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%87%E7%89%87"><span class="toc-number">5.1.</span> <span class="toc-text">切片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.2.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">5.3.</span> <span class="toc-text">结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">5.4.</span> <span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">5.5.</span> <span class="toc-text">数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">6.</span> <span class="toc-text">模式匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#match%E5%8C%B9%E9%85%8D"><span class="toc-number">6.1.</span> <span class="toc-text">match匹配</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">7.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">8.</span> <span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%89%B9%E5%BE%81"><span class="toc-number">9.</span> <span class="toc-text">特征</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E5%BE%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">9.1.</span> <span class="toc-text">特征对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E5%BE%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%86%E5%8F%91"><span class="toc-number">9.2.</span> <span class="toc-text">特征对象的动态分发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E5%BE%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">9.3.</span> <span class="toc-text">特征对象的限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.4.</span> <span class="toc-text">关联类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-number">9.5.</span> <span class="toc-text">特殊的方法调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E5%BE%81%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E7%89%B9%E5%BE%81%E7%BA%A6%E6%9D%9F"><span class="toc-number">9.6.</span> <span class="toc-text">特征定义中的特征约束</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E5%A4%96%E9%83%A8%E7%B1%BB%E5%9E%8B%E4%B8%8A%E5%AE%9E%E7%8E%B0%E5%A4%96%E9%83%A8%E7%89%B9%E5%BE%81"><span class="toc-number">9.7.</span> <span class="toc-text">在外部类型上实现外部特征</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vec"><span class="toc-number">10.</span> <span class="toc-text">Vec</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">11.</span> <span class="toc-text">生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%80%9F%E7%94%A8%E6%A3%80%E6%9F%A5"><span class="toc-number">11.1.</span> <span class="toc-text">借用检查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">11.2.</span> <span class="toc-text">函数中的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">11.3.</span> <span class="toc-text">结构体中的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B6%88%E9%99%A4"><span class="toc-number">11.4.</span> <span class="toc-text">生命周期消除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">11.5.</span> <span class="toc-text">静态生命周期</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">12.</span> <span class="toc-text">错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#panic"><span class="toc-number">12.1.</span> <span class="toc-text">panic</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E6%92%AD%E9%94%99%E8%AF%AF"><span class="toc-number">12.2.</span> <span class="toc-text">传播错误</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%85%E5%92%8C%E6%A8%A1%E5%9D%97"><span class="toc-number">13.</span> <span class="toc-text">包和模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Crate"><span class="toc-number">13.1.</span> <span class="toc-text">Crate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Package"><span class="toc-number">13.2.</span> <span class="toc-text">Package</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97"><span class="toc-number">13.3.</span> <span class="toc-text">模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">13.4.</span> <span class="toc-text">可见性</span></a></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://faustpromaxpx.github.io/2023/04/09/rust/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://faustpromaxpx.github.io/2023/04/09/rust/&text=Rust —— 基础篇"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://faustpromaxpx.github.io/2023/04/09/rust/&title=Rust —— 基础篇"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://faustpromaxpx.github.io/2023/04/09/rust/&is_video=false&description=Rust —— 基础篇"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Rust —— 基础篇&body=Check out this article: http://faustpromaxpx.github.io/2023/04/09/rust/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://faustpromaxpx.github.io/2023/04/09/rust/&title=Rust —— 基础篇"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://faustpromaxpx.github.io/2023/04/09/rust/&title=Rust —— 基础篇"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://faustpromaxpx.github.io/2023/04/09/rust/&title=Rust —— 基础篇"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://faustpromaxpx.github.io/2023/04/09/rust/&title=Rust —— 基础篇"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://faustpromaxpx.github.io/2023/04/09/rust/&name=Rust —— 基础篇&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://faustpromaxpx.github.io/2023/04/09/rust/&t=Rust —— 基础篇"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2024
    Zephyr
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/probberechts">项目</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
