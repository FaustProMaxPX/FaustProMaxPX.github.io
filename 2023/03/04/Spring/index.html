<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Spring（面试版） | 狂奔的蜗牛 | 人行，路平</title>

  
  <meta name="author" content="Zephyr">
  

  
  <meta name="description" content="IOC控制反转，本质是将用户手动创建对象的控制权，交给程序来管理。主要目的是借助第三方实现具有依赖关系的对象之间的解耦
将对象之前的依赖关系交给IOC容器来管理，然后由IOC容器完成对象注入。可以很大程度上简化应用的开发。程序员可以从繁杂的对象依赖中挣脱出来，专心于业务代码的开发。

@Compon">
  

  
  
  <meta name="keywords" content="java,Spring,面试">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="Spring（面试版）"/>

  <meta property="og:site_name" content="狂奔的蜗牛"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="狂奔的蜗牛" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 6.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">狂奔的蜗牛</a>
    </h1>
    <p class="site-description">人行，路平</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>Spring（面试版）</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2023/03/04/Spring/" rel="bookmark">
        <time class="entry-date published" datetime="2023-03-04T09:41:35.000Z">
          2023-03-04
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><p>控制反转，本质是将用户手动创建对象的控制权，交给程序来管理。主要目的是借助第三方实现具有依赖关系的对象之间的解耦</p>
<p>将对象之前的依赖关系交给IOC容器来管理，然后由IOC容器完成对象注入。可以很大程度上简化应用的开发。程序员可以从繁杂的对象依赖中挣脱出来，专心于业务代码的开发。</p>
<blockquote>
<p><code>@Component</code>和<code>@Bean</code>的区别</p>
<p><code>@Component</code>通过类路径扫描来自动侦测并自动装配到Spring容器中。<code>@Bean</code>通常是在标有该注解的方法中自定义bean实例。同时，如果我们想要引入第三方库中的类，只能使用<code>@Bean</code>。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://javadoop.com/post/spring-ioc">Spring IOC 容器源码分析</a></p>
<h2 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h2><p>要想更透彻的理解IOC，还需要了解一下依赖倒置原则。</p>
<p>当我们进行设计时，往往会根据下层基础设计上层建筑，这样有一个问题就是上层建筑一旦发生改动，就要从上到下彻底更改，因为我们的上层建筑都是根据底层完成设计的。</p>
<p>依赖导致的思想就是将整个过程反转过来，我们先明确上层建筑需要底层提供什么服务，然后再去进一步设计底层，这样高层就不必关注底层实现，它只需要底层能完成它需要的功能就可以了。</p>
<p>这两种思想体现到代码里就是：</p>
<ol>
<li><p>自下而上设计代表上层需要了解底层相关信息，例如如果我们要新建一个Car实例，首先要了解轮胎有多大，并将这个size传递给Car的构造器，Car构造器会在内部初始化轮胎实例。这样的问题在于，上下两层强耦合，一旦轮胎的初始化方式出现变动，就要修改Car的构造器。</p>
</li>
<li><p>自上而下设计可以避免上下层之间的耦合，因为它只需要知道自己有一个轮胎实例，并且这个轮胎实例提供了自己想要的功能，此时只需要给Car构造器传递轮胎实例即可完成初始化，即使轮胎构造器发生变动，也不会影响到Car。</p>
</li>
</ol>
<p>IOC就是实现依赖倒置的一种思路，它的实现手段就是通过DI（依赖注入）。</p>
<p>在过去的程序设计思路中，A要想使用B，就必须在自己的内部完成B的初始化，这就代表着A必须了解如何初始化B，而一旦引入了IOC容器，A只需要表明自己需要B，即可从IOC容器中获取到B的实例。</p>
<p>在Spring中，通过IOC容器完成DI，它会利用DFS查询某个实例初始化需要哪些依赖，然后将他们全部初始化出来。</p>
<h1 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h1><p>作用域</p>
<table>
<thead>
<tr>
<th>scope</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>singleton</td>
<td>单例</td>
</tr>
<tr>
<td>prototype</td>
<td>原型，容器内可以有任意数量的对象实例</td>
</tr>
<tr>
<td>request</td>
<td>每收到一个新请求就创建一个</td>
</tr>
<tr>
<td>session</td>
<td>每次会话创建一个</td>
</tr>
<tr>
<td>application</td>
<td>每个应用程序创建一个</td>
</tr>
<tr>
<td>websocket</td>
<td>在每个<code>websocket</code>的生存周期中存在一个</td>
</tr>
</tbody></table>
<blockquote>
<p>单例Bean的线程安全问题</p>
<p>多个线程操作同一个对象时是存在资源竞争的（eg：zl的PostBuilder）</p>
<p>解决方案有两个：</p>
<ol>
<li><p>在Bean中尽量避免定义可变的成员变量</p>
</li>
<li><p>在类中定义一个<code>ThreadLocal</code>成员变量，将需要的成员变量放在里面</p>
</li>
</ol>
</blockquote>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul>
<li>Bean 容器找到配置文件中 Spring Bean 的定义。</li>
<li>Bean 容器利用 Java Reflection API 创建一个 Bean 的实例。</li>
<li>如果涉及到一些属性值 利用 <code>set()</code>方法设置一些属性值。</li>
<li>如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用 <code>setBeanName()</code>方法，传入 Bean 的名字。</li>
<li>如果 Bean 实现了 <code>BeanClassLoaderAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <code>ClassLoader</code>对象的实例。</li>
<li>如果 Bean 实现了 <code>BeanFactoryAware</code> 接口，调用 <code>setBeanFactory()</code>方法，传入 <code>BeanFactory</code>对象的实例。</li>
<li>与上面的类似，如果实现了其他 <code>*.Aware</code>接口，就调用相应的方法。</li>
<li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessBeforeInitialization()</code> 方法</li>
<li>如果 Bean 实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</li>
<li>如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。</li>
<li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessAfterInitialization()</code> 方法</li>
<li>当要销毁 Bean 的时候，如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法。</li>
<li>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</li>
</ul>
<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>AOP的核心思想是将那些于业务无关的，但是被业务模块所共用的逻辑或责任封装起来。OOP是对纵向程序流的封装，而AOP则是对横向程序流的封装。</p>
<p>AOP的基础是动态代理，通过代理模式对原有的代码进行增强。</p>
<table>
<thead>
<tr>
<th>术语</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>目标</td>
<td>被代理的对象</td>
</tr>
<tr>
<td>代理</td>
<td>代理对象</td>
</tr>
<tr>
<td>连接点</td>
<td>目标对象中所有定义的方法</td>
</tr>
<tr>
<td>切入点</td>
<td>被切面增强的连接点</td>
</tr>
<tr>
<td>通知</td>
<td>增强逻辑</td>
</tr>
<tr>
<td>切面</td>
<td>切入点+通知</td>
</tr>
</tbody></table>
<h2 id="自调用问题"><a href="#自调用问题" class="headerlink" title="自调用问题"></a>自调用问题</h2><p>Spring AOP借助代理实现，因此它的调用逻辑实际上是：</p>
<p>调用者 -&gt; 代理 -&gt; 实体</p>
<p>因此如果我们直接在实体内调用实体中的方法（自调用），就会导致AOP失效。下面通过一个例子来理解</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyService</span> <span class="token punctuation">{</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token comment">//......</span>
<span class="token punctuation">}</span>
<span class="token annotation punctuation">@Transactional</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">//......</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当我们通过method1()调用method2()时，实际上是this.method2()，这是一个内部调用。也就是说，这个方法调用不会被切面拦截到，这就意味着Spring提供的代理类不会出现在整个调用链里面，注解也就失效了。</p>
<p>而在类外部调用的话，Spring就会发现调用者是个自己要代理的类型，接着就会走代理的逻辑，但是对于this这种自调用，他会认为就是个普通的类内调用，不会进行代理。</p>
<p>要想修复这个问题，可以通过直接获取MyService的代理对象进行方法调用，或者改用AspectJ来实现。</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>Spring支持两种事务：</p>
<ol>
<li><p>编程式事务：在代码内部直接使用TransactionTemplate手动管理事务，维护困难，很少使用。</p>
</li>
<li><p>声明式事务：通过AOP实现，侵入性较小，如<code>@Transactional</code></p>
</li>
</ol>
<h2 id="事务管理接口"><a href="#事务管理接口" class="headerlink" title="事务管理接口"></a>事务管理接口</h2><p>Spring中的事务管理接口包括：</p>
<ul>
<li>**<code>PlatformTransactionManager</code>**： （平台）事务管理器，Spring 事务策略的核心。</li>
<li>**<code>TransactionDefinition</code>**： 事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)。</li>
<li>**<code>TransactionStatus</code>**： 事务运行状态。</li>
</ul>
<p><code>PlatformTransactionManager</code>是事务的上层管理者，她可以获取事务，提交事务或回滚事务，而另外两个是对事务的描述。</p>
<p>事务属性：</p>
<ul>
<li>隔离级别</li>
<li>传播行为</li>
<li>回滚规则</li>
<li>是否只读</li>
<li>事务超时</li>
</ul>
<h2 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h2><p>事务传播行为用于解决业务层方法之间相互调用的问题。当一个事务方法被另一个事务方法调用时，必须指定事务如何传播</p>
<p>常用的事务传播行为：</p>
<ol>
<li><p><strong><code>TransactionDefinition.PROPAGATION_REQUIRED</code></strong></p>
<p>Spring默认的事务传播策略，如果外围方法已经开启事务，就加入事务。否则新开启一个事务。这种传播行为，不管外围还是内部方法抛出异常都会将整个事务回滚。</p>
</li>
<li><p><strong><code>TransactionDefinition.PROPAGATION_REQUIRES_NEW</code></strong></p>
<p>无论如何都会创建一个新事务，如果外围方法已经开启了事务，就把外围事务挂起。如果外围事务回滚，不会影响内部方法的事务。而如果内部方法抛出异常回滚，并且这个异常被外围方法捕获到，也会导致外部事务回滚。</p>
</li>
<li><p><strong><code>TransactionDefinition.PROPAGATION_NESTED</code></strong></p>
<p>如果当前没有事务，新建一个事务。如果已经有了，创建一个嵌套事务。如果内部事务回滚，并且异常逃逸到外部，也会导致外部事务回滚，但如果异常被成功捕获，则不会影响到外部事务。此外，由于内部事务嵌套在外部事务，因此，外部事务回滚也会导致内部事务回滚。</p>
</li>
</ol>
<h2 id="事务回滚规则"><a href="#事务回滚规则" class="headerlink" title="事务回滚规则"></a>事务回滚规则</h2><p>在默认情况下，事务只会在遇到运行时异常或Error时回归，在面对Checked异常时不会进行回滚。</p>
<h1 id="SpringBoot自动装配"><a href="#SpringBoot自动装配" class="headerlink" title="SpringBoot自动装配"></a>SpringBoot自动装配</h1><p>SpringBoot在SpringFramework的基础上借助SPI，进一步优化了自动装配。它会扫描外部引用jar包中的<code>META-INF/spring.factories</code>文件，将文件中的配置信息加载到Spring容器。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>首先看看SpringBoot中的核心注解SpringBootApplication</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span>TYPE<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>
<span class="token annotation punctuation">@Documented</span>
<span class="token annotation punctuation">@Inherited</span>
<span class="token annotation punctuation">@SpringBootConfiguration</span>
<span class="token annotation punctuation">@EnableAutoConfiguration</span>
<span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>
    excludeFilters <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>
    type <span class="token operator">=</span> <span class="token class-name">FilterType</span><span class="token punctuation">.</span>CUSTOM<span class="token punctuation">,</span>
    classes <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token class-name">TypeExcludeFilter</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>
    type <span class="token operator">=</span> <span class="token class-name">FilterType</span><span class="token punctuation">.</span>CUSTOM<span class="token punctuation">,</span>
    classes <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token class-name">AutoConfigurationExcludeFilter</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">}</span>
<span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">SpringBootApplication</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>我们重点要关注的是<code>EnableAutoConfiguration</code></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span>TYPE<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>
<span class="token annotation punctuation">@Documented</span>
<span class="token annotation punctuation">@Inherited</span>
<span class="token annotation punctuation">@AutoConfigurationPackage</span>
<span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token class-name">AutoConfigurationImportSelector</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">EnableAutoConfiguration</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>它里面的核心是<code>AutoConfigurationImportSelector</code>，这个类负责加载自动装配类。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">selectImports</span><span class="token punctuation">(</span><span class="token class-name">AnnotationMetadata</span> annotationMetadata<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isEnabled</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> NO_IMPORTS<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token class-name">AutoConfigurationEntry</span> autoConfigurationEntry <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getAutoConfigurationEntry</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">toStringArray</span><span class="token punctuation">(</span>autoConfigurationEntry<span class="token punctuation">.</span><span class="token function">getConfigurations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>首先会判断是否启用了自动装配，如果启用了，就会去加载自动装配类</p>
<p><img src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/notes/20230304170601.png"></p>
<p>上面的代码是加载自动装配的过程，它首先需要加载所有的自动装配类，先获取所有自动装配类的全限定名，然后到spring.factories文件里读取要加载的类。</p>
<p>接下来进行去重以及筛选等操作</p>
<p>不过到这还有些问题，一个大型项目需要引入的jar包很多，其中会包含大量用不到的类，如果我们一股脑的全部加载，就会使项目启动非常缓慢，因此这里SpringBoot还会做进一步的筛选，将用不到的部分全部剔除。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/笔记/">笔记</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/java/">java</a><a href="/tags/Spring/">Spring</a><a href="/tags/面试/">面试</a>
    </span>
    

    </div>

    
  </div>
</article>

  









    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2024 Zephyr
    
  </p>
</footer>
    
    
  </div>
</div>
</body>
</html>