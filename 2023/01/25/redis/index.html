<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="Zephyr">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="http://FaustProMaxPX.github.io/2023/01/25/redis/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
        <meta name="description" content="实用主义的redis学习日志，使用的资料为《Redis实战》">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis入门">
<meta property="og:url" content="http://faustpromaxpx.github.io/2023/01/25/redis/index.html">
<meta property="og:site_name" content="狂奔的蜗牛">
<meta property="og:description" content="实用主义的redis学习日志，使用的资料为《Redis实战》">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/redis/20220814203913.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/redis/20220814203946.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/redis/20220814204014.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.drawio.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/20230124103337.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/20230124103643.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/redis/NeatReader-1661071382123.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/20230125105755.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/redis/20220823154309.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/redis/20220823154332.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/redis/NeatReader-1661760163701.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/redis/NeatReader-1661844354039.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/redis/20220914144938.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/redis/20220923104227.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/20230126115012.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/20230126115051.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/20230126115612.png">
<meta property="og:image" content="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/20230126120926.png">
<meta property="article:published_time" content="2023-01-25T03:01:27.000Z">
<meta property="article:modified_time" content="2023-03-11T06:50:03.340Z">
<meta property="article:author" content="Zephyr">
<meta property="article:tag" content="redis">
<meta property="article:tag" content="python">
<meta property="article:tag" content="缓存">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/redis/20220814203913.png">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/favicon.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.svg">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/images/favicon.svg">
    <!--- Page Info-->
    
    <title>
        
            Redis入门 -
        
        狂奔的蜗牛
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
        <style>
    :root {
        --preloader-background-color: #fff;
        --preloader-text-color: #000;
    }

    @media (prefers-color-scheme: dark) {
        :root {
            --preloader-background-color: #202124;
            --preloader-text-color: #fff;
        }
    }

    @media (prefers-color-scheme: light) {
        :root {
            --preloader-background-color: #fff;
            --preloader-text-color: #000;
        }
    }

    @media (max-width: 600px) {
        .ml13 {
            font-size: 2.6rem !important; /* Adjust this value as needed */
        }
    }

    .preloader {
        display: flex;
        flex-direction: column;
        gap: 1rem; /* Tailwind 'gap-4' is 1rem */
        align-items: center;
        justify-content: center;
        position: fixed;
        padding: 12px;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        width: 100vw;
        height: 100vh; /* 'h-screen' is 100% of the viewport height */
        background-color: var(--preloader-background-color);
        z-index: 1100; /* 'z-[1100]' sets the z-index */
        transition: opacity 0.2s ease-in-out;
    }

    .ml13 {
        font-size: 3.2rem;
        /* text-transform: uppercase; */
        color: var(--preloader-text-color);
        letter-spacing: -1px;
        font-weight: 500;
        font-family: 'Chillax-Variable', sans-serif;
        text-align: center;
    }

    .ml13 .word {
        display: inline-flex;
        flex-wrap: wrap;
        white-space: nowrap;
    }

    .ml13 .letter {
        display: inline-block;
        line-height: 1em;
    }
</style>

<div class="preloader">
    
<script src="/js/libs/anime.min.js"></script>

    <h1 class="ml13">
        狂奔的蜗牛
    </h1>
    <script>
        var textWrapper = document.querySelector('.ml13');
        // Split text into words
        var words = textWrapper.textContent.trim().split(' ');

        // Clear the existing content
        textWrapper.innerHTML = '';

        // Wrap each word and its letters in spans
        words.forEach(function(word) {
            var wordSpan = document.createElement('span');
            wordSpan.classList.add('word');
            wordSpan.innerHTML = word.replace(/\S/g, "<span class='letter'>$&</span>");
            textWrapper.appendChild(wordSpan);
            textWrapper.appendChild(document.createTextNode(' ')); // Add space between words
        });


        anime.timeline({loop: true})
            .add({
                targets: '.ml13 .letter',
                translateY: [100,0],
                translateZ: 0,
                opacity: [0,1],
                easing: "easeOutExpo",
                duration: 1400,
                delay: (el, i) => 300 + 30 * i
            }).add({
            targets: '.ml13 .letter',
            translateY: [0,-100],
            opacity: [1,0],
            easing: "easeInExpo",
            duration: 1200,
            delay: (el, i) => 100 + 30 * i
        });

        let themeStatus = JSON.parse(localStorage.getItem('REDEFINE-THEME-STATUS'))?.isDark;

        // If the theme status is not found in local storage, check the preferred color scheme
        if (themeStatus === undefined || themeStatus === null) {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                themeStatus = 'dark';
            } else {
                themeStatus = 'light';
            }
        }

        // Now you can use the themeStatus variable in your code
        if (themeStatus) {
            document.documentElement.style.setProperty('--preloader-background-color', '#202124');
            document.documentElement.style.setProperty('--preloader-text-color', '#fff');
        } else {
            document.documentElement.style.setProperty('--preloader-background-color', '#fff');
            document.documentElement.style.setProperty('--preloader-text-color', '#000');
        }

        window.addEventListener('load', function () {
            hidePreloaderAfterTimeout(1000); // Hide after 1000 milliseconds once the window has loaded
        });

        // Backup failsafe: Hide preloader after a maximum of 5000 milliseconds, regardless of the window load event
        hidePreloaderAfterTimeout(5000);

        function hidePreloaderAfterTimeout(delay) {
            setTimeout(function () {
                var preloader = document.querySelector('.preloader');
                preloader.style.opacity = '0';
                setTimeout(function () {
                    preloader.style.display = 'none';
                }, 200);
            }, delay);
        }
    </script>
</div>
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/assets/build/styles.css">

    

    
<link rel="stylesheet" href="/fonts/fonts.css">

    
<link rel="stylesheet" href="/fonts/Satoshi/satoshi.css">

    <!--- Font Part-->
    
    
    
    


    <script id="hexo-configurations">
    window.config = {"hostname":"faustpromaxpx.github.io","root":"/","language":"zh-CN","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"title_alignment":"left","headings_top_spacing":{"h1":"5rem","h2":"4rem","h3":"2.8rem","h4":"2.5rem","h5":"2.2rem","h6":"2rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":false,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":true,"open_graph":true,"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-kx673m_2560x1440.png","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"Just do it !!!","subtitle":{"text":[],"hitokoto":{"enable":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":true,"style":"default","links":{"github":"https://github.com/FaustProMaxPX","instagram":null,"zhihu":"https://www.zhihu.com/people/shou-zu-tai-ye/posts","twitter":null,"email":"faustprogpu@gmail.com"},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.6.1","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"}},"search":{"enable":true,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":{"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"Tags":{"path":"/tags","icon":"fa-regular fa-tags"},"Categories":{"path":"/categories","icon":"fa-regular fa-folder"}}},"article_date_format":"auto","categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2024/4/06 11:24:14"};
    window.lang_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<meta name="generator" content="Hexo 6.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
<!--        <span class="swup-progress-icon">-->
<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
<!--        </span>-->
    
</div>


<main class="page-container" id="swup">

    

    <div class="main-content-container">


        <div class="main-content-header">
            <header class="navbar-container px-6 md:px-12">

    <div class="navbar-content ">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="/images/logo.png">
                </a>
            
            <a class="logo-title" href="/">
                
                狂奔的蜗牛
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    首页
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-screen w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                首页
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/archives"
                        >
                            <span>Archives</span>
                            <i class="fa-regular fa-archive fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/tags"
                        >
                            <span>Tags</span>
                            <i class="fa-regular fa-tags fa-sm fa-fw"></i>
                        </a>
                    </li>
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/categories"
                        >
                            <span>Categories</span>
                            <i class="fa-regular fa-folder fa-sm fa-fw"></i>
                        </a>
                    </li>
                
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">30</div>
        <div class="label text-third-text-color text-sm">标签</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">4</div>
        <div class="label text-third-text-color text-sm">分类</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">24</div>
        <div class="label text-third-text-color text-sm">文章</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="main-content-body">

            

            <div class="main-content">

                
                    <div class="post-page-container flex relative justify-between box-border w-full h-full">
    <div class="article-content-container">

        <div class="article-title relative w-full">
            
                <div class="w-full flex items-center pt-6 justify-start">
                    <h1 class="article-title-regular text-second-text-color text-4xl md:text-6xl font-bold px-2 sm:px-6 md:px-8 py-3">Redis入门</h1>
                </div>
            
            </div>

        
            <div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
                <div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
                    <img src="/images/logo.png">
                </div>
                <div class="info flex flex-col justify-between">
                    <div class="author flex items-center">
                        <span class="name text-default-text-color text-lg font-semibold">Zephyr</span>
                        
                            <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv3</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2023-01-25 11:01:27</span>
        <span class="mobile">2023-01-25 11:01:27</span>
        <span class="hover-info">创建</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2023-03-11 14:50:03</span>
            <span class="mobile">2023-03-11 14:50:03</span>
            <span class="hover-info">更新</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/redis/">redis</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/python/">python</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/%E7%BC%93%E5%AD%98/">缓存</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>33.6k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>131 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        


        <div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
            <p>实用主义的redis学习日志，使用的资料为《Redis实战》</p>
<span id="more"></span>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Redis是一个速度非常快的非关系型数据库，可以存储键与5种不同类型的值，可以将存储在内存的键值持久化到硬盘，可以使用复制特性来扩展读性能，还可以使用客户端分片来扩展写性能。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>redis有五种数据结构：String, List, Set, Hash, ZSet(有序集合)</p>
<table>
<thead>
<tr>
<th>结构类型</th>
<th>结构存储的值</th>
<th>结构的读写能力</th>
</tr>
</thead>
<tbody><tr>
<td>string</td>
<td>字符串，整数或浮点数</td>
<td>对整个字符串或字符串的一部分执行操作，可以对数字类型执行增减操作</td>
</tr>
<tr>
<td>list</td>
<td>一个链表，每个结点都包含一个字符串</td>
<td>从链表的两端推入或弹出元素，根据偏移量对链表进行修剪；读取单个或多个元素，根据值查找或移除元素</td>
</tr>
<tr>
<td>set</td>
<td>包含字符串的无序收集器</td>
<td>添加，获取，移除单个元素；检查一个元素是否存在；计算并交叉</td>
</tr>
<tr>
<td>hash</td>
<td>包含键值对的无序列表</td>
<td>添加，获取单个键值对，获取所有键值对</td>
</tr>
<tr>
<td>zset</td>
<td>字符串成员与浮点数分值(score)之间的有序映射，元素的排列由分值决定</td>
<td>添加，获取，删除单个元素；根据分值范围获取元素。</td>
</tr>
</tbody></table>
<p>在Redis中存储的基本思路：键名称为 xx:id, 冒号前表明这组数据属于的实体类，冒号之后用于分割实体类对应的不同对象(如果需要的话)。值使用的数据结构则要根据实际情况判断，例如hash适用于存储对象中字段和对应的值；set适用于需要去重/并交叉运算的情况；zset可以用于需要排序的情况。<br>一些例子.<br><img lazyload="" src="/images/loading.svg" data-src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/redis/20220814203913.png"><br><img lazyload="" src="/images/loading.svg" data-src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/redis/20220814203946.png"><br><img lazyload="" src="/images/loading.svg" data-src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/redis/20220814204014.png"></p>
<h2 id="Redis在Web中的应用"><a href="#Redis在Web中的应用" class="headerlink" title="Redis在Web中的应用"></a>Redis在Web中的应用</h2><h3 id="管理用户登录会话"><a href="#管理用户登录会话" class="headerlink" title="管理用户登录会话"></a>管理用户登录会话</h3><p>每一个web服务都会使用cookie来记录访客的身份，并要求浏览器存储这些数据，在下一次登录时携带这些数据。</p>
<table>
<thead>
<tr>
<th>cookie类型</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>签名cookie</td>
<td>验证cookie需要的一切信息都存储在cookie里，cookie也可以包含额外的信息，并且对这些信息签名也很容易</td>
<td>正确处理签名很困难，容易造成安全漏洞</td>
</tr>
<tr>
<td>令牌cookie</td>
<td>添加信息非常容易。cookie体积非常小，可以有效提升访问速度</td>
<td>需要在服务器中存储更多数据，用关系型数据库存储会带来较大的开销。</td>
</tr>
</tbody></table>
<p>下面假设一个场景：假如我们希望记录用户最近浏览的内容，由于这类数据一般都有微量，不定期的特质，如果使用关系型数据库会导致大量细碎的IO，严重拖慢运行速率。但是使用redis的话就可以有效解决在效率上的问题，但是内存的大小也同样不是无限的，因此我们需要定期对数据进行修剪。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">update_token</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> token<span class="token punctuation">,</span> user<span class="token punctuation">,</span> item<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    timestamp <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>
    conn<span class="token punctuation">.</span>hset<span class="token punctuation">(</span><span class="token string">'login:'</span><span class="token punctuation">,</span> token<span class="token punctuation">,</span> user<span class="token punctuation">)</span> <span class="token comment"># 维护用户和令牌的映射关系</span>
    conn<span class="token punctuation">.</span>zadd<span class="token punctuation">(</span><span class="token string">'recent:'</span><span class="token punctuation">,</span> token<span class="token punctuation">,</span> timestamp<span class="token punctuation">)</span> <span class="token comment"># 记录token最后一次使用时间</span>
    <span class="token keyword">if</span> item<span class="token punctuation">:</span>
        conn<span class="token punctuation">.</span>zadd<span class="token punctuation">(</span><span class="token string">'viewed:'</span> <span class="token operator">+</span> token<span class="token punctuation">,</span> item<span class="token punctuation">,</span> timestamp<span class="token punctuation">)</span> <span class="token comment"># 添加最近浏览的商品</span>
        conn<span class="token punctuation">.</span>zremrangebyrank<span class="token punctuation">(</span><span class="token string">'viewed:'</span> <span class="token operator">+</span> token<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">26</span><span class="token punctuation">)</span> <span class="token comment"># 移除旧的记录，只保留最近的25个</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>只在服务端维持指定数量的token，每隔一段时间检查token数是否超标，如果超过阈值就将最老的token删除。<br>这里会存在一个竞争问题，如果要删除的token正在进行操作就会导致用户在操作中途被要求重新登陆。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">QUIT <span class="token operator">=</span> <span class="token boolean">False</span>
LIMIT <span class="token operator">=</span> <span class="token number">1000000</span>
<span class="token keyword">def</span> <span class="token function">clean_session</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">while</span> <span class="token keyword">not</span> QUIT<span class="token punctuation">:</span>
        size <span class="token operator">=</span> conn<span class="token punctuation">.</span>zcard<span class="token punctuation">(</span><span class="token string">'recent:'</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> size <span class="token operator">&lt;=</span> LIMIT<span class="token punctuation">:</span>
            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token keyword">continue</span>
        end_index <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>size <span class="token operator">-</span> LIMIT<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>
        tokens <span class="token operator">=</span> conn<span class="token punctuation">.</span>zrange<span class="token punctuation">(</span><span class="token string">'recent:'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> end_index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
        session_keys <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> token <span class="token keyword">in</span> tokens<span class="token punctuation">:</span>
            session_keys<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">'viewed:'</span> <span class="token operator">+</span> token<span class="token punctuation">)</span>
        conn<span class="token punctuation">.</span>delete<span class="token punctuation">(</span><span class="token operator">*</span>session_keys<span class="token punctuation">)</span>
        conn<span class="token punctuation">.</span>hdel<span class="token punctuation">(</span><span class="token string">'login:'</span><span class="token punctuation">,</span> <span class="token operator">*</span>tokens<span class="token punctuation">)</span>
        conn<span class="token punctuation">.</span>zrem<span class="token punctuation">(</span><span class="token string">'recent:'</span><span class="token punctuation">,</span> <span class="token operator">*</span>tokens<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="购物车功能"><a href="#购物车功能" class="headerlink" title="购物车功能"></a>购物车功能</h3><p>在过去，网站常常将购物车功能集成在cookie当中，这样做的缺点就是会导致cookie体积过大，拖慢请求速度；此外，网站对cookie的验证也会变得困难。<br>在上一节我们做到了将会话cookie以及用户最近浏览商品存储在redis中，接下来我们可以尝试将购物车也存储在redis中。<br>购物车的结构非常简单，使用散列存储商品id与数量的映射，利用cart与用户token形成命名空间。不过添加购物车之后在上面清理token的部分就需要添加对购物车的清理。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">add_to_cart</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> session<span class="token punctuation">,</span> item<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> count <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">:</span>
        conn<span class="token punctuation">.</span>hrem<span class="token punctuation">(</span><span class="token string">'cart:'</span> <span class="token operator">+</span> session<span class="token punctuation">,</span> item<span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        conn<span class="token punctuation">.</span>hset<span class="token punctuation">(</span><span class="token string">'cart:'</span> <span class="token operator">+</span> session<span class="token punctuation">,</span> item<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过这一系列的优化，我们就可以通过较低的代价获取到用户最近浏览的商品，用户加入购物车的商品，用户下单的商品这些数据源，方便后续分析。</p>
<h3 id="网页缓存"><a href="#网页缓存" class="headerlink" title="网页缓存"></a>网页缓存</h3><p>接下来就是最常用的缓存网页响应操作。对于大多数动态生成，但数据变化次数极少的网页，我们可以使用redis将请求的响应缓存下来，在下一次接收到请求之后直接调取缓存中的响应，减少响应时间也减轻了服务器的负担。<br>tip：中间件：能够在处理请求之前或之后添加层的框架</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">cache_request</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> request<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> can_cache<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> request<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> callback<span class="token punctuation">(</span>request<span class="token punctuation">)</span>
    page_key <span class="token operator">=</span> <span class="token string">'cache:'</span> <span class="token operator">+</span> hash_request<span class="token punctuation">(</span>request<span class="token punctuation">)</span>
    content <span class="token operator">=</span> conn<span class="token punctuation">.</span>get<span class="token punctuation">(</span>page_key<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> content<span class="token punctuation">:</span>
        content <span class="token operator">=</span> callback<span class="token punctuation">(</span>request<span class="token punctuation">)</span>
        conn<span class="token punctuation">.</span>setex<span class="token punctuation">(</span>page_key<span class="token punctuation">,</span> content<span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> content<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="数据行缓存"><a href="#数据行缓存" class="headerlink" title="数据行缓存"></a>数据行缓存</h3><p>考虑到有一部分页面只需要表中的一部分数据行，这些页面势必无法整个缓存下来，但如果每次请求页面都去查询的话又会给数据库带来极大的压力。因此这里我们就要考虑缓存部分需要的数据行来提升效率。<br>如果上面的描述过于抽象的话就想一想淘宝的特价促销页面吧。<br>这方面优化的具体做法是：编写一个守护进程函数，让他定期将数据行更新到缓存中。这里数据行在redis中的数据结构为字符串，键为类型+商品id，值为JSON格式的商品属性。调度的处理方法为使用两个有序集合，一个负责记录何时进行调度，成员为数据行id，值为更新该数据的时间戳。另一个负责记录延时，成员为数据行id，值为更新数据的间隔。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">schedule_row_cache</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> row_id<span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">:</span>
    conn<span class="token punctuation">.</span>zadd<span class="token punctuation">(</span><span class="token string">'delay:'</span><span class="token punctuation">,</span> row_id<span class="token punctuation">,</span> delay<span class="token punctuation">)</span> <span class="token comment"># 添加延迟</span>
    conn<span class="token punctuation">.</span>zadd<span class="token punctuation">(</span><span class="token string">'schedule:'</span><span class="token punctuation">,</span> row_id<span class="token punctuation">,</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 立即进行调度</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">cache_rows</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">while</span> <span class="token keyword">not</span> QUIT<span class="token punctuation">:</span>
        <span class="token comment"># 获取下一个调度的商品</span>
        <span class="token builtin">next</span> <span class="token operator">=</span> conn<span class="token punctuation">.</span>zrange<span class="token punctuation">(</span><span class="token string">'schedule:'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> withscores<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
        now <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment"># 如果没有商品或还没轮到则休眠后继续</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token builtin">next</span> <span class="token keyword">or</span> <span class="token builtin">next</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> row<span class="token punctuation">:</span>
            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">.05</span><span class="token punctuation">)</span>
            <span class="token keyword">continue</span>
        row_id <span class="token operator">=</span> <span class="token builtin">next</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        delay <span class="token operator">=</span> conn<span class="token punctuation">.</span>zscore<span class="token punctuation">(</span><span class="token string">'delay:'</span><span class="token punctuation">,</span> row_id<span class="token punctuation">)</span>
        <span class="token keyword">if</span> delay <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">:</span>
            conn<span class="token punctuation">.</span>zrem<span class="token punctuation">(</span><span class="token string">'delay:'</span><span class="token punctuation">,</span> row_id<span class="token punctuation">)</span>
            conn<span class="token punctuation">.</span>zrem<span class="token punctuation">(</span><span class="token string">'schedule:'</span><span class="token punctuation">,</span> row_id<span class="token punctuation">)</span>
            conn<span class="token punctuation">.</span>delete<span class="token punctuation">(</span><span class="token string">'inv:'</span> <span class="token operator">+</span> row_id<span class="token punctuation">)</span>
            <span class="token keyword">continue</span>
        row <span class="token operator">=</span> Inventory<span class="token punctuation">.</span>get<span class="token punctuation">(</span>row_id<span class="token punctuation">)</span>
        conn<span class="token punctuation">.</span>zadd<span class="token punctuation">(</span><span class="token string">'schedule:'</span><span class="token punctuation">,</span> row_id<span class="token punctuation">,</span> now <span class="token operator">+</span> delay<span class="token punctuation">)</span>
        conn<span class="token punctuation">.</span><span class="token builtin">set</span><span class="token punctuation">(</span><span class="token string">'inv:'</span> <span class="token operator">+</span> row_id<span class="token punctuation">,</span> json<span class="token punctuation">.</span>dump<span class="token punctuation">(</span>row<span class="token punctuation">.</span>to_dict<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>tip：redis不支持数据结构的嵌套，因为这会导致命令语法复杂性直线上升。如果希望达成类似的效果可以在命名空间尝试分割例如user:123存储用户信息，user:123:posts存储用户发表的文章。</p>
<h3 id="网页分析"><a href="#网页分析" class="headerlink" title="网页分析"></a>网页分析</h3><p>上面我们通过缓存web页面来减少页面载入时间，但假如我们在内存大小有限的情况下，缓存所有的页面就不太现实了。这时候就需要有选择性的去缓存，比如缓存访问量前10000的商品。<br>这就需要我们再添加一个有序列表来记录各个商品的访问量，每当商品被访问后，它对应的分数就-1，这样访问量最多的商品就会排在列表的第一位。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">update_token</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> token<span class="token punctuation">,</span> user<span class="token punctuation">,</span> item<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    timestamp <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>
    conn<span class="token punctuation">.</span>hset<span class="token punctuation">(</span><span class="token string">'login:'</span><span class="token punctuation">,</span> token<span class="token punctuation">,</span> user<span class="token punctuation">)</span> <span class="token comment"># 维护用户和令牌的映射关系</span>
    conn<span class="token punctuation">.</span>zadd<span class="token punctuation">(</span><span class="token string">'recent:'</span><span class="token punctuation">,</span> token<span class="token punctuation">,</span> timestamp<span class="token punctuation">)</span> <span class="token comment"># 记录token最后一次使用时间</span>
    <span class="token keyword">if</span> item<span class="token punctuation">:</span>
        conn<span class="token punctuation">.</span>zadd<span class="token punctuation">(</span><span class="token string">'viewed:'</span> <span class="token operator">+</span> token<span class="token punctuation">,</span> item<span class="token punctuation">,</span> timestamp<span class="token punctuation">)</span> <span class="token comment"># 添加最近浏览的商品</span>
        conn<span class="token punctuation">.</span>zremrangebyrank<span class="token punctuation">(</span><span class="token string">'viewed:'</span> <span class="token operator">+</span> token<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">26</span><span class="token punctuation">)</span> <span class="token comment"># 移除旧的记录，只保留最近的25个</span>
        conn<span class="token punctuation">.</span>zincrby<span class="token punctuation">(</span><span class="token string">'viewed:'</span><span class="token punctuation">,</span> item<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment"># 增加访问量 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>同时为了减少内存的使用，我们只记录指定数量的商品。这需要一个守护进程函数去定期进行修剪。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">rescale_viewed</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">while</span> <span class="token keyword">not</span> QUIT<span class="token punctuation">:</span>
        conn<span class="token punctuation">.</span>zremrangebyrank<span class="token punctuation">(</span><span class="token string">'viewed:'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">20001</span><span class="token punctuation">)</span> <span class="token comment"># 删除排名在2000后的商品</span>
        conn<span class="token punctuation">.</span>zinterstore<span class="token punctuation">(</span><span class="token string">'viewed:'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">'viewed:'</span><span class="token punctuation">:</span><span class="token number">.5</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>接下来就是修改can_cache，用新的逻辑来判断是否需要缓存</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">can_cache</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> request<span class="token punctuation">)</span><span class="token punctuation">:</span>
    item_id <span class="token operator">=</span> extract_item_id<span class="token punctuation">(</span>request<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> item_id <span class="token keyword">or</span> is_dynamic<span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">False</span>
    rank <span class="token operator">=</span> conn<span class="token punctuation">.</span>zrank<span class="token punctuation">(</span><span class="token string">'viewed:'</span><span class="token punctuation">,</span> item_id<span class="token punctuation">)</span>
    <span class="token keyword">return</span> rank <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span> <span class="token keyword">and</span> rank <span class="token operator">&lt;</span> <span class="token number">10000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="Redis命令"><a href="#Redis命令" class="headerlink" title="Redis命令"></a>Redis命令</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>redis字符串可以存储以下三种数据</p>
<ul>
<li>字节串</li>
<li>整数（长整型）</li>
<li>浮点数（double）</li>
</ul>
<p>当用户向redis中存储字符串时，如果它可以被解释成整数或是浮点数，redis会察觉到这一点并提供增减值的方法，如果对字节串进行增减操作则会收到一个错误反馈。如果对不存在与redis中的键执行增减方法，redis会先将键对应的值初始化为0，然后再执行指定的操作。</p>
<p>Redis中的自增和自减命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody><tr>
<td>INCR</td>
<td>INCR key-name 将键存储的值加1</td>
</tr>
<tr>
<td>DECR</td>
<td>DECR key-name 将键存储的值减1</td>
</tr>
<tr>
<td>INCRBY</td>
<td>INCRBY key-name amount 将键存储的值加amout</td>
</tr>
<tr>
<td>DECRBY</td>
<td>DECRBY key-name amount 将键存储的值减amout</td>
</tr>
<tr>
<td>INCRBYFLOAT</td>
<td>INCRBYFLOAT key-name amount 将键存储的值加浮点数amout</td>
</tr>
</tbody></table>
<p>Redis处理子串和二进制位的命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody><tr>
<td>APPEND</td>
<td>APPEND key-name value 将value追加到给定key当前存储的串的末尾</td>
</tr>
<tr>
<td>GETRANGE</td>
<td>GETRANGE key-name start end 获取由偏移量start到end范围内所有字符组成的子串</td>
</tr>
<tr>
<td>SETRANGE</td>
<td>SETRANGE key-name offset value 将从偏移量offset开始的字符串设置为给定值</td>
</tr>
<tr>
<td>GETBIT</td>
<td>GETBIT key-name offset 将字节串看作是二进制位，并返回串中偏移量为offset的二进制位的值</td>
</tr>
<tr>
<td>SETBIT</td>
<td>SETBIT key-name offset value 将字节串二进制位中偏移量为offset的位设为value</td>
</tr>
</tbody></table>
<p>其中处理子串的方法，对于超出原有长度的部分都会当作空串处理，例如setrange在处理超出原本字符串长度的偏移量时，其作用就相当于将新的值添加在字符串末尾。</p>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>列表是一个由多个字符串组成的有序序列结构，可以用于存储任务信息，最近浏览过的文章或常用联系人信息。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>用例和描述</th>
</tr>
</thead>
<tbody><tr>
<td>RPUSH</td>
<td>RPUSH key-name value [value …] 将若干个值推入列表的右侧</td>
</tr>
<tr>
<td>LPUSH</td>
<td>LPUSH key-name value [value …] 将若干个值推入列表的左侧</td>
</tr>
<tr>
<td>RPOP</td>
<td>RPOP key-name 移除并返回列表右侧的元素</td>
</tr>
<tr>
<td>LPOP</td>
<td>LPOP key-name 移除并返回列表左侧的元素</td>
</tr>
<tr>
<td>LINDEX</td>
<td>LINDEX key-name offset 返回本列表中偏移量为offset的元素</td>
</tr>
<tr>
<td>LRANGE</td>
<td>LRANGE key-name start end 返回列表中第start到第end个元素</td>
</tr>
<tr>
<td>LTRIM</td>
<td>LTRIM key-name start end 对列表进行修剪，只保留从start到end的元素</td>
</tr>
</tbody></table>
<p>其中LTRIM和LRANGE的组合使用可以做到功能上类似LPOP和RPOP，但能够一次返回多个元素。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> rpush list a b c d
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">4</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> ltrim list <span class="token number">1</span> <span class="token number">2</span>
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> lrange list <span class="token number">0</span> -1
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"b"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"c"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>以上的所有方法在列表中没有可以使用的元素时都会返回nil，但redis还提供了使用阻塞队列的列表方法，在列表中没有可用元素时不会立即返回而是阻塞一段时间等待可用元素。<br>阻塞式的列表弹出命令以及在列表间移动元素的命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>BLPOP</td>
<td>BLPOP key-name [key-name …] timeout  从遇到的首个非空队列中弹出最左边的元素，或者阻塞timeout秒并等待可以弹出的元素。</td>
</tr>
<tr>
<td>BRPOP</td>
<td>BRPOP key-name [key-name …] timeout  从遇到的首个非空队列中弹出最右边的元素，或者阻塞timeout秒并等待可以弹出的元素。</td>
</tr>
<tr>
<td>RPOPLPUSH</td>
<td>RPOPLPUSH source-key dest-key 从source-key最右边弹出一个元素，假如dest-key的最左端，并将这个元素返回给用户</td>
</tr>
<tr>
<td>BRPOPLPUSH</td>
<td>BRPOPLPUSH source-key dest-key timeout 和上面一个命令效果一样，区别在于如果source-key中没有元素，就阻塞timeout秒并等待可弹出的元素</td>
</tr>
</tbody></table>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>Redis的集合以无序的方式来存储多个各不相同的元素，可以快速执行添加元素操作，移除元素操作以及检查一个元素是否存在于集合里。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SADD</td>
<td>SADD key-name item [item …] 将一个或多个元素添加到集合里，并返回被添加进去的元素数量</td>
</tr>
<tr>
<td>SREM</td>
<td>SREM key-name item [item …] 从集合中移除一个或多个元素，并返回被移除的元素的数量</td>
</tr>
<tr>
<td>SISMEMBER</td>
<td>SISMEMBER key-name item 检查元素item是否存在于集合key-name里</td>
</tr>
<tr>
<td>SCARD</td>
<td>SCARD key-name 返回集合包含的元素数量</td>
</tr>
<tr>
<td>SMEMBERS</td>
<td>SMEMBERS key-name 返回集合包含的元素数量</td>
</tr>
<tr>
<td>SRANDMEMBER</td>
<td>SRANDMEMBER key-name [count] 从集合里随机返回一个或多个元素。当count为正数时，返回的随机元素不会重复。当count为负数时，返回的元素可能会重复。</td>
</tr>
<tr>
<td>SPOP</td>
<td>随机移除集合中的一个元素，并返回被移除的元素</td>
</tr>
<tr>
<td>SMOV</td>
<td>SMOV source-key dest-key item 如果集合source-key包含元素item，那从中移除item并添加到dest-key中。如果item被成功移除就返回1否则返回0。</td>
</tr>
</tbody></table>
<p>以上就是redis集合的基本操作，接下来介绍集合间的组合与关联，这也是集合最有用的方法。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SDIFF</td>
<td>SDIFF key-name [key-name …] 返回存在于第一个集合但不存在与其他集合中的元素</td>
</tr>
<tr>
<td>SDIFFSTORE</td>
<td>SDIFFSTORE dest-key key-name [key-name …] 将差集运算的结果存储到dest-key里</td>
</tr>
<tr>
<td>SINTER</td>
<td>SINTER key-name [key-name …] 返回交集运算的结果</td>
</tr>
<tr>
<td>SINTERSTORE</td>
<td>SINTERSTORE dest-key key-name [key-name …] 将交集运算的结果存储到dest-key中</td>
</tr>
<tr>
<td>SUNION</td>
<td>SUNION key-name [key-name …] 返回并集运算的结果</td>
</tr>
<tr>
<td>SUNIONSTORE</td>
<td>SUNIONSTORE dest-key key-name [key-name …] 将并集运算的结果存储到dest-key中</td>
</tr>
</tbody></table>
<h3 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h3><p>Redis的散列可以将多个键值对存储在一个Redis键里面。因此散列非常适合将一些相关的数据存储在一起。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>HMGET</td>
<td>HMGET key-name key [key …] 从散列里面获取一个或多个键的值</td>
</tr>
<tr>
<td>HMSET</td>
<td>HMSET key-name key value [key value …] 为散列里面的一个或多个键设置值</td>
</tr>
<tr>
<td>HDEL</td>
<td>HDEL key-name key [key …] 删除散列里面的一个或多个键值对，返回成功找到并删除的键值对数量</td>
</tr>
<tr>
<td>HLEN</td>
<td>HLEN key-name 返回散列包含的键值对数量</td>
</tr>
</tbody></table>
<p>像是这一类批量处理的命令，既可以给用户带来便利，同时也可以通过减少命令的调用次数以及客户端与redis之间通信往返的次数来提升redis性能。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>HEXISTS</td>
<td>HEXISTS key-name key 检查给定键是否存在于散列中</td>
</tr>
<tr>
<td>HKEYS</td>
<td>HKEYS key-name 获取散列包含的所有键</td>
</tr>
<tr>
<td>HVALS</td>
<td>HVALS key-name 获取散列包含的所有值</td>
</tr>
<tr>
<td>HGETALL</td>
<td>HGETALL key-name 获取散列包含的所有键值对</td>
</tr>
<tr>
<td>HINCRBY</td>
<td>HINCRBY key-name key increment 将键key存储的值加上increment</td>
</tr>
<tr>
<td>HINCRBYFLOAT</td>
<td>HINCRBYFLOAT key-name key increment 将键key存储的值加上浮点数increment</td>
</tr>
</tbody></table>
<p>虽然HGETALL可以获取所有的键值对，但并不代表HKEYS和HVALS就没有用处。如果散列的值非常大，那么可以先使用HKEYS获取散列包含的所有键，然后再一个一个取出值，避免因一次获取多个大体积的值而导致服务器阻塞。</p>
<h3 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h3><p>有序集合存储成员与分值之间的键值对映射，并且提供分值处理，以及根据分值大小有序的获取或扫描成员和分值。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ZADD</td>
<td>ZADD key-name score member [score member …] 添加若干个成员，分数键值对到集合中去。</td>
</tr>
<tr>
<td>ZREM</td>
<td>ZREM key-name member [member …] 移除给定的成员，并返回移除的数量。</td>
</tr>
<tr>
<td>ZCARD</td>
<td>ZCARD key-name 返回有序集合包含的成员数量</td>
</tr>
<tr>
<td>ZINCRBY</td>
<td>ZINCRYBY key-name increment member 将指定成员的分数加上increment</td>
</tr>
<tr>
<td>ZCOUNT</td>
<td>ZCOUNT key-name min max 返回分数介于min和max之间的成员数量</td>
</tr>
<tr>
<td>ZRANK</td>
<td>ZRANK key-name member 返回指定成员的排名</td>
</tr>
<tr>
<td>ZSCORE</td>
<td>ZSCORE key-name member 返回指定成员的分数</td>
</tr>
<tr>
<td>ZRANGE</td>
<td>ZRANGE key-name start stop [WITHSCORES] 返回有序集合中排名介于start和stop之间的成员。如果给定了WITHSCORES，则会连分值一并返回</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ZREVRANK</td>
<td>ZREVRANK key-name member 返回有序集合里成员member的排名。这里按分值从大到小排</td>
</tr>
<tr>
<td>ZREVRANGE</td>
<td>ZREVRANGE key-name start stop [WITHSCORES]  返回有序集合给定排名范围内的成员，同样是从大到小排</td>
</tr>
<tr>
<td>ZRANGEBYSCORE</td>
<td>ZRANGEBYSCORE min max [WITHSCORES] [LIMIT offset count] 返回有序集合中，分值介于min和max的成员</td>
</tr>
<tr>
<td>ZREVRANGEBYSCORE</td>
<td>功能同上，但顺序相反</td>
</tr>
<tr>
<td>ZREMRANGEBYRANK</td>
<td>ZREMRANGEBYRANK key-name start stop 移除有序集合中排名介于start和stop之间的成员</td>
</tr>
<tr>
<td>ZREMRANGEBYSCORE</td>
<td>ZREMRANGEBYSCORE key-name min max 移除有序集合中分值介于min和max之间的所有成员</td>
</tr>
<tr>
<td>ZINTERSTORE</td>
<td>ZINTERSTORE dest-key key-count key [key …] [WEIGHTS weight …] [AGGREGATE SUM|MIN|MAX] 对给定有序集合执行交集运算</td>
</tr>
<tr>
<td>ZUNION</td>
<td>ZUNION dest-key key-count key [key …] [WEIGHTS weight …] [AGGREGATE SUM|MIN|MAX] 对给定有序集合执行并集运算</td>
</tr>
</tbody></table>
<p>这里稍微解释一下redis中的集合运算，当若干个有序集合进行集合运算后，其成员部分的结果和我们熟知的数学意义上的集合运算结果一致。而分数部分则由用户传入的WEIGHT和AGGREGATE决定，WEIGHT可以决定各个集合中分数的权重，默认为1。AGGREGATE则决定集合之间找到匹配项后对分数的处理行为，是直接相加还是取最大或最小值。</p>
<h3 id="发布与订阅"><a href="#发布与订阅" class="headerlink" title="发布与订阅"></a>发布与订阅</h3><p>订阅者可以订阅指定的频道，发布者可以向指定的频道传输信息，这些信息一旦被传输到给定频道，所有订阅该频道的订阅者都会收到信息。<br>Redis也提供了一系列用于发布与订阅的命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SUBSCRIBE</td>
<td>SUBSCRIBE channel [channel …]  订阅给定的一个或多个频道</td>
</tr>
<tr>
<td>UNSUBSCRIBE</td>
<td>UNSUBSCRIBE channel [channel …] 退订给定的一个或多个频道，如果没有指定，就退订所有频道</td>
</tr>
<tr>
<td>PUBLISH</td>
<td>PUBLISH channel msg 向给定频道发送信息</td>
</tr>
<tr>
<td>PSUBSCRIBE</td>
<td>PSUBSCRIBE pattern [pattern …] 订阅与给定模式相匹配的所有频道</td>
</tr>
<tr>
<td>PUNSUBSCRIBE</td>
<td>PUNSUBSCRIBE pattern [pattern …] 退订与给定模式相匹配的所有频道</td>
</tr>
<tr>
<td>虽然redis的订阅发布模式很有用，但其也有一定的局限性：</td>
<td></td>
</tr>
</tbody></table>
<ol>
<li>如果一个客户端订阅了某个频道，但其自身的读取速度不够快，这时就会导致大量的消息积压在redis的输出缓冲区，这可能会降低redis的效率，甚至对OS造成伤害。不过在新版的redis中，它会自动断开不符合输出缓冲区大小限制的订阅客户端。</li>
<li>任何网络系统在执行操作时都可能会碰上断线，如果客户端在执行订阅发布的过程中断线，那就会丢失掉断线期间的所有数据。</li>
</ol>
<h3 id="排序命令"><a href="#排序命令" class="headerlink" title="排序命令"></a>排序命令</h3><p>redis中的sort命令可以同时处理字符串，集合，列表和散列。sort命令可以根据字符串，列表，集合，有序集合，散列这5种键里面存储的数据，对列表，集合，以及有序集合进行排序。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SORT</td>
<td>SORT source-key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern …]] [ASC|DESC] [ALPHA] [STORE dest-key]——根据给定的选项，对输入列表、集合或者有序集合进行排序，然后返回或者存储排序的结果</td>
</tr>
<tr>
<td>这里就大致讲一下BY和GET参数的意义</td>
<td></td>
</tr>
<tr>
<td>有时我们希望能够自定义排序规则，例如列表中的数字都有不同的权重，而这些权重值存储在weight_*当中，其中的*代表列表中的数字元素，sort命令会根据列表中的元素去散列weight_之中寻找匹配的权重，并进行排序。</td>
<td></td>
</tr>
<tr>
<td>每次排序完成后都会返回顺序列表，但有时我们希望获取的是外部数据，例如对应的权重，这时就可以使用到GET，匹配方式和BY相同。</td>
<td></td>
</tr>
</tbody></table>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> rpush sort-input <span class="token number">23</span> <span class="token number">15</span> <span class="token number">110</span> <span class="token number">7</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">4</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> hset d-7 field <span class="token number">5</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> hset d-23 field <span class="token number">30</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> hset d-110 field <span class="token number">1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> hset d-15 field <span class="token number">5</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token comment"># 根据d-*中field的值对sort-input进行排序</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token function">sort</span> sort-input by d-*-<span class="token operator">&gt;</span>field
<span class="token comment"># 排序后返回权重值</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token function">sort</span> sort-input by d-*-<span class="token operator">&gt;</span>field get d-*-<span class="token operator">&gt;</span>field<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="基本事务"><a href="#基本事务" class="headerlink" title="基本事务"></a>基本事务</h3><p>redis的基本事务要使用到MULTI和EXEC命令，MULTI命令代表事务的开始，EXEC代表事务的结束。一旦事务开启，Redis就只会处理该客户端的命令，被上述两条命令包裹的命令会一个接一个执行直到所有命令都完成。<br>在Redis接到MULTI命令之后，就会将该客户端后续发送的所有命令都放入一个队列里面，并在不被打断的情况下完成里面的所有命令。这种做法不仅可以有效解决并行状态下的问题，还可以减少与redis的通信往返次数，以此提升效率。<br>这里要特别注意的是，和数据库事务不同，在redis中事务的所有操作都不会被立刻执行，而是缓存在一个队列里，只有在执行过程中，他才是无法打断的。这种事务更接近于一种消息队列。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> multi
OK
<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">(</span>TX<span class="token punctuation">)</span><span class="token operator">&gt;</span> hset <span class="token builtin class-name">test</span> o gg
QUEUED
<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">(</span>TX<span class="token punctuation">)</span><span class="token operator">&gt;</span> hset <span class="token builtin class-name">test</span> niubi <span class="token number">1</span>
QUEUED
<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">(</span>TX<span class="token punctuation">)</span><span class="token operator">&gt;</span> hget <span class="token builtin class-name">test</span> niubi
QUEUED
<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">(</span>TX<span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token builtin class-name">exec</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"1"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在第二章中提到，用户操作与token删除之间有一个竞争关系，我们可以让二者以事务的方式执行，这样就可以有效避免竞争。</p>
<h3 id="键的过期时间"><a href="#键的过期时间" class="headerlink" title="键的过期时间"></a>键的过期时间</h3><p>对于那些在某个时间点之后就不再有用的数据，我们可以通过设置过期时间来让一个键在给定时间之后自动删除。<br>不过这种做法也有限制，对于那些无法原子地为键设置过期时间的情况，这种方法就有点鸡肋了。因此，设置过期时间往往只适用于字符串类型，或是在指定时间后可以直接完全删除，而非删除数据结构中指定部分的情况。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PERSIST</td>
<td>PERSIST key-name 移除键的过期时间</td>
</tr>
<tr>
<td>TTL</td>
<td>TTL key-name 查看给定键距离过期还有多少时间</td>
</tr>
<tr>
<td>EXPIRE</td>
<td>EXPIRE key-name seconds 让给定键在指定的秒数过后过期</td>
</tr>
<tr>
<td>EXPIREAT</td>
<td>EXPIREAT key-name timestamp 将给定键的过期时间设置为给定的UNIX时间戳</td>
</tr>
<tr>
<td>PTTL</td>
<td>PTTL key-name 查看给定键距离过期还有多少毫秒</td>
</tr>
<tr>
<td>PEXPIRE</td>
<td>PEXPIRE key-name milliseconds 让给定键在指定的毫秒之后过期</td>
</tr>
<tr>
<td>PEXPIREAT</td>
<td>PEXPIREAT key-name timestamp-milliseconds 让一个毫秒级精度的UNIX时间戳设置为给定键的过期时间</td>
</tr>
</tbody></table>
<h2 id="Redis线程模型"><a href="#Redis线程模型" class="headerlink" title="Redis线程模型"></a>Redis线程模型</h2><p>我们常说Redis是单线程的，这里指的是Redis在处理命令时只使用主线程，但这并不代表Redis只有一个线程，他在启动的时候会启动后台线程，这些后台线程分别负责：</p>
<ol>
<li><p>AOF刷盘</p>
</li>
<li><p>关闭文件</p>
</li>
<li><p>释放内存</p>
</li>
</ol>
<p>之所以将这些任务交给后台线程，是因为这些都是十分耗时的任务，放在主线程中会大幅降低效率。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.drawio.png"></p>
<p> 上图是Redis线程模型的具体执行流程：</p>
<p>Redis首先会检查写发送队列里是否有待发送的数据，如果有就调用write函数发送数据，如果没有发送完，就注册写事件来处理函数。</p>
<p>接着就会调用epoll_wait等待事件到来：</p>
<ol>
<li><p>如果连接事件到来，调用accept获取已连接socket，然后把它注册到epoll中，最后注册读事件</p>
</li>
<li><p>如果是读事件，使用read接收数据，接着解析指令，执行指令。然后把<em>客户端发送对象</em>添加到发送队列，把执行结果写入缓冲区等待发送</p>
</li>
<li><p>如果是写事件，调用write发送数据，如果没有发完，就注册写事件，等待有数据可发后再发。</p>
</li>
</ol>
<h2 id="数据安全与性能保障"><a href="#数据安全与性能保障" class="headerlink" title="数据安全与性能保障"></a>数据安全与性能保障</h2><h3 id="持久化选项"><a href="#持久化选项" class="headerlink" title="持久化选项"></a>持久化选项</h3><p>快照：将存在与某一时刻的所有数据都写入硬盘<br>只追加文件(AOF)：在执行写命令时，将该命令复制到磁盘里。<br>一般来说，将数据持久化到磁盘的目的主要是为了之后重用数据，或为了防止系统故障而将数据备份到一个远程位置。此外，redis中也可能存储着复杂任务的执行结果，若能存储起来就可以避免后续的计算。</p>
<pre class="line-numbers language-ad-info" data-language="ad-info"><code class="language-ad-info">快照持久化选项
save 60 1000   60秒内若有1000次更改就执行存储以此快照
stop-writes-on-bgsave-error no
rdbcompression yes
dbfilename dump.rdb  快照文件

AOF 持久化选项
appendonly no
appendfsync everysec
no-appendfsync-on-rewrite no
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

dir ./   决定快照文件和AOF文件的保存路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h3><h4 id="创建快照"><a href="#创建快照" class="headerlink" title="创建快照"></a>创建快照</h4><ol>
<li>客户端可以向服务器发送一个<code>bgsave</code>命令来创建快照。服务器接收到之后会fork一个子进程将快照内容写入磁盘，父进程继续处理请求。</li>
<li>客户端还可以发送<code>save</code>命令来创建快照。接到save命令的服务器会停止处理一切客户端请求，开始创建快照。一般只用在内存不足的情况。</li>
<li>当满足了上面设置的save要求后，也会自动触发<code>bgsave</code>创建快照。</li>
<li>当redis接收到<code>shutdown</code>命令或接收到标准<code>trem</code>信号时，会执行<code>save</code>命令，并在完成后关闭服务器。</li>
<li>当一个Redis服务器连接另一个Redis服务器，并向对方发送<code>SYNC</code>命令来开始一次复制操作的时候，如果主服务器目前没有在执行<code>BGSAVE</code>操作，或者主服务器并非刚刚执行完<code>BGSAVE</code>操作，那么主服务器就会执行<code>BGSAVE</code>命令。</li>
</ol>
<p>在使用快照之前，首先必须意识到，如果系统真的崩溃，用户将丢失最近一次生成快照之后更改的所有数据。因此快照只适合于即使丢失一部分数据也不会造成问题的应用。</p>
<h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><p>当Redis服务器执行RDB快照时，会fork出一个子进程执行相关操作，具体流程同AOF。不过需要注意的时，RDB期间服务器通过写时复制修改的内容不会在本次RDB中被写入RDB文件，只能等待下一次<code>bgsave</code>或<code>save</code>执行。</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><h5 id="个人开发"><a href="#个人开发" class="headerlink" title="个人开发"></a>个人开发</h5><p>在个人开发服务器上，我们主要考虑的是尽可能降低快照持久化带来的资源消耗。如果打算在服务器中使用快照持久化，并存储大量的数据，那尽量让开发服务器的硬件配置接近生产服务器的配置，方便快速判断快照生成频率是否恰当。</p>
<h5 id="对日志进行聚合运算"><a href="#对日志进行聚合运算" class="headerlink" title="对日志进行聚合运算"></a>对日志进行聚合运算</h5><p>在对日志文件进行聚合计算或者对页面浏览量进行分析时，唯一要考虑的是，如果redis因崩溃而没能创建快照，我们可以承受丢失多长时间内产生的数据，并在配置文件中用save做好处理。除此之外，还要解决如何恢复因故障而被终端的日志操作。<br>在数据恢复时，首先要做的是弄清楚丢失了哪些数据。因此在处理日志的同时要记录被处理日志的有关信息。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">process_logs</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> path<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 获取文件当前的处理进度</span>
    current_file<span class="token punctuation">,</span> offset <span class="token operator">=</span> conn<span class="token punctuation">.</span>mget<span class="token punctuation">(</span><span class="token string">'progress:file'</span><span class="token punctuation">,</span> <span class="token string">'progress:position'</span><span class="token punctuation">)</span>
    pipe <span class="token operator">=</span> conn<span class="token punctuation">.</span>pipeline<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">update_progress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        pipe<span class="token punctuation">.</span>mset<span class="token punctuation">(</span><span class="token punctuation">{</span>
            <span class="token string">'progress:file'</span><span class="token punctuation">:</span>fname<span class="token punctuation">,</span>
            <span class="token string">'progress:position'</span><span class="token punctuation">:</span>offset
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token comment"># 执行日志更新操作，并记录日志名以及偏移量(处理进度)</span>
        pipe<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> fname <span class="token keyword">in</span> <span class="token builtin">sorted</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 跳过已经完成处理的文件</span>
        <span class="token keyword">if</span> fname <span class="token operator">&lt;</span> current_file<span class="token punctuation">:</span>
            <span class="token keyword">continue</span>
        inp <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>path<span class="token punctuation">,</span> fname<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'rb'</span><span class="token punctuation">)</span>
        <span class="token comment"># 跳过目标日志已被处理的部分</span>
        <span class="token keyword">if</span> fname <span class="token operator">==</span> current_file<span class="token punctuation">:</span>
            inp<span class="token punctuation">.</span>seek<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>offset<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            offset <span class="token operator">=</span> <span class="token number">0</span>
        current_file <span class="token operator">=</span> <span class="token boolean">None</span>
        <span class="token keyword">for</span> lno<span class="token punctuation">,</span> line <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>inp<span class="token punctuation">)</span><span class="token punctuation">:</span>
            callback<span class="token punctuation">(</span>pipe<span class="token punctuation">,</span> line<span class="token punctuation">)</span> <span class="token comment"># 调用回调函数处理日志行</span>
            offset <span class="token operator">+=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>offset<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token builtin">len</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span> <span class="token comment"># 更新偏移量</span>
            <span class="token comment"># 每处理1000个日志行或处理完一个日志文件就更新以此日志处理进度</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token punctuation">(</span>lno <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">1000</span><span class="token punctuation">:</span>
                update_progress<span class="token punctuation">(</span><span class="token punctuation">)</span>
        update_progress<span class="token punctuation">(</span><span class="token punctuation">)</span>
        inp<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h5><p>可以通过调用使用<code>save</code>，而非<code>bgsave</code>减少redis在备份时的停顿时间。可以取消配置文件中自动的save，转而用手动的方式(发送save命令)来处理快照的生成</p>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>AOF持久命令会将被执行的写命令写到AOF文件的末尾，以此来记录数据的变化。因此只需要从头到尾执行一遍AOF文件包含的写命令就可以恢复AOF文件记录的数据集。</p>
<h4 id="文件同步"><a href="#文件同步" class="headerlink" title="文件同步"></a>文件同步</h4><p>向硬盘写入文件时，要经历以下阶段：<br>当调用写入方法时，内容会先被存储到缓冲区，然后操作系统会在将来的某个时候将缓冲区存储的内容写入硬盘。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>同步频率</th>
</tr>
</thead>
<tbody><tr>
<td>always</td>
<td>每个Redis写命令都要同步写入硬盘，这样做会严重降低Redis的速度</td>
</tr>
<tr>
<td>everysec</td>
<td>每秒执行一次同步，显式将多个写命令同步到磁盘</td>
</tr>
<tr>
<td>no</td>
<td>让操作系统来决定何时同步</td>
</tr>
</tbody></table>
<p>一般来说使用everysec选项就足够了，no选项虽然可以让redis的性能免受AOF影响，但却会导致崩溃后不定量的数据缺失。</p>
<pre class="line-numbers language-ad-danger" data-language="ad-danger"><code class="language-ad-danger">如果不想让自己的固态尽早报废，不要使用always选项。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="重写-x2F-压缩AOF文件"><a href="#重写-x2F-压缩AOF文件" class="headerlink" title="重写/压缩AOF文件"></a>重写/压缩AOF文件</h4><p>AOF虽然可以很大程度上减少数据丢失的量，并且能在极短时间内完成持久化操作。但其并非十全十美。<br>随着时间推移，AOF的文件体积会不断增长，占用大量的磁盘空间，同时redis每次重启都要执行AOF中的写明了来还原数据集，如果AOF非常大，还原会非常缓慢。<br>为解决AOF体积不断增大的问题，用户可以向redis发送<code>BGREWRITEAOF</code>命令，它会通过移除AOF文件中的冗余命令来重写AOF文件。要注意的是，该命令的执行逻辑与快照<code>BGSAVE</code>基本相同，因此有同样的缺陷。在使用时要谨慎选择时间段，因为如果AOF非常大的话，内存和时间消耗会很大。<br><code>auto-aof-rewrite-percentage</code>:当AOF体积达到最小体积阈值的指定百分比时开始重写<br><code>auto-aof-rewrite-min-size</code>：AOF在磁盘上可接受的最小文件大小</p>
<p><strong>AOF重写流程</strong></p>
<p>当AOF重写开始后，会fork出一个子<strong>进程</strong>来执行相关操作。使用进程而非线程的原因是，子线程与父进程共享内存，在执行修改时必须通过加锁来保证数据一致性。而使用进程，我们就可以通过COW避免加锁带来的开销。</p>
<blockquote>
<p><strong>COW在AOF中的应用</strong><br>主线程通过<code>fork</code>调用生成子进程时，操作系统会将主进程的页表复制一份给子进程，这个页表记录虚拟地址和物理地址映射关系，而不会复制物理内存。<br>这样一来，子进程就和父进程共享了物理内存数据，同时页表对应的页表项也会标记为只读。<br>当子进程或父进程想要修改共享内存中的数据时，就会触发写时复制，此时OS就会进行物理内存的复制，并重新设置内存映射关系。这个新的页表专属于发起修改的一方，它具有读写权限</p>
</blockquote>
<p><img lazyload="" src="/images/loading.svg" data-src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/20230124103337.png" alt="COW示意图"></p>
<p>既然使用了写时复制，那么父进程在AOF期间进行的修改操作对执行AOF的子进程就是不可见的了，这显然会导致数据不一致。因此，父进程会将新写入的数据写入AOF缓冲区（等待被写入AOF文件的缓冲区）和AOF重写缓存区（处理AOF重写的缓冲区）。当子进程完成AOF时会向父进程发送一个信号，此时父进程会将AOF重写缓冲区的所有内容追加到AOF文件中，并重命名。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/20230124103643.png"></p>
<h4 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h4><p>通过上面的讨论，我们可以看出AOF和RDB都各有优劣。而为了最大程度上利用二者的优势，Redis推出了混合持久化。</p>
<p>开启混合持久化后，进行AOF重写时，fork出来的重写子进程会先将与主线程共享的内存数据以RDB的形式写入AOF文件。在此期间主线程处理的写操作会写入到AOF重写缓冲区，最后它会以增量命令的形式被写入AOF文件。写入完成后通知主线程将新的含有RDB格式和AOF格式的文件替换掉旧的AOF文件。</p>
<p>这样做的好处在于，重启Redis加载数据时，由于数据量很大的部分使用RDB存储，它的加载速度会很快。而之后一些琐碎的修改使用AOF存储，可以很大程度上减少数据的丢失。</p>
<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>让其他服务器拥有一个不断更新的数据副本，使得拥有数据副本的服务器可以用于处理用户发送的请求。<br>在需要扩展读请求或是在需要写入临时数据的时候，用户可以通过设置额外的Redis从服务器来保存数据集的副本。客户端每次向主服务器进行写入时，从服务器都会实时地得到更新。</p>
<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>前文提到当主服务器被连接时，会存储一份快照，因此要确保主服务器的<code>dir</code>,<code>dbfilename</code>被正确配置，并且拥有相应的权限。<br>从服务器可以同过<code>slaveof host port</code>来连接主服务器，也可以通过<code>slaveof no one</code>让服务器停止复制操作。</p>
<h4 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h4><table>
<thead>
<tr>
<th>步骤</th>
<th>主服务器操作</th>
<th>从服务器操作</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>等待命令进入</td>
<td>连接主服务器，发送SYNC命令</td>
</tr>
<tr>
<td>2</td>
<td>开始执行BGSAVE，并使用缓冲区记录BGSAVE之后执行的所有写命令</td>
<td>根据配置选项来决定是继续使用现有的数据响应请求还是向发送请求的客户端返回错误</td>
</tr>
<tr>
<td>3</td>
<td>BGSAVE执行完毕，向从服务器发送快照文件，并在发送期间继续使用缓冲区记录被执行的写命令</td>
<td>丢弃所有旧数据，开始载入发来的快照文件</td>
</tr>
<tr>
<td>4</td>
<td>快照文件发送完毕，开始向从服务器发送存储在缓冲区里面的写命令</td>
<td>完成对快照文件的解释操作，像往常一样开始接收命令请求</td>
</tr>
<tr>
<td>5</td>
<td>缓冲区存储的写命令发送完毕；从此开始，每执行一个写命令，就向从服务器发送相同命令</td>
<td>执行主服务器发来的所有写命令</td>
</tr>
</tbody></table>
<p>从上面的步骤不难看出，Redis的主从交互需要网络畅通，同时最好在主服务器中预留下30%-45%的内存用于执行BGSAVE和创建记录写命令的缓冲区。<br>当有多台从服务器尝试连接主服务器时，就会出现下面两种情况之一：</p>
<ol>
<li>快照还没发送：所有从服务器收到相同的快照和写命令</li>
<li>快照正在发送或已经发送：当主服务器与较早进行连接的从服务器执行完复制所需的5个步骤之后，主服务器会与新连接的从服务器执行一次新的步骤1至步骤5</li>
</ol>
<p>考虑到主从服务器间的网络不可能永远畅通，我们必须准备一些应对网络问题的措施。当发生主从服务器断开连接后又重新连接的情况时，最简单的处理方式就是让它们再进行一次全量复制，这显然是非常耗时的。</p>
<p>因此，面对这种情况，Redis采用了增量复制，当从服务器重新连接主服务器后，它仍会向主服务器发送<code>psync</code>，不过这次offset值不再是-1（全量复制时为-1）。主服务器收到后会发送CONTINUE命令，告诉从服务器这是一次增量复制。</p>
<p><strong>主服务器处理增量复制的方式</strong></p>
<p>主服务器会维护一个环形缓冲区，里面记录了所有最近执行的命令，同时主服务器也会维护一个变量用于记录自己写到哪里了。</p>
<p>主服务器在收到从服务器的<code>psync</code>命令后，会比较收到的offset和自己维护的写入offset，如果从服务器缺失的数据还在环形缓冲区里，就会执行增量复制，否则会执行全量复制。</p>
<h4 id="主从链"><a href="#主从链" class="headerlink" title="主从链"></a>主从链</h4><p>创建太多个从服务器可能会造成网络不可用，尤其是在复制需要通过互联网或在不同数据中心之间进行时。为了缓解这一问题，我们让从服务器也可以拥有自己的从服务器，并由此形成主从链。<br>从从复制和主从复制的区别在于，如果从服务器X拥有从服务器Y，那么当从服务器执行复制步骤4时，会断开与服务器Y的连接，导致从服务器Y需要重新连接并重新同步。</p>
<p>当读请求的重要性明显高于写请求的重要性，并且读请求的数量远远超出一台Redis服务器可以处理的范围时，用户就需要添加新的从服务器来处理读请求。随着负载不断上升，主服务器可能会无法快速地更新所有从服务器，或者因为重新连接和重新同步从服务器而导致系统超载。为了缓解这个问题，用户可以创建一个由Redis主从节点（master/slave node）组成的中间层来分担主服务器的复制工作<br><img lazyload="" src="/images/loading.svg" data-src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/redis/NeatReader-1661071382123.png"></p>
<h4 id="检验硬盘写入"><a href="#检验硬盘写入" class="headerlink" title="检验硬盘写入"></a>检验硬盘写入</h4><p>验证主服务器发送的数据是否被从服务器写入磁盘需要以下两个步骤：</p>
<ol>
<li>判断数据是否已经到达了从服务器：向主服务器写入真正的数据后，再向主服务器写入一个唯一的虚构值，然后通过检查虚构值是否存在于从服务器来判断写数据是否到达从服务器。</li>
<li>判断从服务器是否已经把数据写入了磁盘：检查<code>INFO</code>命令的输出结果中<code>aof_pending_bio_fsync</code>的属性值是否为0。</li>
</ol>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">wait_for_sync</span><span class="token punctuation">(</span>mconn<span class="token punctuation">,</span> sconn<span class="token punctuation">)</span><span class="token punctuation">:</span>
    identifier <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">(</span>uuid<span class="token punctuation">.</span>uuid4<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 用于判断数据是否抵达的虚拟值</span>
    mconn<span class="token punctuation">.</span>zadd<span class="token punctuation">(</span><span class="token string">'sync:wait'</span><span class="token punctuation">,</span> identifier<span class="token punctuation">,</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment"># 等待服务器完成同步</span>
    <span class="token keyword">while</span> <span class="token keyword">not</span> sconn<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'master_link_status'</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'up'</span><span class="token punctuation">:</span>
        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">.001</span><span class="token punctuation">)</span>
    <span class="token comment"># 等待从服务器接收数据</span>
    <span class="token keyword">while</span> <span class="token keyword">not</span> sconn<span class="token punctuation">.</span>zscore<span class="token punctuation">(</span><span class="token string">'sync:wait'</span><span class="token punctuation">,</span> identifier<span class="token punctuation">)</span><span class="token punctuation">:</span>
        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">.001</span><span class="token punctuation">)</span>
    <span class="token comment"># 检查数据是否已经被写入磁盘，1s后超时</span>
    deadline <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1.01</span>
    <span class="token keyword">while</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> deadline<span class="token punctuation">:</span>
        <span class="token keyword">if</span> sconn<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'aof_pending_bio_fsync'</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
            <span class="token keyword">break</span>
        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">.001</span><span class="token punctuation">)</span>
    <span class="token comment"># 清理令牌，同时清理之前可能留下的旧令牌</span>
    mconn<span class="token punctuation">.</span>zrem<span class="token punctuation">(</span><span class="token string">'sync:wait'</span><span class="token punctuation">,</span> identifier<span class="token punctuation">)</span>
    mconn<span class="token punctuation">.</span>zremrangebyscore<span class="token punctuation">(</span><span class="token string">'sync:wait'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">900</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="减少数据丢失"><a href="#减少数据丢失" class="headerlink" title="减少数据丢失"></a>减少数据丢失</h4><p><strong>异步复制</strong></p>
<hr>
<p>Redis主从复制采用的是异步复制，如果主节点向从节点同步写请求时宕机，主节点内存中的数据就会完全丢失。</p>
<p>Redis配置中有一个参数<code>min-slaves-max-lag</code>。一旦所有的从节点复制/同步数据的耗时都超过了这个配置的值，主服务器就会停止服务，因为它判断，这种情况下继续服务，一旦宕机，会造成大量的数据丢失。</p>
<p>此时客户端可以选择服务降级，先使用本地缓存继续服务，等待主服务器恢复正常后，再重新发起请求。</p>
<p><strong>脑裂</strong></p>
<hr>
<p>如果主节点无法与从节点交互，也无法响应哨兵的心跳，就会被判断死亡，此时哨兵会选举出一个新的主节点继续服务。</p>
<p>但假如原主节点是由于网络分区的原因而无法进行响应与同步，当主节点连接回来之后，会被哨兵降级为从节点，此时会进行一次全量复制。这导致主节点在被隔离状态下处理的所有写请求都被清理掉，产生数据丢失。</p>
<p>为了处理这种情况，Redis使用两个配置参数：</p>
<ol>
<li>min-slaves-to-write x 主节点必须要能与x个节点连接，否则它禁止写入数据</li>
<li>min-slaves-max-lag x 主从数据复制和同步的延迟不能超过 x 秒</li>
</ol>
<p>通过上面两个配置，我们能保证主服务器在假死状态下也不会写入数据，当它重新连回集群后，也就不存在数据丢失。</p>
<h3 id="处理系统故障"><a href="#处理系统故障" class="headerlink" title="处理系统故障"></a>处理系统故障</h3><p>Redis提供了两个命令用于快照和AOF文件的检查与恢复<br>redis-check-aof [–fix] &lt;file.aof&gt;<br>Redis会扫描指定的aof文件，寻找不正确或不完整的命令。如果添加了fix选项，Redis就会删除从第一个不正确命令开始的所有命令。<br>redis-check-dump &lt;dump.rdb&gt;<br>Redis检查指定的快照文件是否出错，但无法进行修复。</p>
<h3 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h3><p>Redis使用哨兵来进行主从故障转移，同时监控主从节点的状态。哨兵节点主要负责三件事：监控，选主，通知</p>
<p><strong>监控</strong></p>
<p>哨兵每隔1秒就会向所有的主从节点发送ping，如果某个节点没有在规定时间内（由配置项<code>down-after-milliseconds</code>设置）响应，就会被判断<strong>主观下线</strong>。</p>
<p>有主观下线，那么自然也有客观下线，当一个哨兵判断某个节点主观下线后就会向其他哨兵发起命令，询问他们是否也认为这个节点主观下线。如果赞成的哨兵数达到配置项<code>quorum</code>指定的值，该节点就会被判断为客观下线。</p>
<p><strong>选主</strong></p>
<p>当哨兵集群判断主节点客观下线后，就会选派出一个leader节点进行主从故障转移。通常是由判断主节点客观下线的节点担任<strong>候选者</strong>。</p>
<p>一个候选者要想赢得选举需要以下两个条件：</p>
<ol>
<li>获取半数以上的赞成票</li>
<li>获取的票数大于配置项<code>quorum</code>值</li>
</ol>
<p>主从故障转移流程：</p>
<ol>
<li>在已下线主节点的所有网络状态良好的从节点中选出一个从节点担任新的主节点。选取标准为：优先级，复制进度，ID号</li>
<li>让其余的从节点复制新的主节点</li>
<li>将新主节点的IP地址等信息通过发布/订阅模式通知给客户端。</li>
<li>继续监视旧主节点，如果它连回集群，将其设为从节点。</li>
</ol>
<p><img lazyload="" src="/images/loading.svg" data-src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/20230125105755.png" alt="选取新主库流程"></p>
<p><strong>哨兵节点之间的发现方式</strong></p>
<p>哨兵之间会通过发布-订阅的方式相互发现，他们通过在订阅主节点上的<code>__sentinel__:hello</code>频道来实现相互发现，首次加入集群的哨兵会往频道中发送自己的IP和端口号，其他哨兵就可以借此获知新成员的信息。</p>
<p>接着，哨兵又可以向主节点发送INFO命令，来获取从节点的信息。</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>之前已经简单提过了命令的基本操作，但这一部分命令只能够帮助我们以流水线的方式提升程序效率，它并没有对数据一致性的保障。例如，假设一个客户开启了事务，并决定修改某个键，如果此时另一个客户端修改了这个键，事务最终仍会顺利执行，但最终结果却可能天差地别。<br>在分布式事务的情况下，常常会采用2PC(二阶段提交)，但如果连数据一致性都无法维持的话，2PC无法实现。例如，商店进了一批货，老板1更新好了库存，而老板2没更新好库存，这时候这批货就无法被记录，因为老板之间数据不一致，在投票时会发生明显分歧。<br>为了保证数据的一致性，Redis还提供了<code>WATCH</code>, <code>UNWATCH</code>, <code>DISCARD</code>命令。<br>WATCH会监视指定的键，在开启WATCH到使用EXEC提交这段时间，如果有其他用户对被监视的键做出了修改，在用户尝试执行EXEC的时候就会返回一个错误。<br>UNWATCH会取消Redis对所有监视键的监视<br>DISCARD会取消监视，同时放弃事务中的所有命令</p>
<p>接下来用一个商场案例来解释事务的用法<br>首先是用户将商品放到商场上销售，这时要监视的键是用户持有物，如果用户将商品挂上去后就用掉了商品，自然是不允许卖出的。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">list_item</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> itemid<span class="token punctuation">,</span> sellerid<span class="token punctuation">,</span> price<span class="token punctuation">)</span><span class="token punctuation">:</span>
    inventory <span class="token operator">=</span> <span class="token string">"inventory:%s"</span><span class="token operator">%</span>sellerid
    item <span class="token operator">=</span> <span class="token string">"%s.%s"</span><span class="token operator">%</span><span class="token punctuation">(</span>itemid<span class="token punctuation">,</span> sellerid<span class="token punctuation">)</span>
    end <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">5</span>
    pipe <span class="token operator">=</span> conn<span class="token punctuation">.</span>pipeline<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">while</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> end<span class="token punctuation">:</span>
        <span class="token keyword">try</span><span class="token punctuation">:</span>
            pipe<span class="token punctuation">.</span>watch<span class="token punctuation">(</span>inventory<span class="token punctuation">)</span>
            <span class="token comment"># 如果指定的商品已经不再用户包裹里，就放弃监视</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> pipe<span class="token punctuation">.</span>sismember<span class="token punctuation">(</span>inventory<span class="token punctuation">,</span> itemid<span class="token punctuation">)</span><span class="token punctuation">:</span>
                pipe<span class="token punctuation">.</span>unwatch<span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token boolean">None</span>
            pipe<span class="token punctuation">.</span>multi<span class="token punctuation">(</span><span class="token punctuation">)</span>
            pipe<span class="token punctuation">.</span>zadd<span class="token punctuation">(</span><span class="token string">"market:"</span><span class="token punctuation">,</span> item<span class="token punctuation">,</span> price<span class="token punctuation">)</span>
            pipe<span class="token punctuation">.</span>srem<span class="token punctuation">(</span>inventory<span class="token punctuation">,</span> itemid<span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">True</span>
            <span class="token comment"># 如果出现变动就开始重试</span>
        <span class="token keyword">except</span> redis<span class="token punctuation">.</span>exceptions<span class="token punctuation">.</span>WatchError<span class="token punctuation">:</span>
            <span class="token keyword">pass</span>
    <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>而对于购买商品来说，就需要监视商场的货物变化情况以及买家的钱包状况</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">purchase_item</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> buyerid<span class="token punctuation">,</span> itemid<span class="token punctuation">,</span> sellerid<span class="token punctuation">,</span> lprice<span class="token punctuation">)</span><span class="token punctuation">:</span>
    buyer <span class="token operator">=</span> <span class="token string">"users:%s"</span><span class="token operator">%</span>buyerid
    seller <span class="token operator">=</span> <span class="token string">"users:%s"</span><span class="token operator">%</span>sellerid
    item <span class="token operator">=</span> <span class="token string">"%s.%s"</span><span class="token operator">%</span><span class="token punctuation">(</span>itemid<span class="token punctuation">,</span> sellerid<span class="token punctuation">)</span>
    inventory <span class="token operator">=</span> <span class="token string">"inventory:%s"</span><span class="token operator">%</span>buyerid
    end <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">10</span>
    pipe <span class="token operator">=</span> conn<span class="token punctuation">.</span>pipeline<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">while</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> end<span class="token punctuation">:</span>
        <span class="token keyword">try</span><span class="token punctuation">:</span>
            pipe<span class="token punctuation">.</span>watch<span class="token punctuation">(</span><span class="token string">"market:"</span><span class="token punctuation">,</span> buyer<span class="token punctuation">)</span>
            price <span class="token operator">=</span> pipe<span class="token punctuation">.</span>zscore<span class="token punctuation">(</span><span class="token string">"market:"</span><span class="token punctuation">,</span> item<span class="token punctuation">)</span>
            funds <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>pipe<span class="token punctuation">.</span>hget<span class="token punctuation">(</span>buyer<span class="token punctuation">,</span> <span class="token string">"funds"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> price <span class="token operator">!=</span> lprice <span class="token keyword">or</span> price <span class="token operator">&gt;</span> funds<span class="token punctuation">:</span>
                pipe<span class="token punctuation">.</span>unwatch<span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token boolean">None</span>
            pipe<span class="token punctuation">.</span>multi<span class="token punctuation">(</span><span class="token punctuation">)</span>
            pipe<span class="token punctuation">.</span>hincrby<span class="token punctuation">(</span>seller<span class="token punctuation">,</span> <span class="token string">"funds"</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">(</span>price<span class="token punctuation">)</span><span class="token punctuation">)</span>
            pipe<span class="token punctuation">.</span>hincrby<span class="token punctuation">(</span>buyer<span class="token punctuation">,</span> <span class="token string">"funds"</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token operator">-</span>price<span class="token punctuation">)</span><span class="token punctuation">)</span>
            pipe<span class="token punctuation">.</span>sadd<span class="token punctuation">(</span>inventory<span class="token punctuation">,</span> itemid<span class="token punctuation">)</span>
            pipe<span class="token punctuation">.</span>zrem<span class="token punctuation">(</span><span class="token string">"market:"</span><span class="token punctuation">,</span> item<span class="token punctuation">)</span>
            pipe<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">True</span>
        <span class="token keyword">except</span> redis<span class="token punctuation">.</span>exception<span class="token punctuation">.</span>WatchError<span class="token punctuation">:</span>
            <span class="token keyword">pass</span>
    <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Redis不像关系型数据库一样，在要访问的数据上加锁，因为持有锁的客户端处理越慢，等待的时间就越长。Redis只会在监视的数据被更改时，通知客户端，避免了等待，当客户端接到失败通知时，只需要尝试重新执行即可。</p>
<h2 id="构建支持程序"><a href="#构建支持程序" class="headerlink" title="构建支持程序"></a>构建支持程序</h2><h3 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h3><p>常用的日志记录方式有两种，第一种是将日志记录到文件里面。然后随着程序的运行不断将新的日志行记录到日志文件中。并在一段时间之后创建新的日志文件。这种日志记录方式很难聚合所有的日志并进行处理。<br>另一种方式就是本章使用的syslog。该服务运行在Linux服务器的514号TCP端口和UDP端口上，syslog接收其他程序发来的日志并将这些信息路由到存储在硬盘上的各个日志文件中</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 将所有的日志级别映射为字符串</span>
SEVERITY <span class="token operator">=</span> <span class="token punctuation">{</span>
    logging<span class="token punctuation">.</span>DEBUG<span class="token punctuation">:</span> <span class="token string">'debug'</span><span class="token punctuation">,</span>
    logging<span class="token punctuation">.</span>INFO<span class="token punctuation">:</span> <span class="token string">'info'</span><span class="token punctuation">,</span>
    logging<span class="token punctuation">.</span>WARNING<span class="token punctuation">:</span> <span class="token string">'warning'</span><span class="token punctuation">,</span>
    logging<span class="token punctuation">.</span>ERROR<span class="token punctuation">:</span> <span class="token string">'error'</span><span class="token punctuation">,</span>
    logging<span class="token punctuation">.</span>CRITICAL<span class="token punctuation">:</span> <span class="token string">'critical'</span>
<span class="token punctuation">}</span>
SEVERITY<span class="token punctuation">.</span>update<span class="token punctuation">(</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> name<span class="token punctuation">)</span> <span class="token keyword">for</span> name <span class="token keyword">in</span> SEVERITY<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">log_recent</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> name<span class="token punctuation">,</span> message<span class="token punctuation">,</span> severity<span class="token operator">=</span>logging<span class="token punctuation">.</span>INFO<span class="token punctuation">,</span> pipe<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    severity <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">(</span>SEVERITY<span class="token punctuation">.</span>get<span class="token punctuation">(</span>severity<span class="token punctuation">,</span> severity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span>
    destination <span class="token operator">=</span> <span class="token string">'recent:%s:%s'</span><span class="token operator">%</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> severity<span class="token punctuation">)</span>
    message <span class="token operator">=</span> time<span class="token punctuation">.</span>asctime<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> message
    pipe <span class="token operator">=</span> pipe <span class="token keyword">or</span> conn<span class="token punctuation">.</span>pipeline<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 使用流水线降低通信次数</span>
    pipe<span class="token punctuation">.</span>lpush<span class="token punctuation">(</span>destination<span class="token punctuation">,</span> message<span class="token punctuation">)</span> <span class="token comment"># 将日志加入列表</span>
    pipe<span class="token punctuation">.</span>ltrim<span class="token punctuation">(</span>destination<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">)</span> <span class="token comment"># 让日志只包含最新的100条</span>
    pipe<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面的实例可以很方便的记录最新的日志，但是对于日志的重要程度以及出现频率无法进行统计，因此我们再添加一个用于记录常见日志的方法。<br>程序会将消息作为成员存储到有序集合里面，并将消息出现的频率设置为成员的分值。为了确保我们看见的常见消息都是最新的，程序会以每小时一次的频率对消息进行轮换，并在轮换日志的时候保留上一个小时记录的常见消息，从而防止没有任何消息存在的情况出现。<br>程序还需要谨慎处理上一个小时收集到的日志，因为涉及改名操作，因此需要将其放在一个事务里面。此外，程序会将流水线传递给log_recent()来减少记录常见日志和记录最新日志时的通信次数。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">log_common</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> name<span class="token punctuation">,</span> message<span class="token punctuation">,</span> severity<span class="token operator">=</span>logging<span class="token punctuation">.</span>INFO<span class="token punctuation">,</span> timeout<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    severity <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">(</span>SEVERITY<span class="token punctuation">.</span>get<span class="token punctuation">(</span>severity<span class="token punctuation">,</span> severity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span>
    destination <span class="token operator">=</span> <span class="token string">'common:%s:%s'</span><span class="token operator">%</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> severity<span class="token punctuation">)</span>
    start_key <span class="token operator">=</span> destination <span class="token operator">+</span> <span class="token string">':start'</span> <span class="token comment"># 程序每小时轮换一次日志，使用一个键来存储当前所处的时间</span>
    pipe <span class="token operator">=</span> conn<span class="token punctuation">.</span>pipeline<span class="token punctuation">(</span><span class="token punctuation">)</span>
    end <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> timeout
    <span class="token keyword">while</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> end<span class="token punctuation">:</span>
        <span class="token keyword">try</span><span class="token punctuation">:</span>
            <span class="token comment"># 对记录当前小时数的键进行监视，确保轮换操作正确执行</span>
            pipe<span class="token punctuation">.</span>watch<span class="token punctuation">(</span>start_key<span class="token punctuation">)</span>
            now <span class="token operator">=</span> datetime<span class="token punctuation">.</span>utcnow<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token comment"># 获取当前小时数</span>
            hour_start <span class="token operator">=</span> datetime<span class="token punctuation">(</span><span class="token operator">*</span>now<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>isoformat<span class="token punctuation">(</span><span class="token punctuation">)</span>
            existing <span class="token operator">=</span> pipe<span class="token punctuation">.</span>get<span class="token punctuation">(</span>start_key<span class="token punctuation">)</span>
            <span class="token comment"># 开启事务</span>
            pipe<span class="token punctuation">.</span>multi<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token comment"># 如果记录的是上一个小时的日志，就将他归档</span>
            <span class="token keyword">if</span> existing <span class="token keyword">and</span> existing <span class="token operator">&lt;</span> hour_start<span class="token punctuation">:</span>
                pipe<span class="token punctuation">.</span>rename<span class="token punctuation">(</span>destination<span class="token punctuation">,</span> destination <span class="token operator">+</span> <span class="token string">':last'</span><span class="token punctuation">)</span>
                pipe<span class="token punctuation">.</span>rename<span class="token punctuation">(</span>start_key<span class="token punctuation">,</span> destination <span class="token operator">+</span> <span class="token string">':pstart'</span><span class="token punctuation">)</span>
                pipe<span class="token punctuation">.</span><span class="token builtin">set</span><span class="token punctuation">(</span>start_key<span class="token punctuation">,</span> hour_start<span class="token punctuation">)</span>
            <span class="token keyword">elif</span> <span class="token keyword">not</span> existing<span class="token punctuation">:</span>
                pipe<span class="token punctuation">.</span><span class="token builtin">set</span><span class="token punctuation">(</span>start_key<span class="token punctuation">,</span> hour_start<span class="token punctuation">)</span>
            <span class="token comment"># 更新日志出现次数</span>
            pipe<span class="token punctuation">.</span>zincrby<span class="token punctuation">(</span>destination<span class="token punctuation">,</span> message<span class="token punctuation">)</span>
            <span class="token comment"># 记录日志</span>
            log_recent<span class="token punctuation">(</span>pipe<span class="token punctuation">,</span> name<span class="token punctuation">,</span> message<span class="token punctuation">,</span> severity<span class="token punctuation">,</span> pipe<span class="token punctuation">)</span>
            <span class="token keyword">return</span>
        <span class="token keyword">except</span> redis<span class="token punctuation">.</span>exception<span class="token punctuation">.</span>WatchError<span class="token punctuation">:</span>
            <span class="token keyword">continue</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="在Redis中存储计数器"><a href="#在Redis中存储计数器" class="headerlink" title="在Redis中存储计数器"></a>在Redis中存储计数器</h3><p>在监控应用程序的同时，持续地收集信息是一件非常重要的事情。那些影响网站响应速度以及网站所能服务的页面数量的代码改动、新的广告营销活动或者是刚刚接触系统的新用户，都有可能会彻底地改变网站载入页面的数量，并因此而影响网站的各项性能指标。但如果我们平时不记录任何指标数据的话，我们就不可能知道指标发生了变化，也就不可能知道网站的性能是在提高还是在下降。<br>在收集指标数据方面，我们可以使用Redis构建一个工具。创建的每一个计数器都有自己的名字，并且会以不同的精度存储最新的数据样本。<br>在存储计数器方面，使用hash存储每个计数器在各个时间段的计数，用计数器的名字和频率构成命名空间。除此之外，利用有序集合存储计数器，并将他们的分值全部设为0，这样Redis在排序的时候就会根据成员值排序。<br><img lazyload="" src="/images/loading.svg" data-src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/redis/20220823154309.png"><br><img lazyload="" src="/images/loading.svg" data-src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/redis/20220823154332.png"></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 计数器精度</span>
PRECISION <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">,</span> <span class="token number">3600</span><span class="token punctuation">]</span>
<span class="token keyword">def</span> <span class="token function">update_counter</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> name<span class="token punctuation">,</span> count<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> now<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    now <span class="token operator">=</span> now <span class="token keyword">or</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment"># 用流水线减少消息通信次数</span>
    pipe <span class="token operator">=</span> conn<span class="token punctuation">.</span>pipeline<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment"># 更新各个频率的相关计数器</span>
    <span class="token keyword">for</span> prec <span class="token keyword">in</span> PRECISION<span class="token punctuation">:</span>
        pnow <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>now <span class="token operator">/</span> prec<span class="token punctuation">)</span> <span class="token operator">*</span> prec
        <span class="token builtin">hash</span> <span class="token operator">=</span> <span class="token string">'%s:%s'</span><span class="token operator">%</span><span class="token punctuation">(</span>prec<span class="token punctuation">,</span> name<span class="token punctuation">)</span>
        pipe<span class="token punctuation">.</span>zadd<span class="token punctuation">(</span><span class="token string">'known:'</span><span class="token punctuation">,</span> <span class="token builtin">hash</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
        pipe<span class="token punctuation">.</span>hincrby<span class="token punctuation">(</span><span class="token string">'count:'</span> <span class="token operator">+</span> <span class="token builtin">hash</span><span class="token punctuation">,</span> pnow<span class="token punctuation">,</span> count<span class="token punctuation">)</span>
    pipe<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">get_counter</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> name<span class="token punctuation">,</span> precision<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token builtin">hash</span> <span class="token operator">=</span> <span class="token string">'%s:%s'</span><span class="token operator">%</span><span class="token punctuation">(</span>precision<span class="token punctuation">,</span> name<span class="token punctuation">)</span>
    data <span class="token operator">=</span> conn<span class="token punctuation">.</span>hgetall<span class="token punctuation">(</span><span class="token string">'count:'</span> <span class="token operator">+</span> <span class="token builtin">hash</span><span class="token punctuation">)</span>
    to_return <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> key<span class="token punctuation">,</span> value <span class="token keyword">in</span> data<span class="token punctuation">.</span>iteritems<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        to_return<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>
    to_return<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> to_return<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>接下来就是清理计数器了，如果我们只是一味存储数据而不清理旧数据，必然会导致OOM。不过由于我们之前已经将计数器记录在了Redis的有序集合中，因此只需要遍历它并删除指定的数据即可。<br>在执行清理的过程中要注意以下几点：</p>
<ul>
<li>任何时候都可能会有新的计数器被添加进来</li>
<li>同一时候可能会有多个不同的清理操作</li>
<li>对于一个每天只更新一次的计数器来说，频繁扫描它的状态会浪费大量资源</li>
<li>不应尝试清理一个不包含数据的计数器</li>
</ul>
<p>接下来简单说一下清理的逻辑：开启一个守护进程，每隔60s扫描一次计数器，对于更新频率高于扫描频率的，每次扫描后都进行清理；而对那些更新频率低于扫描频率的则可以适当减少清理次数，比如一个5min更新一次的计数器，可以每扫描5次清理一次。获取要清理的计数器后，就按照可保存的最大样本数计算记录的截止时间，将截止时间之前的记录全部清理掉。清理完毕之后检查计数器中剩余的数据，如果没有数据了，就尝试删除，不过要监视该计数器，如果有别的客户端添加数据就放弃。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">clean_counters</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">:</span>
    pipe <span class="token operator">=</span> conn<span class="token punctuation">.</span>pipeline<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    passed <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment"># 记录清理程序的运行次数，用于同步不同频率的计数器的清理</span>
    <span class="token keyword">while</span> <span class="token keyword">not</span> QUIT<span class="token punctuation">:</span>
        start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>
        index <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">while</span> index <span class="token operator">&lt;</span> conn<span class="token punctuation">.</span>zcard<span class="token punctuation">(</span><span class="token string">'known:'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token builtin">hash</span> <span class="token operator">=</span> conn<span class="token punctuation">.</span>zrange<span class="token punctuation">(</span><span class="token string">'known:'</span><span class="token punctuation">,</span> index<span class="token punctuation">,</span> index<span class="token punctuation">)</span>
            index <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token builtin">hash</span><span class="token punctuation">:</span>
                <span class="token keyword">break</span>
            <span class="token comment"># 获取计数器名称以及频率</span>
            <span class="token builtin">hash</span> <span class="token operator">=</span> <span class="token builtin">hash</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
            prec <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">hash</span><span class="token punctuation">.</span>partition<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token comment"># 计算计数器的清理频率</span>
            hprec <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>prec <span class="token operator">//</span> <span class="token number">60</span><span class="token punctuation">)</span> <span class="token keyword">or</span> <span class="token number">1</span>
            <span class="token keyword">if</span> passes <span class="token operator">%</span> hprec<span class="token punctuation">:</span>
                <span class="token keyword">continue</span>
            hkey <span class="token operator">=</span> <span class="token string">'count:'</span> <span class="token operator">+</span> <span class="token builtin">hash</span>
            <span class="token comment"># 计算允许存在的记录的截止时间</span>
            cutoff <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> SAMPLE_COUNT <span class="token operator">*</span> prec
            <span class="token comment"># 获取计数器的时间戳</span>
            samples <span class="token operator">=</span> <span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> conn<span class="token punctuation">.</span>hkeys<span class="token punctuation">(</span>hkey<span class="token punctuation">)</span><span class="token punctuation">)</span>
            samples<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token comment"># 计算清理的数量</span>
            remove <span class="token operator">=</span> bbisect<span class="token punctuation">.</span>bisect_right<span class="token punctuation">(</span>samples<span class="token punctuation">,</span> cutoff<span class="token punctuation">)</span>

            <span class="token keyword">if</span> remove<span class="token punctuation">:</span>
                conn<span class="token punctuation">.</span>hdel<span class="token punctuation">(</span>hkey<span class="token punctuation">,</span> <span class="token operator">*</span>samples<span class="token punctuation">[</span><span class="token punctuation">:</span>remove<span class="token punctuation">]</span><span class="token punctuation">)</span>
                <span class="token comment"># 如果清理完之后计数器内容为空，尝试删除</span>
                <span class="token keyword">if</span> remove <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>samples<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    <span class="token keyword">try</span><span class="token punctuation">:</span>
                        pipe<span class="token punctuation">.</span>watch<span class="token punctuation">(</span>hkey<span class="token punctuation">)</span>
                        <span class="token keyword">if</span> <span class="token keyword">not</span> pipe<span class="token punctuation">.</span>hlen<span class="token punctuation">(</span>hkey<span class="token punctuation">)</span><span class="token punctuation">:</span>
                            pipe<span class="token punctuation">.</span>multi<span class="token punctuation">(</span><span class="token punctuation">)</span>
                            pipe<span class="token punctuation">.</span>zrem<span class="token punctuation">(</span><span class="token string">'known:'</span><span class="token punctuation">,</span> <span class="token builtin">hash</span><span class="token punctuation">)</span>
                            pipe<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span>
                            index <span class="token operator">-=</span> <span class="token number">1</span>
                        <span class="token keyword">else</span><span class="token punctuation">:</span>
                            pipe<span class="token punctuation">.</span>unwatch<span class="token punctuation">(</span><span class="token punctuation">)</span>
                    <span class="token keyword">except</span> redis<span class="token punctuation">.</span>exceptions<span class="token punctuation">.</span>WatchError<span class="token punctuation">:</span>
                        <span class="token keyword">pass</span>
    <span class="token comment"># 修改清理器的轮数</span>
    passes <span class="token operator">+=</span> <span class="token number">1</span>
    <span class="token comment"># 计算清理器的耗时</span>
    duration <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">)</span>
    <span class="token comment"># 让程序睡眠到下一个1分钟开始，如果之前已经运行了1min，就休眠1s</span>
    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token builtin">max</span><span class="token punctuation">(</span><span class="token number">60</span> <span class="token operator">-</span> duration<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="存储统计数据"><a href="#存储统计数据" class="headerlink" title="存储统计数据"></a>存储统计数据</h3><p>对于给定的上下文和类型，可以使用Redis的有序集合来存储类型的统计数据。当然这里不是为了利用它有序的特性，而是为了方便之后进行交并集运算。这里我们分析一下存储统计数据的需求：首先需要一种键值对的存储形式，可以将统计数据对应起来，其次需要能够进行交并运算方便不同统计数据间的比对，满足以上两个条件的只有有序集合。<br>接下来简单讲讲存储统计数据的思路：前一部分操作和log_common类似，记录当前小时和前1小时的信息。接着新建两个有序集合，一个作为最小值集合，一个作为最大值集合，然后利用适当的聚合函数计算新的最大最小值。这里专门使用并集运算的原因在于，这类值变动频率很大，自己用watch修改较为麻烦，不如交给redis的命令操作。然后对各成员进行更新即可。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">update_stats</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> context<span class="token punctuation">,</span> <span class="token builtin">type</span><span class="token punctuation">,</span> value<span class="token punctuation">,</span> timeout<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    destination <span class="token operator">=</span> <span class="token string">'stats:%s:%s'</span><span class="token operator">%</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> <span class="token builtin">type</span><span class="token punctuation">)</span>
    start_key <span class="token operator">=</span> destination <span class="token operator">+</span> <span class="token string">':start'</span>
    pipe <span class="token operator">=</span> conn<span class="token punctuation">.</span>pipeline<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    end <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> timeout
    <span class="token keyword">while</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> end<span class="token punctuation">:</span>
        <span class="token keyword">try</span><span class="token punctuation">:</span>
            pipe<span class="token punctuation">.</span>watch<span class="token punctuation">(</span>start_key<span class="token punctuation">)</span>
            now <span class="token operator">=</span> datetime<span class="token punctuation">.</span>utcnow<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>timetuple<span class="token punctuation">(</span><span class="token punctuation">)</span>
            hour_start <span class="token operator">=</span> datetime<span class="token punctuation">(</span><span class="token operator">*</span>now<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>isoformat<span class="token punctuation">(</span><span class="token punctuation">)</span>
            existing <span class="token operator">=</span> pipe<span class="token punctuation">.</span>get<span class="token punctuation">(</span>start_key<span class="token punctuation">)</span>
            pipe<span class="token punctuation">.</span>multi<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> existing <span class="token keyword">and</span> existing <span class="token operator">&lt;</span> hour_start<span class="token punctuation">:</span>
                pipe<span class="token punctuation">.</span>rename<span class="token punctuation">(</span>destination<span class="token punctuation">,</span> destination <span class="token operator">+</span> <span class="token string">':last'</span><span class="token punctuation">)</span>
                pipe<span class="token punctuation">.</span>rename<span class="token punctuation">(</span>start_key<span class="token punctuation">,</span> destination <span class="token operator">+</span> <span class="token string">':pstart'</span><span class="token punctuation">)</span>
                pipe<span class="token punctuation">.</span><span class="token builtin">set</span><span class="token punctuation">(</span>start_key<span class="token punctuation">,</span> hour_start<span class="token punctuation">)</span>
            <span class="token keyword">elif</span> <span class="token keyword">not</span> existing<span class="token punctuation">:</span>
                pipe<span class="token punctuation">.</span><span class="token builtin">set</span><span class="token punctuation">(</span>start_key<span class="token punctuation">,</span> hour_start<span class="token punctuation">)</span>
            tkey1 <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">(</span>uuid<span class="token punctuation">.</span>uuid4<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            tkey2 <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">(</span>uuid<span class="token punctuation">.</span>uuid4<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            pipe<span class="token punctuation">.</span>zadd<span class="token punctuation">(</span>tkey1<span class="token punctuation">,</span> <span class="token string">'min'</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span>
            pipe<span class="token punctuation">.</span>zadd<span class="token punctuation">(</span>tkey2<span class="token punctuation">,</span> <span class="token string">'max'</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span>
            pipe<span class="token punctuation">.</span>zunionstore<span class="token punctuation">(</span>destination<span class="token punctuation">,</span> 
                <span class="token punctuation">[</span>destination<span class="token punctuation">,</span> tkey1<span class="token punctuation">]</span><span class="token punctuation">,</span> aggregate<span class="token operator">=</span><span class="token string">'min'</span><span class="token punctuation">)</span>
            pipe<span class="token punctuation">.</span>zunionstore<span class="token punctuation">(</span>destination<span class="token punctuation">,</span>
                <span class="token punctuation">[</span>destination<span class="token punctuation">,</span> tkey2<span class="token punctuation">]</span><span class="token punctuation">,</span> aggregate<span class="token operator">=</span><span class="token string">'max'</span><span class="token punctuation">)</span>
            pipe<span class="token punctuation">.</span>delete<span class="token punctuation">(</span>tkey1<span class="token punctuation">,</span> tkey2<span class="token punctuation">)</span>
            pipe<span class="token punctuation">.</span>zincrby<span class="token punctuation">(</span>destination<span class="token punctuation">,</span> <span class="token string">'count'</span><span class="token punctuation">)</span>
            pipe<span class="token punctuation">.</span>zincrby<span class="token punctuation">(</span>destination<span class="token punctuation">,</span> <span class="token string">'sum'</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span>
            pipe<span class="token punctuation">.</span>zincrby<span class="token punctuation">(</span>destination<span class="token punctuation">,</span> <span class="token string">'sumsq'</span><span class="token punctuation">,</span> value<span class="token operator">*</span>value<span class="token punctuation">)</span>
            <span class="token keyword">return</span> pipe<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token comment"># 返回一些后续要用到的统计信息</span>
        <span class="token keyword">except</span> redis<span class="token punctuation">.</span>exceptions<span class="token punctuation">.</span>WatchError<span class="token punctuation">:</span>
            <span class="token keyword">continue</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在存储了统计数据之后，我们就可以开始尝试寻找例如生成速度较慢的网页，以方便后续优化。<br>我们可以给每个页面都添加一个计时器来解决这个问题，但要注意的是，我们真正需要的是统计数据，是访问最慢的几个页面，因此需要实现一个既能计时，又能将计时结果存储起来的东西。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token decorator annotation punctuation">@contextlib<span class="token punctuation">.</span>contextmanager</span>
<span class="token keyword">def</span> <span class="token function">access_time</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">:</span>
    start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">yield</span> <span class="token comment"># 执行被上下文管理器包裹的代码</span>
    delta <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start
    stats <span class="token operator">=</span> update_stats<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> context<span class="token punctuation">,</span> <span class="token string">'AccessTime'</span><span class="token punctuation">,</span> delta<span class="token punctuation">)</span>
    average <span class="token operator">=</span> stats<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">/</span> stats<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment"># 计算平均访问时长</span>
    pipe <span class="token operator">=</span> conn<span class="token punctuation">.</span>pipeline<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    pipe<span class="token punctuation">.</span>zadd<span class="token punctuation">(</span><span class="token string">'slowest:AccessTime'</span><span class="token punctuation">,</span> context<span class="token punctuation">,</span> average<span class="token punctuation">)</span>
    pipe<span class="token punctuation">.</span>zremrangebyrank<span class="token punctuation">(</span><span class="token string">'slowest:AccessTime'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">101</span><span class="token punctuation">)</span> <span class="token comment"># 只保留最慢的100个界面</span>
    pipe<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 使用方式</span>
<span class="token keyword">with</span> access_time<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">:</span>
    callback<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>统计数据不知能记录网页的加载速度，同样还可以加载模板的渲染速度，数据库的加载速度等等。除此之外，我们还可以将明显出现异常的统计数据输出到日志当中，方便进行问题的排查与优化。</p>
<h3 id="查找IP属地以及国家"><a href="#查找IP属地以及国家" class="headerlink" title="查找IP属地以及国家"></a>查找IP属地以及国家</h3><p>这一节要实现根据用户的IP定位其所在的地区。难点在于同一属地的IP地址数量很大，普通的筛选策略会消耗大量机器资源。不过同一地区的IP地址有一种特征：相比其他地区的起始IP，必然与所属地区IP的一致位数最多。因此这里可以将城市IP地址转换为分数，用有序队列存储。用户所属的地区IP就是在所有比用户IP分数小的地区IP中最大的那个。<br>在本例中使用散列存储城市详细信息，用有序队列存储ip分数与城市id的映射</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># IP转换为分数的函数</span>
<span class="token keyword">def</span> <span class="token function">ip_to_score</span><span class="token punctuation">(</span>ip_address<span class="token punctuation">)</span><span class="token punctuation">:</span>
    score <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> v <span class="token keyword">in</span> ip_address<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        score <span class="token operator">=</span> score <span class="token operator">*</span> <span class="token number">256</span> <span class="token operator">+</span> <span class="token builtin">int</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> score<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 将城市id以及其IP地址的分数添加到有序集合</span>
<span class="token keyword">def</span> <span class="token function">import_ips_to_redis</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> filename<span class="token punctuation">)</span><span class="token punctuation">:</span>
    csv_file <span class="token operator">=</span> csv<span class="token punctuation">.</span>reader<span class="token punctuation">(</span><span class="token builtin">open</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> <span class="token string">'rb'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> count<span class="token punctuation">,</span> row <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>csv_file<span class="token punctuation">)</span><span class="token punctuation">:</span>
        start_ip <span class="token operator">=</span> row<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">if</span> row <span class="token keyword">else</span> <span class="token string">''</span>
        <span class="token keyword">if</span> <span class="token string">'i'</span> <span class="token keyword">in</span> start_ip<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">continue</span>
        <span class="token keyword">if</span> <span class="token string">'.'</span> <span class="token keyword">in</span> start_ip<span class="token punctuation">:</span>
            start_ip <span class="token operator">=</span> ip_to_score<span class="token punctuation">(</span>start_ip<span class="token punctuation">)</span>
        <span class="token keyword">elif</span> start_ip<span class="token punctuation">.</span>isdigit<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            start_ip <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>start_ip<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">continue</span>
        city_id <span class="token operator">=</span> row<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">'_'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span>
        conn<span class="token punctuation">.</span>zadd<span class="token punctuation">(</span><span class="token string">'ip2cityid:'</span><span class="token punctuation">,</span> city_id<span class="token punctuation">,</span> start_ip<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">find_city_by_ip</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> ip_address<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>ip_address<span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        ip_address <span class="token operator">=</span> ip_to_score<span class="token punctuation">(</span>ip_address<span class="token punctuation">)</span>
    <span class="token comment"># 查找所属城市的id</span>
    city_id <span class="token operator">=</span> conn<span class="token punctuation">.</span>zrevrangebyscore<span class="token punctuation">(</span><span class="token string">'ip2cityid:'</span><span class="token punctuation">,</span> ip_address<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> start<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> num<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> city_id<span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">None</span>
    city_id <span class="token operator">=</span> city_id<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>partition<span class="token punctuation">(</span><span class="token string">'_'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    <span class="token keyword">return</span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>conn<span class="token punctuation">.</span>hget<span class="token punctuation">(</span><span class="token string">'cityid2city:'</span><span class="token punctuation">,</span> city_id<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="构建应用程序组件"><a href="#构建应用程序组件" class="headerlink" title="构建应用程序组件"></a>构建应用程序组件</h2><h3 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h3><p>假设我们现在需要完成一个最近联系人的自动补全功能。这需要我们能够快速向列表中添加或是删除联系人，除此之外，这个功能不能占用太多的内存。综合以上考量，应当选择列表作为存储结构，因为列表是Redis中内存占用最小的数据结构。<br>在构建最近联系人阶段，主要分为以下三个步骤：</p>
<ol>
<li>如果该联系人已经存在，就删除它</li>
<li>将新的最近联系人插入</li>
<li>如果最近联系人个数超出阈值就进行修剪</li>
</ol>
<p>当需要自动补全时，从Redis中获取最近联系人列表并进行匹配，返回匹配的联系人列表。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">fetch_autocomplete_list</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span> conn<span class="token punctuation">:</span> redis<span class="token punctuation">.</span>Redis<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">]</span><span class="token punctuation">,</span> prefix<span class="token punctuation">)</span><span class="token punctuation">:</span>
    candidates <span class="token operator">=</span> conn<span class="token punctuation">.</span>lrange<span class="token punctuation">(</span><span class="token string">'recent:'</span> <span class="token operator">+</span> user<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
    matches <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> c <span class="token keyword">in</span> candidates<span class="token punctuation">:</span>
        <span class="token keyword">if</span> c<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>startswith<span class="token punctuation">(</span>prefix<span class="token punctuation">)</span><span class="token punctuation">:</span>
            matches<span class="token punctuation">.</span>append<span class="token punctuation">(</span>c<span class="token punctuation">)</span>
    <span class="token keyword">return</span> matches<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>因为在构建最近联系人列表时，我们已经有意限制了联系人数量的大小，因此这种解决方案可以取得十分优秀的效果。但如果面对的是大量数据的情况，这种方案就不太适用了。可以考虑使用带有时间戳的有序列表实现该功能。</p>
<p>在上面的例子中，我们的解决思路是直接从Redis现有列表中查找匹配的元素。但当元素数量很多时，扫描整个列表只为寻找几个匹配的记录就显得不是那么划算了。对于与时间有关的自动补全已经给出了方案，但如果只给定范围呢，例如公会成员列表又该怎么做呢？</p>
<p>接下来要介绍的方案的核心思路是：根据给定参数创建查找范围从而提升查找效率。<br>在介绍解决方案之前还要先介绍以下有序集合的一种变相用法，前文有提到过，当所有成员的分值都相同时，Redis就会根据成员字符串的ASCII码来进行排序(这里假设所有成员名称均为纯英文)。因此，如果用户给定abc开头的前缀，那就是需要查找abbz…与abd之间的所有成员，程序可以通过向Redis中插入abb{和abc{来创建出查找范围(在ASCII码中，`是首个排在a前的字符，{是首个排在z后的字符)</p>
<p>创建查找范围的思路：利用二分查找找到prefix末尾的前置字符，然后添加’{‘作为查找范围的起点，然后在prefix最后添加{作为终点。实际上是找到首个小于prefix，以及首个大于prefix的字符串。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">valid_charater <span class="token operator">=</span> <span class="token string">'`abcdefghijklmnopqrstuvwxyz{'</span>
<span class="token keyword">def</span> <span class="token function">find_prefix_range</span><span class="token punctuation">(</span>prefix<span class="token punctuation">)</span><span class="token punctuation">:</span>
    pos <span class="token operator">=</span> bisect<span class="token punctuation">.</span>bisect_left<span class="token punctuation">(</span>valid_charater<span class="token punctuation">,</span> prefix<span class="token punctuation">)</span>
    suffix <span class="token operator">=</span> valid_charater<span class="token punctuation">[</span><span class="token punctuation">(</span>pos <span class="token keyword">or</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
    <span class="token keyword">return</span> prefix<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> suffix <span class="token operator">+</span> <span class="token string">'{'</span><span class="token punctuation">,</span> prefix <span class="token operator">+</span> <span class="token string">'{'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>具体查询的时候就是先向Redis插入刚刚创建的两个范围界限，在查找完成之后将它们删除。考虑到同一时间可能会有多个客户端尝试查询，在删除时需要开启事务，同时在返回结果时也要注意将带有{的元素清除(查询过程中可能有客户端插入了界限元素)</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">auto_complete_on_prefix</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> guide<span class="token punctuation">,</span> prefix<span class="token punctuation">)</span><span class="token punctuation">:</span>
    start<span class="token punctuation">,</span> end <span class="token operator">=</span> find_prefix_range<span class="token punctuation">(</span>prefix<span class="token operator">=</span>prefix<span class="token punctuation">)</span>
    identifier <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">(</span>uuid<span class="token punctuation">.</span>uuid4<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 为避免多个客户端同时查询导致起始元素和终止元素被重复添加</span>
    start <span class="token operator">+=</span> identifier
    end <span class="token operator">+=</span> identifier
    zset_name <span class="token operator">=</span> <span class="token string">"member:"</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>guide<span class="token punctuation">)</span>
    conn<span class="token punctuation">.</span>zadd<span class="token punctuation">(</span>zset_name<span class="token punctuation">,</span> <span class="token punctuation">{</span>start<span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">,</span> end<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    pipeline <span class="token operator">=</span> conn<span class="token punctuation">.</span>pipeline<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
        <span class="token keyword">try</span><span class="token punctuation">:</span>
            pipeline<span class="token punctuation">.</span>watch<span class="token punctuation">(</span>zset_name<span class="token punctuation">)</span>
            sindex <span class="token operator">=</span> pipeline<span class="token punctuation">.</span>zrank<span class="token punctuation">(</span>zset_name<span class="token punctuation">,</span> start<span class="token punctuation">)</span>
            eindex <span class="token operator">=</span> pipeline<span class="token punctuation">.</span>zrank<span class="token punctuation">(</span>zset_name<span class="token punctuation">,</span> end<span class="token punctuation">)</span>
            erange <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>sindex <span class="token operator">+</span> <span class="token number">9</span><span class="token punctuation">,</span> eindex <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span>  <span class="token comment"># type: ignore</span>
            pipeline<span class="token punctuation">.</span>multi<span class="token punctuation">(</span><span class="token punctuation">)</span>
            pipeline<span class="token punctuation">.</span>zrem<span class="token punctuation">(</span>zset_name<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span>
            pipeline<span class="token punctuation">.</span>zrange<span class="token punctuation">(</span>zset_name<span class="token punctuation">,</span> sindex<span class="token punctuation">,</span> erange<span class="token punctuation">)</span>  <span class="token comment"># type: ignore</span>
            items <span class="token operator">=</span> pipeline<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
            <span class="token keyword">break</span>
        <span class="token keyword">except</span> redis<span class="token punctuation">.</span>exceptions<span class="token punctuation">.</span>WatchError<span class="token punctuation">:</span>
            <span class="token keyword">continue</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span>item <span class="token keyword">for</span> item <span class="token keyword">in</span> items <span class="token keyword">if</span> <span class="token string">'{'</span> <span class="token keyword">not</span> <span class="token keyword">in</span> item<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>在上面的例子中，我们使用WATCH命令来保证数据的一致性。但在高负载的情况下，WATCH会导致大量的重试操作，大大拉低系统的性能。<br>以下列举一些并发情况下锁在不正确运行的症状：</p>
<ul>
<li>持有锁的进程因为操作时间过长而导致锁被自动释放，但进程本身并不知晓这一点，甚至还可能会错误地释放掉了其他进程持有的锁。</li>
<li>一个持有锁并打算执行长时间操作的进程已经崩溃，但其他想要获取锁的进程不知道哪个进程持有着锁，也无法检测出持有锁的进程已经崩溃，只能白白地浪费时间等待锁被释放。</li>
<li>在一个进程持有的锁过期之后，其他多个进程同时尝试去获取锁，并且都获得了锁。</li>
<li>上面提到的第一种情况和第三种情况同时出现，导致有多个进程获得了锁，而每个进程都以为自己是唯一一个获得锁的进程。</li>
</ul>
<p>下面我们来尝试以下手动实现一个简易的锁，具体思路如下：用锁名称构成命名空间，将值设置为一个uuid生成的字符串，所有涉及共享数据操作的程序都要尝试去获取指定的锁。程序会使用Redis命令<code>setnx</code>尝试获取锁(setnx只会在当前键没有值时将值插入进去)，插入成功就代表成功获取到锁，否则就不断重试去获取锁。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">acquire_lock</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> lockname<span class="token punctuation">,</span> acquire_timeout<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    identifier <span class="token operator">=</span> uuid<span class="token punctuation">.</span>uuid4<span class="token punctuation">(</span><span class="token punctuation">)</span>
    end <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> acquire_timeout
    <span class="token keyword">while</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> end<span class="token punctuation">:</span>
        <span class="token keyword">if</span> conn<span class="token punctuation">.</span>setnx<span class="token punctuation">(</span><span class="token string">'lock'</span> <span class="token operator">+</span> lockname<span class="token punctuation">,</span> identifier<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> identifier
        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">.001</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在购买操作时，就只需要将完整的购买操作包裹在持有锁的阶段就行。其中购买操作放在try代码段内是为了保证即使程序中途异常也能保证锁最后被释放。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">purchase_item_with_lock</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> buyerid<span class="token punctuation">,</span> itemid<span class="token punctuation">,</span> sellerid<span class="token punctuation">)</span><span class="token punctuation">:</span>
    buyer <span class="token operator">=</span> <span class="token string">"users:%s"</span><span class="token operator">%</span>buyerid
    seller <span class="token operator">=</span> <span class="token string">"users:%s"</span><span class="token operator">%</span>sellerid
    item <span class="token operator">=</span> <span class="token string">"%s.%s"</span><span class="token operator">%</span><span class="token punctuation">(</span>itemid<span class="token punctuation">,</span> sellerid<span class="token punctuation">)</span>
    inventory <span class="token operator">=</span> <span class="token string">"inventory:%s"</span><span class="token operator">%</span>buyerid
    locked <span class="token operator">=</span> acquire_lock<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> market<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> locked<span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">False</span>
    pipe <span class="token operator">=</span> conn<span class="token punctuation">.</span>pipeline<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        pipe<span class="token punctuation">.</span>zscore<span class="token punctuation">(</span><span class="token string">"market:"</span><span class="token punctuation">,</span> item<span class="token punctuation">)</span>
        pipe<span class="token punctuation">.</span>hget<span class="token punctuation">(</span>buyer<span class="token punctuation">,</span> <span class="token string">'funds'</span><span class="token punctuation">)</span>
        price<span class="token punctuation">,</span> funds <span class="token operator">=</span> pipe<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> price <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">or</span> price <span class="token operator">&gt;</span> funds<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>
        pipe<span class="token punctuation">.</span>hincrby<span class="token punctuation">(</span>seller<span class="token punctuation">,</span> <span class="token string">'funds'</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">(</span>price<span class="token punctuation">)</span><span class="token punctuation">)</span>
        pipe<span class="token punctuation">.</span>hincrby<span class="token punctuation">(</span>buyer<span class="token punctuation">,</span> <span class="token string">'funds'</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token operator">-</span>price<span class="token punctuation">)</span><span class="token punctuation">)</span>
        pipe<span class="token punctuation">.</span>sadd<span class="token punctuation">(</span>inventory<span class="token punctuation">,</span> itemid<span class="token punctuation">)</span>
        pipe<span class="token punctuation">.</span>zrem<span class="token punctuation">(</span><span class="token string">'market:'</span><span class="token punctuation">,</span> item<span class="token punctuation">)</span>
        pipe<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">True</span>
    <span class="token keyword">finally</span><span class="token punctuation">:</span>
        release_lock<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> market<span class="token punctuation">,</span> locked<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>而在释放锁的时候要注意：要监视锁对应键的情况，避免某一把锁被多次释放</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">release_lock</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> lockname<span class="token punctuation">,</span> identifier<span class="token punctuation">)</span><span class="token punctuation">:</span>
    pipe <span class="token operator">=</span> conn<span class="token punctuation">.</span>pipeline<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    lockname <span class="token operator">=</span> <span class="token string">'lock:'</span> <span class="token operator">+</span> lockname
    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
        <span class="token keyword">try</span><span class="token punctuation">:</span>
            pipe<span class="token punctuation">.</span>watch<span class="token punctuation">(</span>lockname<span class="token punctuation">)</span>
            <span class="token keyword">if</span> pipe<span class="token punctuation">.</span>get<span class="token punctuation">(</span>lockname<span class="token punctuation">)</span> <span class="token operator">==</span> identifier<span class="token punctuation">:</span>
                pipe<span class="token punctuation">.</span>multi<span class="token punctuation">(</span><span class="token punctuation">)</span>
                pipe<span class="token punctuation">.</span>delete<span class="token punctuation">(</span>lockname<span class="token punctuation">)</span>
                pipe<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token boolean">True</span>
            pipe<span class="token punctuation">.</span>unwatch<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span>
        <span class="token keyword">except</span> redis<span class="token punctuation">.</span>exceptions<span class="token punctuation">.</span>WatchError<span class="token punctuation">:</span>
            <span class="token keyword">pass</span>
    <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>以上的实例代码只实现了和watch同一粒度的锁，但在市场交易这种情况下，明显细粒度锁更加适合。因此只需要将传入<code>acquire_lock</code>中的lockname进行对应的修改就能实现粒度的更改。</p>
<p>dogpile效应：执行事务所需的时间越长，就会有越多待处理的事务互相重叠，这种重叠增加了执行单个事务所需的时间，并使得那些带有时间限制的事务失败的几率大幅上升，最终导致所有事务执行失败的几率和进行重试的几率都大幅地上升。典型例子就是用户等得不耐烦，重复发起请求，服务器压力飙升。</p>
<p>在完成了锁的创建与失效之后，就要考虑锁的超时处理了。为了保证客户端即使崩溃，也能正确释放锁，需要在其他客户端尝试请求锁且失败时，检查这一把锁的过期时间，如果没有过期就为其设置超时时间。这样，即使客户端在获取锁后，设置过期时间前崩溃了，也不会导致某一把锁从此无法获取。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">acquire_lock_with_timeout</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> lockname<span class="token punctuation">,</span> acquire_timeout<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span> lock_timeout<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    identifier <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">(</span>uuid<span class="token punctuation">.</span>uuid4<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    lockname <span class="token operator">=</span> <span class="token string">'lock:'</span> <span class="token operator">+</span> lockname
    lock_timeout <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span>ceil<span class="token punctuation">(</span>lock_timeout<span class="token punctuation">)</span><span class="token punctuation">)</span>
    end <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> acquire_timeout
    <span class="token keyword">while</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> end<span class="token punctuation">:</span>
        <span class="token keyword">if</span> conn<span class="token punctuation">.</span>setnx<span class="token punctuation">(</span>lockname<span class="token punctuation">,</span> identifier<span class="token punctuation">)</span><span class="token punctuation">:</span>
            conn<span class="token punctuation">.</span>expire<span class="token punctuation">(</span>lockname<span class="token punctuation">,</span> lock_timeout<span class="token punctuation">)</span>
            <span class="token keyword">return</span> identifier
        <span class="token keyword">elif</span> <span class="token keyword">not</span> conn<span class="token punctuation">.</span>ttl<span class="token punctuation">(</span>lockname<span class="token punctuation">)</span><span class="token punctuation">:</span>
            conn<span class="token punctuation">.</span>expire<span class="token punctuation">(</span>lockname<span class="token punctuation">,</span> lock_timeout<span class="token punctuation">)</span>
        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">.001</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>利用这个新的锁，我们就可以重新实现上面的自动补全功能，每有用户需要自动补全时就直接锁定整个联系人列表，避免多个用户查询导致不断的冲突重试。</p>
<h3 id="计数信号量"><a href="#计数信号量" class="headerlink" title="计数信号量"></a>计数信号量</h3><p>计数信号量用于限制一个资源最多能被多少进程同时访问，用于限定能被同时使用的资源数量。客户端获取信号量与锁的方式相同，区别在于获取不到锁会等待，而获取不到信号量则会直接返回结果。<br>这里使用有序队列搭配时间戳实现信号量的获取限制，程序为每一个进程生成一个唯一表示作为有序集合的成员，时间戳则为分数。若成员在指定排名之内则能够获取到信号量，否则删除自身在有序集合中的记录并返回空。同时程序在向集合中添加前会先清除过期记录。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">acquire_semaphore</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> semname<span class="token punctuation">,</span> limit<span class="token punctuation">,</span> timeout<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    identidier <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">(</span>uuid<span class="token punctuation">.</span>uuid4<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    now <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>
    pipeline <span class="token operator">=</span> conn<span class="token punctuation">.</span>pipeline<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>zremrangebyscore<span class="token punctuation">(</span>semname<span class="token punctuation">,</span> <span class="token string">'-inf'</span><span class="token punctuation">,</span> now <span class="token operator">-</span> timeout<span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>zadd<span class="token punctuation">(</span>semname<span class="token punctuation">,</span> identidier<span class="token punctuation">,</span> now<span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>zrank<span class="token punctuation">(</span>semname<span class="token punctuation">,</span> identidier<span class="token punctuation">)</span>
    <span class="token keyword">if</span> pipeline<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> limit<span class="token punctuation">:</span>
        <span class="token keyword">return</span> identidier
    conn<span class="token punctuation">.</span>zrem<span class="token punctuation">(</span>semname<span class="token punctuation">,</span> identidier<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token boolean">None</span>

<span class="token keyword">def</span> <span class="token function">release_semaphore</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> semname<span class="token punctuation">,</span> identifier<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> conn<span class="token punctuation">.</span>zrem<span class="token punctuation">(</span>semname<span class="token punctuation">,</span> identifier<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面是一个非常简单的信号量实现，它的缺陷在于会默认所有发起请求的客户端的系统时间都是一样的。如果系统A比系统B快10ms，只要B在A获取信号量的10ms以内尝试获取信号量，就能窃取到A的信号量。因类似情况导致锁获取结果不同的锁或信号量，我们称他们为不公平的锁/信号量。</p>
<p>为了让信号量尽量公平，我们可以在程序中再添加一个计数器，每当有一个进程尝试来获取信号量就将计数器值自增并赋给对应进程。在分配信号量时，根据进程获得的计数器值来确定。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">acquire_fair_semaphore</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> semname<span class="token punctuation">,</span> limit<span class="token punctuation">,</span> timeout<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    identifier <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">(</span>uuid<span class="token punctuation">.</span>uuid4<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    czset <span class="token operator">=</span> semname <span class="token operator">+</span> <span class="token string">':owner'</span>
    ctr <span class="token operator">=</span> semname <span class="token operator">+</span> <span class="token string">':counter'</span>
    now <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>
    pipeline <span class="token operator">=</span> conn<span class="token punctuation">.</span>pipeline<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>zremrangebyscore<span class="token punctuation">(</span>semname<span class="token punctuation">,</span> <span class="token string">'-inf'</span><span class="token punctuation">,</span> now <span class="token operator">-</span> timeout<span class="token punctuation">)</span> <span class="token comment"># 将已经超时的信号量删除</span>
    pipeline<span class="token punctuation">.</span>zinterstore<span class="token punctuation">(</span>czset<span class="token punctuation">,</span> <span class="token punctuation">{</span>czset<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> semname<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment"># czset中只会保留还在semaphore中的记录</span>
    pipeline<span class="token punctuation">.</span>incr<span class="token punctuation">(</span>ctr<span class="token punctuation">)</span>
    counter <span class="token operator">=</span> pipeline<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>zadd<span class="token punctuation">(</span>semname<span class="token punctuation">,</span> identifier<span class="token punctuation">,</span> now<span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>zadd<span class="token punctuation">(</span>czset<span class="token punctuation">,</span> identifier<span class="token punctuation">,</span> counter<span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>zrank<span class="token punctuation">(</span>czset<span class="token punctuation">,</span> identifier<span class="token punctuation">)</span>
    <span class="token keyword">if</span> pipeline<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> limit<span class="token punctuation">:</span>
        <span class="token keyword">return</span> identifier
    pipeline<span class="token punctuation">.</span>zrem<span class="token punctuation">(</span>semname<span class="token punctuation">,</span> identifier<span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>zrem<span class="token punctuation">(</span>czset<span class="token punctuation">,</span> identifier<span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token boolean">None</span>

<span class="token keyword">def</span> <span class="token function">release_fair_semaphore</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> semname<span class="token punctuation">,</span> identifier<span class="token punctuation">)</span><span class="token punctuation">:</span>
    pipeline <span class="token operator">=</span> conn<span class="token punctuation">.</span>pipeline<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>zrem<span class="token punctuation">(</span>semname<span class="token punctuation">,</span> identifier<span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>zrem<span class="token punctuation">(</span>semname <span class="token operator">+</span> <span class="token string">':owner'</span><span class="token punctuation">,</span> identifier<span class="token punctuation">)</span>
    <span class="token keyword">return</span> pipeline<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">acquire_fair_semaphore</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> semname<span class="token punctuation">,</span> limit<span class="token punctuation">,</span> timeout<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    identifier <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">(</span>uuid<span class="token punctuation">.</span>uuid4<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    czset <span class="token operator">=</span> semname <span class="token operator">+</span> <span class="token string">':owner'</span>
    ctr <span class="token operator">=</span> semname <span class="token operator">+</span> <span class="token string">':counter'</span>
    now <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>
    pipeline <span class="token operator">=</span> conn<span class="token punctuation">.</span>pipeline<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>zremrangebyscore<span class="token punctuation">(</span>semname<span class="token punctuation">,</span> <span class="token string">'-inf'</span><span class="token punctuation">,</span> now <span class="token operator">-</span> timeout<span class="token punctuation">)</span> <span class="token comment"># 将已经超时的信号量删除</span>
    pipeline<span class="token punctuation">.</span>zinterstore<span class="token punctuation">(</span>czset<span class="token punctuation">,</span> <span class="token punctuation">{</span>czset<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> semname<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment"># czset中只会保留还在semaphore中的记录</span>
    pipeline<span class="token punctuation">.</span>incr<span class="token punctuation">(</span>ctr<span class="token punctuation">)</span>
    counter <span class="token operator">=</span> pipeline<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>zadd<span class="token punctuation">(</span>semname<span class="token punctuation">,</span> identifier<span class="token punctuation">,</span> now<span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>zadd<span class="token punctuation">(</span>czset<span class="token punctuation">,</span> identifier<span class="token punctuation">,</span> counter<span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>zrank<span class="token punctuation">(</span>czset<span class="token punctuation">,</span> identifier<span class="token punctuation">)</span>
    <span class="token keyword">if</span> pipeline<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> limit<span class="token punctuation">:</span>
        <span class="token keyword">return</span> identifier
    pipeline<span class="token punctuation">.</span>zrem<span class="token punctuation">(</span>semname<span class="token punctuation">,</span> identifier<span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>zrem<span class="token punctuation">(</span>czset<span class="token punctuation">,</span> identifier<span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token boolean">None</span>

<span class="token keyword">def</span> <span class="token function">release_fair_semaphore</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> semname<span class="token punctuation">,</span> identifier<span class="token punctuation">)</span><span class="token punctuation">:</span>
    pipeline <span class="token operator">=</span> conn<span class="token punctuation">.</span>pipeline<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>zrem<span class="token punctuation">(</span>semname<span class="token punctuation">,</span> identifier<span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>zrem<span class="token punctuation">(</span>semname <span class="token operator">+</span> <span class="token string">':owner'</span><span class="token punctuation">,</span> identifier<span class="token punctuation">)</span>
    <span class="token keyword">return</span> pipeline<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>由于这里我们只给信号量设置了10秒的超时时间，如果交易过程超过了10s，那就需要及时对信号量进行刷新。同时还需要注意如果信号量已经因为过期被删除，就需要拒绝调用这的请求。<br>在长时间使用信号量的时候，必须以合适的频率对信号量进行刷新，避免超时导致信号量被删除。<br>因为我们在上面区分开了超时序列和计数序列，计数序列的内容根据超时序列进行同步，因此刷新时只需要更新超时序列，确保计数序列中的对应记录不被删除即可。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">refresh_fair_semaphore</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> semname<span class="token punctuation">,</span> identifier<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> conn<span class="token punctuation">.</span>zadd<span class="token punctuation">(</span>semname<span class="token punctuation">,</span> identifier<span class="token punctuation">,</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        release_fair_semaphore<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> semname<span class="token punctuation">,</span> identifier<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">False</span>
    <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在完成以上功能之后，就要开始考虑消除竞争条件了。下面想象一下这样的场景：线程A首先完成了计数器的自增操作，但在线程A将自己的标识符加入有序集合之前，B完成了自增操作和添加操作，抢先一步拿到信号量。这样，虽然线程A的计数排名靠前，但因为还没有加入集合，所以信号量归B。之后信号量A将自己加入集合，检查排名发现自己满足条件，于是便能直接窃取B已经获取的信号量。而B不会收到任何提示，只会在尝试删除信号量或刷新信号量时发现。</p>
<p>想要解决上述问题，首先要明确问题的根源：获取信号量的过程不是原子性的，是可再分的，因此在并发环境下它就是线程不安全的。而想让一个线程不安全的操作变得线程安全，最简单的方法就是加锁，加锁是一个原子性操作，获取锁之后的操作都将是线程安全的。因此只需要在获取信号量之前，先尝试获取对应信号量的锁。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">acquire_semaphore_with_lock</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> semname<span class="token punctuation">,</span> limit<span class="token punctuation">,</span> timeout<span class="token operator">=</span><span class="token number">.01</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    identifier <span class="token operator">=</span> market<span class="token punctuation">.</span>acquire_lock_with_timeout<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> semname<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span>
    <span class="token keyword">if</span> identifier<span class="token punctuation">:</span>
        <span class="token keyword">try</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> acquire_fair_semaphore<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> semname<span class="token punctuation">,</span> limit<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span>
        <span class="token keyword">finally</span><span class="token punctuation">:</span>
            market<span class="token punctuation">.</span>release_lock<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> semname<span class="token punctuation">,</span> identifier<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><p>在处理请求时，对于那些执行时间较长的操作，可以放入队列，之后再对队列进行处理。这样用户可以及时得到反馈，服务器也不会因某个任务而阻塞。<br>任务队列的应用非常广泛，最典型的就是给用户发送邮件、验证码。</p>
<h4 id="先进先出队列"><a href="#先进先出队列" class="headerlink" title="先进先出队列"></a>先进先出队列</h4><p>这里先介绍先进先出队列，用发送邮件当作例子。由于发送邮件都有较高的延迟，且容易出现失败的情况，因此将它交给队列处理会是个好选择。将要发送的邮件信息先存储在队列当中，当要发送时，构建一个工作进程以并行的方式一次发送多封邮件。<br>这里使用列表来存储邮件信息，用<code>RPUSH</code>添加邮件，<code>BLPOP</code>提取出要发送的邮件。由于邮件不一定每时每刻都有，因此使用阻塞队列可以避免程序过多次重试。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">process_sold_email_queue</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">while</span> <span class="token keyword">not</span> QUIT<span class="token punctuation">:</span>
        packed <span class="token operator">=</span> conn<span class="token punctuation">.</span>blpop<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'queue'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> packed<span class="token punctuation">:</span>
            <span class="token keyword">continue</span>
        to_send <span class="token operator">=</span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>packed<span class="token punctuation">)</span>
        <span class="token keyword">try</span><span class="token punctuation">:</span>
            fetch_data_and_send_sold_email<span class="token punctuation">(</span>to_send<span class="token punctuation">)</span>
        <span class="token keyword">except</span> EmailSenderError <span class="token keyword">as</span> e<span class="token punctuation">:</span>
            log_error<span class="token punctuation">(</span><span class="token string">"Failed to send"</span><span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            log_success<span class="token punctuation">(</span><span class="token string">"Send sold email"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这是队列的最简单的一种实现方式，接下来尝试给他添加优先级。<br>最简单的一种方式就是用不同的队列表示不同的优先级，并按顺序将他们放入列表传递给函数。Redis的<code>BLPOP</code>命令会在接收到的队列列表中按顺序从最先给他提供数据的列表中抽取对象。</p>
<h4 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h4><p>通常应用程序还会希望能让某个任务被延迟执行，例如B站发送视频设置准点发送就可以交给延迟队列来处理。这里最容易想到的一种方法就是使用有序集合存储任务的执行时间戳，定期扫描集合中有没有到期的任务要执行。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">execute_later</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> queue<span class="token punctuation">,</span> name<span class="token punctuation">,</span> args<span class="token punctuation">,</span> delay<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    identifier <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">(</span>uuid<span class="token punctuation">.</span>uuid4<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    item <span class="token operator">=</span> json<span class="token punctuation">.</span>dump<span class="token punctuation">(</span><span class="token punctuation">[</span>identifier<span class="token punctuation">,</span> queue<span class="token punctuation">,</span> name<span class="token punctuation">,</span> args<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> delay <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
        conn<span class="token punctuation">.</span>zadd<span class="token punctuation">(</span><span class="token string">'delayed:'</span><span class="token punctuation">,</span> item<span class="token punctuation">,</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> delay<span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        conn<span class="token punctuation">.</span>rpush<span class="token punctuation">(</span><span class="token string">'queue:'</span> <span class="token operator">+</span> queue<span class="token punctuation">,</span> item<span class="token punctuation">)</span>
    <span class="token keyword">return</span> identifier

<span class="token keyword">def</span> <span class="token function">poll_queue</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">while</span> <span class="token keyword">not</span> QUIT<span class="token punctuation">:</span>
        item <span class="token operator">=</span> conn<span class="token punctuation">.</span>zrange<span class="token punctuation">(</span><span class="token string">'delayed:'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> withscores<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> item <span class="token keyword">or</span> item<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">.01</span><span class="token punctuation">)</span>
            <span class="token keyword">continue</span>
        item <span class="token operator">=</span> item<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        identifier<span class="token punctuation">,</span> queue<span class="token punctuation">,</span> function<span class="token punctuation">,</span> args <span class="token operator">=</span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>item<span class="token punctuation">)</span>
        locked <span class="token operator">=</span> lock<span class="token punctuation">.</span>acquire_lock_with_timeout<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> identifier<span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> locked<span class="token punctuation">:</span>
            <span class="token keyword">continue</span>
        <span class="token keyword">if</span> conn<span class="token punctuation">.</span>zrem<span class="token punctuation">(</span><span class="token string">'delayed:'</span><span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">:</span>
            conn<span class="token punctuation">.</span>rpush<span class="token punctuation">(</span><span class="token string">'queue:'</span> <span class="token operator">+</span> queue<span class="token punctuation">,</span> item<span class="token punctuation">)</span>
        lock<span class="token punctuation">.</span>release_lock<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> identifier<span class="token punctuation">,</span> locked<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>实现时要注意的一点是，在转移任务时要给对应的任务加锁，避免某个任务被多次执行。</p>
<h3 id="消息拉取"><a href="#消息拉取" class="headerlink" title="消息拉取"></a>消息拉取</h3><p>当要实现两个或多个客户端之间的相互通信时，常常使用Redis的订阅发布功能，但这种实现必须要求收发方同时在线，一旦出现连接问题，发送的消息就会丢失。此外，如果客户端速度缓慢，也会拖慢Redis的运行效率。<br>基于以上问题，我们可以实现一个类似邮箱的功能，即使用户不在线也不影响发送消息，连接断开也不会导致消息丢失。<br>具体的实现思路非常简单，用一个队列存储用户的未读消息，每当有消息要发送，就将它放入队列，用户通过请求获取存储在队列中的消息。发送方也可以通过这个队列明确消息是否已被收到。</p>
<p>但是只实现一个一对一的消息收发肯定是不够的，接下来我们尝试实现一个一对多的消息拉取。<br>首先要明确存储的信息：消息需要存储在一个队列中，通过命名空间与指定群组绑定。还需要一个集合存储群组中的成员,其分值为该成员最后阅读的消息方便后续清理所有用户都阅读过的消息。这里还另外用集合存储了用户在各个群组最后的已读消息，方便用户筛选新的消息。<br><img lazyload="" src="/images/loading.svg" data-src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/redis/NeatReader-1661760163701.png"></p>
<p>然后就是创建群组的逻辑：程序会为当前群聊生成一个编号，然后初始化对应的成员集合以及已读集合，将对应成员的已读集合中群组的分值设为0. 最后发送初始化消息.</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">create_chat</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> sender<span class="token punctuation">,</span> recipients<span class="token punctuation">,</span> message<span class="token punctuation">,</span> chat_id<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    chat_id <span class="token operator">=</span> chat_id <span class="token keyword">or</span> conn<span class="token punctuation">.</span>incr<span class="token punctuation">(</span><span class="token string">'ids:chat'</span><span class="token punctuation">)</span>
    recipients<span class="token punctuation">.</span>append<span class="token punctuation">(</span>sender<span class="token punctuation">)</span>
    recipients_dict <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">for</span> r <span class="token keyword">in</span> recipients<span class="token punctuation">)</span>
    pipeline <span class="token operator">=</span> conn<span class="token punctuation">.</span>pipeline<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>zadd<span class="token punctuation">(</span><span class="token string">'chat:'</span> <span class="token operator">+</span> chat_id<span class="token punctuation">,</span> <span class="token operator">**</span>recipients_dict<span class="token punctuation">)</span>
    <span class="token keyword">for</span> r <span class="token keyword">in</span> recipients<span class="token punctuation">:</span>
        pipeline<span class="token punctuation">.</span>zadd<span class="token punctuation">(</span><span class="token string">'seen:'</span> <span class="token operator">+</span> r<span class="token punctuation">,</span> chat_id<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> send_message<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> chat_id<span class="token punctuation">,</span> sender<span class="token punctuation">,</span> message<span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">send_message</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> chat_id<span class="token punctuation">,</span> sender<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">:</span>
    identifier <span class="token operator">=</span> lock<span class="token punctuation">.</span>acquire_lock<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> <span class="token string">'chat:'</span> <span class="token operator">+</span> chat_id<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> identifier<span class="token punctuation">:</span>
        <span class="token keyword">raise</span> Exception<span class="token punctuation">(</span><span class="token string">"Couldn't get the lock"</span><span class="token punctuation">)</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        mid <span class="token operator">=</span> conn<span class="token punctuation">.</span>incr<span class="token punctuation">(</span><span class="token string">"ids:"</span> <span class="token operator">+</span> chat_id<span class="token punctuation">)</span>
        ts <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>
        packed <span class="token operator">=</span> json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span><span class="token punctuation">{</span>
            <span class="token string">'id'</span><span class="token punctuation">:</span> mid<span class="token punctuation">,</span>
            <span class="token string">'ts'</span><span class="token punctuation">:</span> ts<span class="token punctuation">,</span>
            <span class="token string">'sender'</span><span class="token punctuation">:</span> sender<span class="token punctuation">,</span>
            <span class="token string">'message'</span><span class="token punctuation">:</span> message
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        conn<span class="token punctuation">.</span>zadd<span class="token punctuation">(</span><span class="token string">'msgs:'</span> <span class="token operator">+</span> chat_id<span class="token punctuation">,</span> packed<span class="token punctuation">,</span> mid<span class="token punctuation">)</span>
    <span class="token keyword">finally</span><span class="token punctuation">:</span>
        lock<span class="token punctuation">.</span>release_lock<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> <span class="token string">'chat:'</span> <span class="token operator">+</span> chat_id<span class="token punctuation">,</span> identifier<span class="token punctuation">)</span>
    <span class="token keyword">return</span> chat_id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里只有发送消息的部分需要注意:需要用锁来包裹发送消息的代码. 一般来说，当程序使用一个来自Redis的值去构建另一个将要被添加到Redis里面的值时，就需要使用锁或者由<code>WATCH</code>、<code>MULTI</code>和<code>EXEC</code>组成的事务来消除竞争条件。</p>
<p>接下来是获取用户消息,由于我们已经在已读集合中存储了用户读取的最后一条消息的id,可以很轻易的构建出搜索范围.用户拉取到最新消息之后,更新对应的已读列表,并根据当前群组已读消息的最小id清理被所有用户阅读过的消息.</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">fetch_pending_message</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> recipient<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 获取当前用户所有已经阅读过的信息</span>
    seen <span class="token operator">=</span> conn<span class="token punctuation">.</span>zrange<span class="token punctuation">(</span><span class="token string">'seen:'</span> <span class="token operator">+</span> recipient<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> withscores<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    pipeline <span class="token operator">=</span> conn<span class="token punctuation">.</span>pipeline<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    <span class="token comment"># 获取用户所处群组所有的未读信息</span>
    <span class="token keyword">for</span> chat_id<span class="token punctuation">,</span> seen_id <span class="token keyword">in</span> seen<span class="token punctuation">:</span>
        pipeline<span class="token punctuation">.</span>zrangebyscore<span class="token punctuation">(</span>
            <span class="token string">'msgs:'</span> <span class="token operator">+</span> chat_id<span class="token punctuation">,</span> seen_id <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'inf'</span>
        <span class="token punctuation">)</span>
    chat_info <span class="token operator">=</span> <span class="token builtin">zip</span><span class="token punctuation">(</span>seen<span class="token punctuation">,</span> pipeline<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> i<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>chat_id<span class="token punctuation">,</span> seen_id<span class="token punctuation">)</span><span class="token punctuation">,</span> messages<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>chat_info<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> messages<span class="token punctuation">:</span>
            <span class="token keyword">continue</span>
        <span class="token comment"># 反序列化所有的未读消息</span>
        messages<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">map</span><span class="token punctuation">(</span>json<span class="token punctuation">.</span>loads<span class="token punctuation">,</span> messages<span class="token punctuation">)</span>
        seen_id <span class="token operator">=</span> messages<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'id'</span><span class="token punctuation">]</span>
        <span class="token comment"># 更新用户看过的最后一条消息</span>
        conn<span class="token punctuation">.</span>zadd<span class="token punctuation">(</span><span class="token string">'chat:'</span> <span class="token operator">+</span> chat_id<span class="token punctuation">,</span> recipient<span class="token punctuation">,</span> seen_id<span class="token punctuation">)</span>
        <span class="token comment"># 获取被所有人读过的消息的最小id</span>
        min_id <span class="token operator">=</span> conn<span class="token punctuation">.</span>zrange<span class="token punctuation">(</span>
            <span class="token string">'chat:'</span> <span class="token operator">+</span> chat_id<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> withscores<span class="token operator">=</span><span class="token boolean">True</span>
        <span class="token punctuation">)</span>
        <span class="token comment"># 更新群组中的最后一条已读消息</span>
        pipeline<span class="token punctuation">.</span>zadd<span class="token punctuation">(</span><span class="token string">'seen:'</span> <span class="token operator">+</span> recipient<span class="token punctuation">,</span> chat_id<span class="token punctuation">,</span> seen_id<span class="token punctuation">)</span>
        <span class="token keyword">if</span> min_id<span class="token punctuation">:</span>
            pipeline<span class="token punctuation">.</span>zremrangebyscore<span class="token punctuation">(</span>
                <span class="token string">'msgs:'</span> <span class="token operator">+</span> chat_id<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> min_id<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
            <span class="token punctuation">)</span>
        <span class="token comment"># 组装需要返回给用户的消息</span>
        chat_info<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>chat_id<span class="token punctuation">,</span> messages<span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> chat_info<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>最后是加入以及退出群组<br>当用户要加入群组时,需要把他添加到群组的有序集合,并更新用户已读集合.由于新加入群组必然会拉取最新的消息,因此将对应的已读id修改为最新的id.<br>在删除用户时,先将用户在对应群组的数据删除.然后检查群组人数,如果没有人了就直接将群组删除.如果还有人就根据最新的已读id删除所有被阅读过的消息.</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">leave_chat</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> chat_id<span class="token punctuation">,</span> user<span class="token punctuation">)</span><span class="token punctuation">:</span>
    pipeline <span class="token operator">=</span> conn<span class="token punctuation">.</span>pipeline<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>zrem<span class="token punctuation">(</span><span class="token string">'chat:'</span> <span class="token operator">+</span> chat_id<span class="token punctuation">,</span> user<span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>zrem<span class="token punctuation">(</span><span class="token string">'seen:'</span> <span class="token operator">+</span> user<span class="token punctuation">,</span> chat_id<span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>zcard<span class="token punctuation">(</span><span class="token string">'chat:'</span> <span class="token operator">+</span> chat_id<span class="token punctuation">)</span>

    <span class="token keyword">if</span> <span class="token keyword">not</span> pipeline<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        pipeline<span class="token punctuation">.</span>delete<span class="token punctuation">(</span><span class="token string">'msgs:'</span> <span class="token operator">+</span> chat_id<span class="token punctuation">)</span>
        pipeline<span class="token punctuation">.</span>delete<span class="token punctuation">(</span><span class="token string">'ids:'</span> <span class="token operator">+</span> chat_id<span class="token punctuation">)</span>
        pipeline<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        oldest <span class="token operator">=</span> conn<span class="token punctuation">.</span>zrange<span class="token punctuation">(</span><span class="token string">'chat:'</span> <span class="token operator">+</span> chat_id<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> withscores<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
        conn<span class="token punctuation">.</span>zremrangebyscore<span class="token punctuation">(</span><span class="token string">'msgs:'</span> <span class="token operator">+</span> chat_id<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> oldest<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="基于搜索的应用程序"><a href="#基于搜索的应用程序" class="headerlink" title="基于搜索的应用程序"></a>基于搜索的应用程序</h2><h3 id="使用Redis进行搜索"><a href="#使用Redis进行搜索" class="headerlink" title="使用Redis进行搜索"></a>使用Redis进行搜索</h3><p>在讲解如何使用Redis构建搜索引擎之前，我们首先要了解一下基本的搜索原理。要想获得比扫描文档更快的搜索速度，一个显而易见的方法就是构建索引，不过通常情况下的索引都是帮助快速从文档中找到对应内容，但这里要建的索引，是根据它的内容标记对应的文档，因此称为反向索引。<br>在Redis中，使用集合或有序集合来存储每一个关键字对应的文档，这样在搜索的时候就能根据关键字对应的文档集合计算交并集，快速的获取查询结果。<br><img lazyload="" src="/images/loading.svg" data-src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/redis/NeatReader-1661844354039.png" alt="反向索引"></p>
<h4 id="基本索引"><a href="#基本索引" class="headerlink" title="基本索引"></a>基本索引</h4><p>在给程序创建索引之前，首先要对文档进行标记化(tokenization)。这里我们采取一种非常简单的标记化方法：认定单词只能由英文字母和单引号组成，并且每个单词至少有两个字符长。<br>标记化的一个附加步骤，就是移除内容中的非用词(stop word)，这些词都不能提供有效的信息，剔除他们可以有效提升程序性能并且减小索引体积。<br>建立索引的基本思路就是：利用正则表达式找到匹配的单词，筛选出长度符合条件并且不属于非用词的部分，在他们对应的集合中加上文档的id</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">WORDS_RE <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token builtin">compile</span><span class="token punctuation">(</span><span class="token string">"[a-z']{2,}"</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">tokenize</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">:</span>
    words <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> <span class="token keyword">match</span> <span class="token keyword">in</span> WORDS_RE<span class="token punctuation">.</span>finditer<span class="token punctuation">(</span>content<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        word <span class="token operator">=</span> <span class="token keyword">match</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token string">"'"</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">2</span><span class="token punctuation">:</span>
            words<span class="token punctuation">.</span>add<span class="token punctuation">(</span>word<span class="token punctuation">)</span>
    <span class="token keyword">return</span> words <span class="token operator">-</span> STOP_WORDS

<span class="token keyword">def</span> <span class="token function">index_document</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> docid<span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">:</span>
    words <span class="token operator">=</span> tokenize<span class="token punctuation">(</span>content<span class="token punctuation">)</span>
    pipeline <span class="token operator">=</span> conn<span class="token punctuation">.</span>pipeline<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> word <span class="token keyword">in</span> words<span class="token punctuation">:</span>
        pipeline<span class="token punctuation">.</span>sadd<span class="token punctuation">(</span><span class="token string">'idx:'</span> <span class="token operator">+</span> word<span class="token punctuation">,</span> docid<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>pipeline<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果文档的索引会变化，则可以在标记化的过程中将所有的符合条件的单词以JSON字符串格式存储进Redis中，当文档变化重新构建索引时，就可以根据里面的内容剔除掉失效的索引。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">index_document</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> docid<span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">:</span>
    words_json <span class="token operator">=</span> conn<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'words:'</span> <span class="token operator">+</span> docid<span class="token punctuation">)</span>
    words <span class="token operator">=</span> tokenize<span class="token punctuation">(</span>content<span class="token punctuation">)</span>
    <span class="token keyword">if</span> words_json<span class="token punctuation">:</span>
        old_words <span class="token operator">=</span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>words_json<span class="token punctuation">)</span>
        invalid_words <span class="token operator">=</span> old_words <span class="token operator">-</span> words
    pipeline <span class="token operator">=</span> conn<span class="token punctuation">.</span>pipeline<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> word <span class="token keyword">in</span> invalid_words<span class="token punctuation">:</span>
        pipeline<span class="token punctuation">.</span>srem<span class="token punctuation">(</span><span class="token string">'idx:'</span> <span class="token operator">+</span> word<span class="token punctuation">,</span> docid<span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> pipeline<span class="token punctuation">.</span>scard<span class="token punctuation">(</span><span class="token string">'idx:'</span> <span class="token operator">+</span> word<span class="token punctuation">)</span><span class="token punctuation">:</span>
            pipeline<span class="token punctuation">.</span>delete<span class="token punctuation">(</span><span class="token string">'idx:'</span> <span class="token operator">+</span> word<span class="token punctuation">)</span>
    <span class="token keyword">for</span> word <span class="token keyword">in</span> words<span class="token punctuation">:</span>
        pipeline<span class="token punctuation">.</span>sadd<span class="token punctuation">(</span><span class="token string">'idx:'</span> <span class="token operator">+</span> word<span class="token punctuation">,</span> docid<span class="token punctuation">)</span>
    conn<span class="token punctuation">.</span><span class="token builtin">set</span><span class="token punctuation">(</span><span class="token string">'words:'</span> <span class="token operator">+</span> docid<span class="token punctuation">,</span> json<span class="token punctuation">.</span>dump<span class="token punctuation">(</span>words<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>pipeline<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>之后要考虑的就是搜索结果的生成操作，对于简单的搜索可以直接使用交集完成。但用户有时会希望使用同义词查询或是剔除掉包含指定单词的搜索结果，这就要用到并集和差集。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">_set_common</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> method<span class="token punctuation">,</span> names<span class="token punctuation">,</span> ttl<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">,</span> execute<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token builtin">id</span> <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">(</span>uuid<span class="token punctuation">.</span>uuid4<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    pipeline <span class="token operator">=</span> conn<span class="token punctuation">.</span>pipeline<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token keyword">if</span> execute <span class="token keyword">else</span> conn
    names <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'idx:'</span> <span class="token operator">+</span> name <span class="token keyword">for</span> name <span class="token keyword">in</span> names<span class="token punctuation">]</span>
    <span class="token builtin">getattr</span><span class="token punctuation">(</span>pipeline<span class="token punctuation">,</span> method<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">'idx:'</span> <span class="token operator">+</span> <span class="token builtin">id</span><span class="token punctuation">,</span> <span class="token operator">*</span>names<span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>expire<span class="token punctuation">(</span><span class="token string">'idx:'</span> <span class="token operator">+</span> <span class="token builtin">id</span><span class="token punctuation">,</span> ttl<span class="token punctuation">)</span>
    <span class="token keyword">if</span> execute<span class="token punctuation">:</span>
        pipeline<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token builtin">id</span>

<span class="token keyword">def</span> <span class="token function">intersect</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> items<span class="token punctuation">,</span> ttl<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">,</span> _execute<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> _set_common<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> <span class="token string">'sinterstore'</span><span class="token punctuation">,</span> items<span class="token punctuation">,</span> ttl<span class="token punctuation">,</span> _execute<span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">union</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> items<span class="token punctuation">,</span> ttl<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">,</span> _execute<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> _set_common<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> <span class="token string">'sunionstore'</span><span class="token punctuation">,</span> items<span class="token punctuation">,</span> ttl<span class="token punctuation">,</span> _execute<span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">difference</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> items<span class="token punctuation">,</span> ttl<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">,</span> _execute<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> _set_common<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> <span class="token string">'sdiffstore'</span><span class="token punctuation">,</span> items<span class="token punctuation">,</span> ttl<span class="token punctuation">,</span> _execute<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>接下来一步就是进行语法分析，这里规定对于以+为前缀的单词，表示这一个单词是之前单词的同义词，以-为前缀的单词表示要去掉包含该单词的搜索结果。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">parse</span><span class="token punctuation">(</span>query<span class="token punctuation">)</span><span class="token punctuation">:</span>
    unwanted <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token builtin">all</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    current <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> <span class="token keyword">match</span> <span class="token keyword">in</span> QUERY_RE<span class="token punctuation">.</span>finditer<span class="token punctuation">(</span>query<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        word <span class="token operator">=</span> <span class="token keyword">match</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span>
        prefix <span class="token operator">=</span> word<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span>
        <span class="token keyword">if</span> prefix <span class="token keyword">in</span> <span class="token string">'+-'</span><span class="token punctuation">:</span>
            word <span class="token operator">=</span> word<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            prefix <span class="token operator">=</span> <span class="token boolean">None</span>
        word <span class="token operator">=</span> word<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token string">"'"</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token keyword">or</span> word <span class="token keyword">in</span> STOP_WORDS<span class="token punctuation">:</span>
            <span class="token keyword">continue</span>
        <span class="token keyword">if</span> prefix <span class="token operator">==</span> <span class="token string">'-'</span><span class="token punctuation">:</span>
            unwanted<span class="token punctuation">.</span>add<span class="token punctuation">(</span>word<span class="token punctuation">)</span>
            <span class="token keyword">continue</span>
        <span class="token keyword">if</span> current <span class="token keyword">and</span> <span class="token keyword">not</span> prefix<span class="token punctuation">:</span>
            <span class="token builtin">all</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span>
            current <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        current<span class="token punctuation">.</span>add<span class="token punctuation">(</span>word<span class="token punctuation">)</span>
    <span class="token keyword">if</span> current<span class="token punctuation">:</span>
        <span class="token builtin">all</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token builtin">all</span><span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">(</span>unwanted<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>最后就是实现查找功能了，具体思路是：对于每一个同义词列表都进行并运算后将其对应的临时集合id添加到接下来的运算集合中，对于只有一个元素的集合则直接添加。将收集到的运算集合进行交集运算获得结果，如果没有要提出的关键字就直接返回，如果有则再将他们剔除</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">parse_and_search</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> query<span class="token punctuation">,</span> ttl<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token builtin">all</span><span class="token punctuation">,</span> unwanted <span class="token operator">=</span> parse<span class="token punctuation">(</span>query<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token builtin">all</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">None</span>
    to_intersect <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> syn <span class="token keyword">in</span> <span class="token builtin">all</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>syn<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">:</span>
            to_intersect<span class="token punctuation">.</span>append<span class="token punctuation">(</span>union<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> syn<span class="token punctuation">,</span> ttl<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            to_intersect<span class="token punctuation">.</span>append<span class="token punctuation">(</span>syn<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>to_intersect<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">:</span>
        intersect_result <span class="token operator">=</span> intersect<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> to_intersect<span class="token punctuation">,</span> ttl<span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        intersect_result <span class="token operator">=</span> to_intersect<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    <span class="token keyword">if</span> unwanted<span class="token punctuation">:</span>
        unwanted<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> intersect_result<span class="token punctuation">)</span>
        <span class="token keyword">return</span> difference<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> unwanted<span class="token punctuation">,</span> ttl<span class="token punctuation">)</span>
    <span class="token keyword">return</span> intersect_result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>不过单纯找出搜索结果还不够，最好可以根据关联度对搜索结果进行排序，方便用户查找需要的消息。这里使用最简单的一种关联度排序方式：根据文章的最后更新时间。<br>关联度排序的实现可以使用Redis的sort函数，它可以根据外部数据对结果进行排序。<br>对于排序生成的结果可以让他们的生存时间更长一点</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">search_and_sort</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> query<span class="token punctuation">,</span> <span class="token builtin">id</span><span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> ttl<span class="token operator">=</span><span class="token number">300</span><span class="token punctuation">,</span> sort<span class="token operator">=</span><span class="token string">'-updated'</span><span class="token punctuation">,</span> start<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> num<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    desc <span class="token operator">=</span> sort<span class="token punctuation">.</span>startswith<span class="token punctuation">(</span><span class="token string">'-'</span><span class="token punctuation">)</span>
    sort <span class="token operator">=</span> sort<span class="token punctuation">.</span>lstrip<span class="token punctuation">(</span><span class="token string">'-'</span><span class="token punctuation">)</span>
    by <span class="token operator">=</span> <span class="token string">'kd:doc:*-&gt;'</span> <span class="token operator">+</span> sort
    alpha <span class="token operator">=</span> sort <span class="token keyword">not</span> <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token string">'updated'</span><span class="token punctuation">,</span> <span class="token string">'id'</span><span class="token punctuation">,</span> <span class="token string">'created'</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token builtin">id</span> <span class="token keyword">and</span> <span class="token keyword">not</span> conn<span class="token punctuation">.</span>expire<span class="token punctuation">(</span><span class="token builtin">id</span><span class="token punctuation">,</span> ttl<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 如果用户提供了id，并且还没有过期就延长它的生存周期</span>
        <span class="token builtin">id</span> <span class="token operator">=</span> <span class="token boolean">None</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token builtin">id</span><span class="token punctuation">:</span> <span class="token comment"># 如果没有提供，就代表还没完成搜索</span>
        <span class="token builtin">id</span> <span class="token operator">=</span> parse_and_search<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> query<span class="token punctuation">,</span> ttl<span class="token punctuation">)</span>
    pipeline <span class="token operator">=</span> conn<span class="token punctuation">.</span>pipeline<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>scard<span class="token punctuation">(</span><span class="token string">'idx:'</span> <span class="token operator">+</span> <span class="token builtin">id</span><span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token string">'idx:'</span> <span class="token operator">+</span> <span class="token builtin">id</span><span class="token punctuation">,</span> by<span class="token operator">=</span>by<span class="token punctuation">,</span> alpha<span class="token operator">=</span>alpha<span class="token punctuation">,</span> desc<span class="token operator">=</span>desc<span class="token punctuation">,</span> start<span class="token operator">=</span>start<span class="token punctuation">,</span> num<span class="token operator">=</span>num<span class="token punctuation">)</span>
    results <span class="token operator">=</span> pipeline<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> results<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> results<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token builtin">id</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="有序索引"><a href="#有序索引" class="headerlink" title="有序索引"></a>有序索引</h4><p>但在真实的业务场景中，根据单一的指标进行关联度分析显然是不合理的，我们需要一种能够将各种指标按照指定的权重结合起来计算关联度的方法。<br>Redis的<code>ZINTERSTORE</code>命令可以将传入的集合，按照指定的权重进行聚合，这里我们让它按照计算各种指标的权重并相加。为了达成这个目的，还需要添加两个集合，一个统计投票数，一个统计更新时间。（ZINTERSTORE也可以接收普通集合，他们元素的分值都设为1）<br>解决思路：</p>
<ul>
<li><p>首先，如果程序接收到id并且该id没有过期，说明不需要再额外做一次查询，只需要将id对应的键的生命周期延长。</p>
</li>
<li><p>如果没有id或id过期，则再进行一次基本查询，获取到临时集合的id</p>
</li>
<li><p>接下来设置各个集合的权重，id对应的集合权重为0，因为该集合只负责与投票集合和更新集合匹配，投票集合以及更新集合的权重根据参数配置。之后将他们交给计算方法</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">search_and_zsort</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> query<span class="token punctuation">,</span> <span class="token builtin">id</span><span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> ttl<span class="token operator">=</span><span class="token number">300</span><span class="token punctuation">,</span> update<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> vote<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> start<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> num<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">,</span> desc<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">if</span> <span class="token builtin">id</span> <span class="token keyword">and</span> <span class="token keyword">not</span> conn<span class="token punctuation">.</span>expire<span class="token punctuation">(</span><span class="token builtin">id</span><span class="token punctuation">,</span> ttl<span class="token punctuation">)</span><span class="token punctuation">:</span>
      <span class="token builtin">id</span> <span class="token operator">=</span> <span class="token boolean">None</span>
  <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token builtin">id</span><span class="token punctuation">:</span>
      <span class="token builtin">id</span> <span class="token operator">=</span> parse_and_search<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> query<span class="token punctuation">,</span> ttl<span class="token operator">=</span>ttl<span class="token punctuation">)</span>
      scored_search <span class="token operator">=</span> <span class="token punctuation">{</span>
          <span class="token builtin">id</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
          <span class="token string">'sort:update'</span><span class="token punctuation">:</span> update<span class="token punctuation">,</span>
          <span class="token string">'sort:votes'</span><span class="token punctuation">:</span> vote
      <span class="token punctuation">}</span>
      <span class="token builtin">id</span> <span class="token operator">=</span> zintersect<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> scored_search<span class="token punctuation">,</span> ttl<span class="token punctuation">)</span>
  pipeline <span class="token operator">=</span> conn<span class="token punctuation">.</span>pipeline<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>
  <span class="token keyword">if</span> desc<span class="token punctuation">:</span>
      pipeline<span class="token punctuation">.</span>zrevrange<span class="token punctuation">(</span><span class="token string">'idx:'</span> <span class="token operator">+</span> <span class="token builtin">id</span><span class="token punctuation">,</span> start<span class="token punctuation">,</span> start <span class="token operator">+</span> num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token keyword">else</span><span class="token punctuation">:</span>
      pipeline<span class="token punctuation">.</span>zrange<span class="token punctuation">(</span><span class="token string">'idx:'</span> <span class="token operator">+</span> <span class="token builtin">id</span><span class="token punctuation">,</span> start<span class="token punctuation">,</span> start <span class="token operator">+</span> num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
  results <span class="token operator">=</span> pipeline<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> results<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> results<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token builtin">id</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>计算方法接收到参数后，将他们权重表中的键修改为Redis中对应的键，之后调用对应的方法</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">_zset_common</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> method<span class="token punctuation">,</span> scores<span class="token punctuation">,</span> ttl<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token operator">**</span>kw<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token builtin">id</span> <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">(</span>uuid<span class="token punctuation">.</span>uuid4<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  execute <span class="token operator">=</span> kw<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token string">'_execute'</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">)</span>
  pipeline <span class="token operator">=</span> conn<span class="token punctuation">.</span>pipeline<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token keyword">if</span> execute <span class="token keyword">else</span> conn
  <span class="token keyword">for</span> key <span class="token keyword">in</span> scores<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
      scores<span class="token punctuation">[</span><span class="token string">'idx:'</span> <span class="token operator">+</span> key<span class="token punctuation">]</span> <span class="token operator">=</span> scores<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
  <span class="token builtin">getattr</span><span class="token punctuation">(</span>pipeline<span class="token punctuation">,</span> method<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">'idx:'</span> <span class="token operator">+</span> <span class="token builtin">id</span><span class="token punctuation">,</span> scores<span class="token punctuation">,</span> <span class="token operator">**</span>kw<span class="token punctuation">)</span>
  pipeline<span class="token punctuation">.</span>expire<span class="token punctuation">(</span><span class="token string">'idx:'</span> <span class="token operator">+</span> <span class="token builtin">id</span><span class="token punctuation">,</span> ttl<span class="token punctuation">)</span>
  <span class="token keyword">if</span> execute<span class="token punctuation">:</span>
      pipeline<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token builtin">id</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<p>def zintersect(conn, items, ttl=30, **kw):<br>    return _zset_common(conn, ‘zinterstore’, dict(items), ttl, **kw)</p>
<p>def zunion(conn, items, ttl=30, **kw):<br>    return _zset_common(conn, ‘zunionstore’, dict(items), ttl, **kw)</p>
<pre class="line-numbers language-none"><code class="language-none">如果要让Redis实现非数值排序，那要做的工作显然就是将对应的非数值按照一定规则转换为数值。当我们想要进行字符串排序时，可以将每个字母转换成对应的数字，ASCII码显然是个不错的选择。不过这也同样有所限制，Redis的有序集合的分值使用64位浮点型存储，最多处理8个字符。这里的例子只进行前6位字母的排序。
```python
def string_to_score(string, ignore_case=False):
    if ignore_case:
        string = string.lower()
    pieces = map(ord, string[:6])
    while len(pieces) &lt; 6:
        pieces.append(-1)
    score = 0
    for piece in pieces:
        score = score * 257 + piece + 1
    return score * 2 + (len(string) &gt; 6)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>有了将字符串转换为分值的启发，之前的自动补全功能也能进行进一步优化。如果我们将人名信息转换为分值，那么在查询时就不必再建立查找范围，只需将原先用于建立查找范围的边界值转换为分值，然后调用zrangebyscore即可。<br>此外，如果我们修改字符串转换的规则，例如，只考虑小写字母的匹配，那么每一个字符只需要使用5个位即可完成存储，这样就能容纳下更多的字符进行前缀匹配。</p>
<h3 id="职位搜索"><a href="#职位搜索" class="headerlink" title="职位搜索"></a>职位搜索</h3><p>本节将着手解决职位搜索问题，更好的找到匹配求职者现有技能的职位。<br>首先最简单的一种实现方式就是将职位所需的技能要求都添加到对应的集合中，当求职者要查看是否匹配时，就将职位的技能集合和求职者的技能集合进行差集计算。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">add_job</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> job_id<span class="token punctuation">,</span> required_skills<span class="token punctuation">)</span><span class="token punctuation">:</span>
    conn<span class="token punctuation">.</span>sadd<span class="token punctuation">(</span><span class="token string">'job:'</span> <span class="token operator">+</span> job_id<span class="token punctuation">,</span> <span class="token operator">*</span>required_skills<span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">is_quialified</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> job_id<span class="token punctuation">,</span> candidate_skills<span class="token punctuation">)</span><span class="token punctuation">:</span>
    temp <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">(</span>uuid<span class="token punctuation">.</span>uuid4<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    pipeline <span class="token operator">=</span> conn<span class="token punctuation">.</span>pipeline<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>sadd<span class="token punctuation">(</span>temp<span class="token punctuation">,</span> <span class="token operator">*</span>candidate_skills<span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>expire<span class="token punctuation">(</span>temp<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>sdiff<span class="token punctuation">(</span><span class="token string">'job:'</span> <span class="token operator">+</span> job_id<span class="token punctuation">,</span> temp<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token keyword">not</span> pipeline<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个实现方法非常简单，但是缺点也很明显，它需要对每个职位都进行单独的检查，十分影响后续的性能扩展。</p>
<p>除了这种最简单的搜索方法之外，还可以通过搜索的方式查找到合适的职位，不过他对Redis数据结构的操作和平常的方法并不一样。<br>首先我们像建立反向索引一样，在每一个技能集合下存储需要这个技能的职位id，然后将每个职位需要的技能数存储在一个有序集合中。当程序接收到用户传入的技能组后，它会将涉及的技能集合进行并集运算，由于集合的分值默认位1，因此这样生成的结果就是职位id与求职者满足该职位要求的技能的数量。然后再将这个临时集合与存储了职位要求技能数的结合进行交集运算，一个集合的权重为1，另一个为-1，最后生成的结果中，分数为0的职位就是满足要求的职位。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">index_job</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> job_id<span class="token punctuation">,</span> skills<span class="token punctuation">)</span><span class="token punctuation">:</span>
    pipeline <span class="token operator">=</span> conn<span class="token punctuation">.</span>pipeline<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> skill <span class="token keyword">in</span> skills<span class="token punctuation">:</span>
        pipeline<span class="token punctuation">.</span>sadd<span class="token punctuation">(</span><span class="token string">'idx:skill:'</span> <span class="token operator">+</span> skill<span class="token punctuation">,</span> job_id<span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>zadd<span class="token punctuation">(</span><span class="token string">'idx:jobs:req'</span><span class="token punctuation">,</span> job_id<span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>skills<span class="token punctuation">)</span><span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">find_jobs</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> candidate_skills<span class="token punctuation">)</span><span class="token punctuation">:</span>
    skills <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">for</span> skill <span class="token keyword">in</span> <span class="token builtin">set</span><span class="token punctuation">(</span>candidate_skills<span class="token punctuation">)</span><span class="token punctuation">:</span>
        skills<span class="token punctuation">[</span><span class="token string">'skill:'</span> <span class="token operator">+</span> skill<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
    job_scores <span class="token operator">=</span> search<span class="token punctuation">.</span>zunion<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> skills<span class="token punctuation">)</span>
    final_result <span class="token operator">=</span> search<span class="token punctuation">.</span>zintersect<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> <span class="token punctuation">{</span>job_scores<span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'jobs:req'</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> conn<span class="token punctuation">.</span>zrangebyscore<span class="token punctuation">(</span><span class="token string">'idx:'</span> <span class="token operator">+</span> final_result<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果还要加上对技能熟练度的考虑，可以用有序集合存储技能要求，并根据熟练度要求给每个职位赋予相应的分值。然后在计算用户得分时也根据熟练度计算分值，最后结果 &gt;0 的都是满足要求的职位。</p>
<h2 id="构建简单的社交网站"><a href="#构建简单的社交网站" class="headerlink" title="构建简单的社交网站"></a>构建简单的社交网站</h2><h3 id="用户和状态"><a href="#用户和状态" class="headerlink" title="用户和状态"></a>用户和状态</h3><p>对于用户信息，通常都是使用散列来存储。创建用户的整个过程非常简单，但是需要注意的是，为了防止多个请求注册相同用户名导致唯一性被破坏，在开始执行创建操作之前，需要将要注册的用户名锁起来(这里用户名就是一种资源)。除此之外还要注意用户的敏感信息不能存储在该散列中，因为程序会频繁取出这个散列用于响应，这些信息应当存储在其他地方。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">create_user</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> login<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>
    llogin <span class="token operator">=</span> login<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment"># 尝试获取用户名对应的锁</span>
    lock <span class="token operator">=</span> acquire_lock_with_timeout<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> <span class="token string">"user:"</span> <span class="token operator">+</span> llogin<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token comment"># 如果获取失败，代表有别的线程在创建该用户名的角色</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> lock<span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">None</span>
    <span class="token comment"># 如果该用户名已被使用过，创建失败</span>
    <span class="token keyword">if</span> conn<span class="token punctuation">.</span>hget<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> <span class="token string">"user:"</span> <span class="token operator">+</span> llogin<span class="token punctuation">)</span><span class="token punctuation">:</span>
        release_lock<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> <span class="token string">"user:"</span> <span class="token operator">+</span> llogin<span class="token punctuation">,</span> lock<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">None</span>
    <span class="token builtin">id</span> <span class="token operator">=</span> conn<span class="token punctuation">.</span>incr<span class="token punctuation">(</span><span class="token string">"user:id:"</span><span class="token punctuation">)</span>
    pipeline <span class="token operator">=</span> conn<span class="token punctuation">.</span>pipeline<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>hset<span class="token punctuation">(</span><span class="token string">"users:"</span><span class="token punctuation">,</span> llogin<span class="token punctuation">,</span> <span class="token builtin">id</span><span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>hmset<span class="token punctuation">(</span><span class="token string">"users:%s"</span><span class="token operator">%</span><span class="token builtin">id</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token string">'login'</span><span class="token punctuation">:</span> login<span class="token punctuation">,</span>
        <span class="token string">'id'</span><span class="token punctuation">:</span> <span class="token builtin">id</span><span class="token punctuation">,</span>
        <span class="token string">'name'</span><span class="token punctuation">:</span> name<span class="token punctuation">,</span>
        <span class="token string">'followers'</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
        <span class="token string">'following'</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
        <span class="token string">'posts'</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
        <span class="token string">'signup'</span><span class="token punctuation">:</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span>
    release_lock<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> <span class="token string">"user:"</span> <span class="token operator">+</span> llogin<span class="token punctuation">,</span> lock<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token builtin">id</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建用户状态也非常简单，这里不多赘述</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">create_status</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> uid<span class="token punctuation">,</span> message<span class="token punctuation">,</span> <span class="token operator">**</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>
    pipeline <span class="token operator">=</span> conn<span class="token punctuation">.</span>pipeline<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>hget<span class="token punctuation">(</span><span class="token string">'user:%s'</span><span class="token operator">%</span>uid<span class="token punctuation">,</span> <span class="token string">'login'</span><span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>incr<span class="token punctuation">(</span><span class="token string">'status:id:'</span><span class="token punctuation">)</span>
    login<span class="token punctuation">,</span> <span class="token builtin">id</span> <span class="token operator">=</span> pipeline<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">if</span> <span class="token keyword">not</span> login<span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">None</span>
    data<span class="token punctuation">.</span>update<span class="token punctuation">(</span><span class="token punctuation">{</span>
        <span class="token string">'message'</span><span class="token punctuation">:</span> message<span class="token punctuation">,</span>
        <span class="token string">'posted'</span><span class="token punctuation">:</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token string">'id'</span><span class="token punctuation">:</span> <span class="token builtin">id</span><span class="token punctuation">,</span>
        <span class="token string">'uid'</span><span class="token punctuation">:</span> uid<span class="token punctuation">,</span>
        <span class="token string">'login'</span><span class="token punctuation">:</span> login
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>hmset<span class="token punctuation">(</span><span class="token string">'status:%s'</span><span class="token operator">%</span><span class="token builtin">id</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>hincrby<span class="token punctuation">(</span><span class="token string">'user:%s'</span><span class="token operator">%</span>uid<span class="token punctuation">,</span> <span class="token string">'posts'</span><span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token builtin">id</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="主页时间线"><a href="#主页时间线" class="headerlink" title="主页时间线"></a>主页时间线</h3><p>在使用B站等应用时，一般都会有动态功能，也就是主页时间线。他记录了一段时间里关注对象发布的动态消息。由于主页时间线很多时候是用户进入应用的入口，因此对应的信息必须简单易获取。<br>这里使用一个有序队列来存储状态消息id和它的发布时间戳。在查询的时候按照从新到旧的顺序查找状态信息id，并根据获取到的id取得状态信息数据。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">get_status_message</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> uid<span class="token punctuation">,</span> timeline<span class="token operator">=</span><span class="token string">'home:'</span><span class="token punctuation">,</span> page<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> count<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    statuses <span class="token operator">=</span> conn<span class="token punctuation">.</span>zrevrange<span class="token punctuation">(</span><span class="token string">'%s%s'</span><span class="token operator">%</span><span class="token punctuation">(</span>timeline<span class="token punctuation">,</span> uid<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>page<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>count<span class="token punctuation">,</span> page<span class="token operator">*</span>count<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
    pipeline <span class="token operator">=</span> conn<span class="token punctuation">.</span>pipeline<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> <span class="token builtin">id</span> <span class="token keyword">in</span> statuses<span class="token punctuation">:</span>
        pipeline<span class="token punctuation">.</span>hgetall<span class="token punctuation">(</span><span class="token string">'status:%s'</span><span class="token operator">%</span><span class="token builtin">id</span><span class="token punctuation">)</span>
    <span class="token comment"># 用过滤器过滤掉已被删除的部分</span>
    <span class="token keyword">return</span> <span class="token builtin">filter</span><span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">,</span> pipeline<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面的代码除了查询主页时间线意外，还可以查询到个人时间线(只包含个人动态)，只需要修改<code>timeline</code>即可。</p>
<p>当然以上的操作都只设计查询，真正的应用还需要在关注和取消关注时维护对应的时间线集合。这里使用两个有序集合存储用户的关注列表和被关注列表。存储用户id以及对应的关注/被关注时间戳。</p>
<p>当用户执行关注操作时，除了将用户id存入二人的关注列表和被关注列表之外，还需要将被关注者的一部分状态信息更新到关注者的主页时间线当中。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">HOME_TIMELINE_SIZE <span class="token operator">=</span> <span class="token number">1000</span>
<span class="token keyword">def</span> <span class="token function">follow_user</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> uid<span class="token punctuation">,</span> other_id<span class="token punctuation">)</span><span class="token punctuation">:</span>
    fkey1 <span class="token operator">=</span> <span class="token string">'following:%s'</span><span class="token operator">%</span>uid
    fkey2 <span class="token operator">=</span> <span class="token string">'followers:%s'</span><span class="token operator">%</span>other_id
    <span class="token keyword">if</span> conn<span class="token punctuation">.</span>zscore<span class="token punctuation">(</span>fkey1<span class="token punctuation">,</span> other_id<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">None</span>
    now <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>
    pipeline <span class="token operator">=</span> conn<span class="token punctuation">.</span>pipeline<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>zadd<span class="token punctuation">(</span>fkey1<span class="token punctuation">,</span> other_id<span class="token punctuation">,</span> now<span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>zadd<span class="token punctuation">(</span>fkey2<span class="token punctuation">,</span> uid<span class="token punctuation">,</span> now<span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>zrevrange<span class="token punctuation">(</span><span class="token string">'profile:%s'</span><span class="token operator">%</span>other_id<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> HOME_TIMELINE_SIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> withscores<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    following<span class="token punctuation">,</span> followers<span class="token punctuation">,</span> status_and_score <span class="token operator">=</span> pipeline<span class="token punctuation">.</span>execute<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
    pipeline<span class="token punctuation">.</span>hincrby<span class="token punctuation">(</span><span class="token string">'user:%s'</span><span class="token operator">%</span>uid<span class="token punctuation">,</span> <span class="token string">'following'</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">(</span>following<span class="token punctuation">)</span><span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>hincrby<span class="token punctuation">(</span><span class="token string">'user:%s'</span><span class="token operator">%</span>other_id<span class="token punctuation">,</span> <span class="token string">'followers'</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">(</span>followers<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> status_and_score<span class="token punctuation">:</span>
        pipeline<span class="token punctuation">.</span>zadd<span class="token punctuation">(</span><span class="token string">'home:%s'</span><span class="token operator">%</span>uid<span class="token punctuation">,</span> <span class="token operator">**</span><span class="token builtin">dict</span><span class="token punctuation">(</span>status_and_score<span class="token punctuation">)</span><span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>zremrangebyrank<span class="token punctuation">(</span><span class="token string">'home:%s'</span><span class="token operator">%</span>uid<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>HOME_TIMELINE_SIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在将关注者的主页时间线更新之后，还需要将他们的大小缩减到阈值，避免OOM。</p>
<p>取关的操作流程刚好与关注的流程相反，只需要将用户id从关注者列表和被关注者列表中移除，然后在主页时间线中修改对应的信息即可。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">unfollow_user</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> uid<span class="token punctuation">,</span> other_uid<span class="token punctuation">)</span><span class="token punctuation">:</span>
    fkey1 <span class="token operator">=</span> <span class="token string">'following:%s'</span><span class="token operator">%</span>uid
    fkey2 <span class="token operator">=</span> <span class="token string">'followers:%s'</span><span class="token operator">%</span>other_uid
    <span class="token keyword">if</span> <span class="token keyword">not</span> conn<span class="token punctuation">.</span>zscore<span class="token punctuation">(</span>fkey1<span class="token punctuation">,</span> other_uid<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">None</span>
    pipeline <span class="token operator">=</span> conn<span class="token punctuation">.</span>pipeline<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>zrem<span class="token punctuation">(</span>fkey1<span class="token punctuation">,</span> other_uid<span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>zrem<span class="token punctuation">(</span>fkey2<span class="token punctuation">,</span> uid<span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>zrevrange<span class="token punctuation">(</span><span class="token string">'profile:%s'</span><span class="token operator">%</span>other_uid<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> HOME_TIMELINE_SIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
    following<span class="token punctuation">,</span> followers<span class="token punctuation">,</span> statuses <span class="token operator">=</span> pipeline<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
    pipeline<span class="token punctuation">.</span>hincrby<span class="token punctuation">(</span><span class="token string">'user:%s'</span><span class="token operator">%</span>uid<span class="token punctuation">,</span> <span class="token string">'following'</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">(</span>following<span class="token punctuation">)</span><span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>hincrby<span class="token punctuation">(</span><span class="token string">'user:%s'</span><span class="token operator">%</span>other_uid<span class="token punctuation">,</span> <span class="token string">'followers'</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">(</span>followers<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> statuses<span class="token punctuation">:</span>
        pipeline<span class="token punctuation">.</span>zrem<span class="token punctuation">(</span><span class="token string">'home:%s'</span><span class="token operator">%</span>uid<span class="token punctuation">,</span> <span class="token operator">*</span>statuses<span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果想要在取消关注后重新填充，只需在取关后记录下本次在主页时间线中删除的记录数，然后去用户关注的博主的个人时间线中获取对应数量的记录填充进来即可，最后将大小修建为阈值。<br>不过用户在取关之后肯定希望立即得到反馈，因此，重新填充的工作可以交给延迟队列来进行。</p>
<h3 id="状态信息的发布与删除"><a href="#状态信息的发布与删除" class="headerlink" title="状态信息的发布与删除"></a>状态信息的发布与删除</h3><p>前面只讲了程序如何获取状态信息，接下来要做的就是添加状态信息的发布与删除。当消息发布时，对应的id应当被推送的关注者的主页时间线当中。如果关注者的数量较少，这个操作可以被立即执行，但如果关注者的数量非常庞大，那立即更新就会导致很长的等待时间，这里可以使用延迟队列来确保函数最终能够以合理的等待时间返回。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">post_status</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> uid<span class="token punctuation">,</span> message<span class="token punctuation">,</span> <span class="token operator">**</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token builtin">id</span> <span class="token operator">=</span> create_status<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> uid<span class="token punctuation">,</span> message<span class="token punctuation">,</span> <span class="token operator">**</span>data<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token builtin">id</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">None</span>
    posted <span class="token operator">=</span> conn<span class="token punctuation">.</span>hget<span class="token punctuation">(</span><span class="token string">'status:%s'</span><span class="token operator">%</span><span class="token builtin">id</span><span class="token punctuation">,</span> <span class="token string">'posted'</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> posted<span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">None</span>
    post <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token builtin">str</span><span class="token punctuation">(</span><span class="token builtin">id</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token builtin">float</span><span class="token punctuation">(</span>posted<span class="token punctuation">)</span><span class="token punctuation">}</span>
    conn<span class="token punctuation">.</span>zadd<span class="token punctuation">(</span><span class="token string">'profile:%s'</span><span class="token operator">%</span>uid<span class="token punctuation">,</span> <span class="token operator">**</span>post<span class="token punctuation">)</span>
    syndicate_status<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> uid<span class="token punctuation">,</span> post<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token builtin">id</span>

POST_PER_PASS <span class="token operator">=</span> <span class="token number">1000</span>
<span class="token keyword">def</span> <span class="token function">syndicate_status</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> uid<span class="token punctuation">,</span> post<span class="token punctuation">,</span> start<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 获取最多1000个关注者</span>
    followers <span class="token operator">=</span> conn<span class="token punctuation">.</span>zrangebyscore<span class="token punctuation">(</span><span class="token string">'followers:%s'</span><span class="token operator">%</span>uid<span class="token punctuation">,</span> start<span class="token punctuation">,</span> <span class="token string">'inf'</span><span class="token punctuation">,</span> start<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> num<span class="token operator">=</span>POST_PER_PASS<span class="token punctuation">,</span> withscores<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    pipeline <span class="token operator">=</span> conn<span class="token punctuation">.</span>pipeline<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>
    <span class="token comment"># 更新这些关注者的主页时间线</span>
    <span class="token comment"># 遍历的同时更新start变量，作为下一次的起始</span>
    <span class="token keyword">for</span> follower<span class="token punctuation">,</span> start <span class="token keyword">in</span> followers<span class="token punctuation">:</span>
        pipeline<span class="token punctuation">.</span>zadd<span class="token punctuation">(</span><span class="token string">'home:%s'</span><span class="token operator">%</span>follower<span class="token punctuation">,</span> <span class="token operator">**</span>post<span class="token punctuation">)</span>
        <span class="token comment"># 修剪主页时间线，防止它长度超过阈值</span>
        pipeline<span class="token punctuation">.</span>zremrangebyrank<span class="token punctuation">(</span><span class="token string">'home:%s'</span><span class="token operator">%</span>follower<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>HOME_TIMELINE_SIZE<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment"># 如果关注者数量很大，就将它推给延迟队列</span>
    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>followers<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> POST_PER_PASS<span class="token punctuation">:</span>
        execute_later<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> <span class="token string">'default'</span><span class="token punctuation">,</span> <span class="token string">'syndicate_status'</span><span class="token punctuation">,</span><span class="token punctuation">[</span>conn<span class="token punctuation">,</span> uid<span class="token punctuation">,</span> post<span class="token punctuation">,</span> start<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>而删除的操作相对来说就非常简单了，因为在获取状态消息时使用了filter过滤掉已经被删除的信息，因此只需要删除掉状态消息在散列中的记录，它就不会在任何时间线中出现了。具体的流程和别的删除操作没太大区别，同样是对被删除的记录加锁然后修改发布者的数据信息。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">delete_status</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> uid<span class="token punctuation">,</span> status_id<span class="token punctuation">)</span><span class="token punctuation">:</span>
    key <span class="token operator">=</span> <span class="token string">'status:%s'</span><span class="token operator">%</span>status_id
    lock <span class="token operator">=</span> acquire_lock_with_timeout<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> lock<span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">None</span>
    <span class="token keyword">if</span> conn<span class="token punctuation">.</span>hget<span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token string">'uid'</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token builtin">str</span><span class="token punctuation">(</span>uid<span class="token punctuation">)</span><span class="token punctuation">:</span>
        release_lock<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> key<span class="token punctuation">,</span> lock<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">None</span>
    pipeline <span class="token operator">=</span> conn<span class="token punctuation">.</span>pipeline<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>delete<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>zrem<span class="token punctuation">(</span><span class="token string">'profile:%s'</span><span class="token operator">%</span>uid<span class="token punctuation">,</span> status_id<span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>zrem<span class="token punctuation">(</span><span class="token string">'home:%s'</span><span class="token operator">%</span>uid<span class="token punctuation">,</span> status_id<span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>hincrby<span class="token punctuation">(</span><span class="token string">'user:%s'</span><span class="token operator">%</span>uid<span class="token punctuation">,</span> <span class="token string">'posts'</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span>
    release_lock<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> key<span class="token punctuation">,</span> lock<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这样的删除虽然简单，但是被删除的消息id依旧存储在用户的主页时间线里，时间久了会积压大量的无用数据，因此还需要对这些数据进行清理。<br>具体操作也非常简单，只需要通过消息散列获取对应的发布者id，得到关注者列表然后依据列表大小进行删除即可(分批/不分批)</p>
<h3 id="流API"><a href="#流API" class="headerlink" title="流API"></a>流API</h3><p>在开发网站的过程中，我们可能希望收集一些网站中发生的事件方便后续的优化与数据分析。最容易想到的实现方法就是专门执行一些调用来收集这些信息或是在所有执行操作的函数内部添加这部分功能。<br>不过在本节，我们使用另一种方法来实现这类功能：构建一些函数来广播事件，然后由负责数据分析的事件监听器来接收并处理。<br>流API与其他功能最大的区别就是，一般的操作都需要尽快完成并返回，而流API则需要在一定时间内持续返回结果。也就是说，随着事件推移，流API逐渐会构成一个由事件组成的序列，来让网站和客户端了解到在网站中发生的事情。<br>在接下来的例子中我们将让流API监控消息的创建与删除，由于流API不是像处理普通请求一样，一次性返回完整的所有数据，因此需要使用分块技术让HTTP服务器可以生成并发送增量式数据。</p>
<h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><p>首先第一步就是为流API创建一个服务器，这个服务器可以为每一个请求都开启一个线程进行处理。在服务器代码中体现的逻辑非常简单，就是先标识客户端接着验证请求是否合法然后交给过滤器进行过滤操作。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">StreamingAPIServer</span><span class="token punctuation">(</span>socketserver<span class="token punctuation">.</span>ThreadingMixIn<span class="token punctuation">,</span> http<span class="token punctuation">.</span>server<span class="token punctuation">.</span>HTTPServer<span class="token punctuation">)</span><span class="token punctuation">:</span>
    deamon_threads <span class="token operator">=</span> <span class="token boolean">True</span>

<span class="token keyword">class</span> <span class="token class-name">StreamingAPIRequestHandler</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>server<span class="token punctuation">.</span>BaseHTTPRequestHandler<span class="token punctuation">)</span><span class="token punctuation">:</span>

    <span class="token keyword">def</span> <span class="token function">do_GET</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        parse_identifier<span class="token punctuation">(</span>self<span class="token punctuation">)</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>path <span class="token operator">!=</span> <span class="token string">'/statuses/sample.json'</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> self<span class="token punctuation">.</span>send_error<span class="token punctuation">(</span><span class="token number">404</span><span class="token punctuation">)</span>
        process_filter<span class="token punctuation">(</span>self<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">do_POST</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        parse_identifier<span class="token punctuation">(</span>self<span class="token punctuation">)</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>path <span class="token operator">!=</span> <span class="token string">'/statuses/filter.json'</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> self<span class="token punctuation">.</span>send_error<span class="token punctuation">(</span><span class="token number">404</span><span class="token punctuation">)</span>
        process_filter<span class="token punctuation">(</span>self<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>接下来这部分是处理语法分析的函数</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">parse_identifier</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 将标识符和查询参数设为预留值</span>
    handler<span class="token punctuation">.</span>identifier <span class="token operator">=</span> <span class="token boolean">None</span>
    handler<span class="token punctuation">.</span>query <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token string">'?'</span> <span class="token keyword">in</span> handler<span class="token punctuation">.</span>path<span class="token punctuation">:</span>
        <span class="token comment"># 取出路径中包含查询参数的部分并更新路径</span>
        handler<span class="token punctuation">.</span>path<span class="token punctuation">,</span> _<span class="token punctuation">,</span> query <span class="token operator">=</span> handler<span class="token punctuation">.</span>path<span class="token punctuation">.</span>partition<span class="token punctuation">(</span><span class="token string">'?'</span><span class="token punctuation">)</span>
        <span class="token comment"># 通过语法分析获取查询参数</span>
        handler<span class="token punctuation">.</span>query <span class="token operator">=</span> urlparse<span class="token punctuation">.</span>parse_qs<span class="token punctuation">(</span>query<span class="token punctuation">)</span>
        <span class="token comment"># 获取identifier的查询参数列表</span>
        identifier <span class="token operator">=</span> handler<span class="token punctuation">.</span>query<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'identifier'</span><span class="token punctuation">)</span> <span class="token keyword">or</span> <span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">]</span>
        handler<span class="token punctuation">.</span>identifier <span class="token operator">=</span> identifier<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>之后是校验请求并向客户端发送流数据，这个函数的基本构思是确保服务器取得客户端的标识符，并且成功获取请求指定的过滤参数。最终按照分块的方式将数据传递给客户端</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">FILTERS <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'track'</span><span class="token punctuation">,</span> <span class="token string">'filter'</span><span class="token punctuation">,</span> <span class="token string">'location'</span><span class="token punctuation">}</span>
<span class="token keyword">def</span> <span class="token function">process_filters</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token builtin">id</span> <span class="token operator">=</span> handler<span class="token punctuation">.</span>identifier
    <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token builtin">id</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> handler<span class="token punctuation">.</span>send_error<span class="token punctuation">(</span><span class="token number">401</span><span class="token punctuation">,</span> <span class="token string">'identifier missing'</span><span class="token punctuation">)</span>
    method <span class="token operator">=</span> handler<span class="token punctuation">.</span>path<span class="token punctuation">.</span>rsplit<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    name <span class="token operator">=</span> <span class="token boolean">None</span>
    args <span class="token operator">=</span> <span class="token boolean">None</span>
    <span class="token keyword">if</span> method <span class="token operator">==</span> <span class="token string">'filter'</span><span class="token punctuation">:</span>
        data <span class="token operator">=</span> cgi<span class="token punctuation">.</span>FieldStorage<span class="token punctuation">(</span>
            fp<span class="token operator">=</span>handler<span class="token punctuation">.</span>rfile<span class="token punctuation">,</span>
            headers<span class="token operator">=</span>handler<span class="token punctuation">.</span>headers<span class="token punctuation">,</span>
            environ<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">'REQUEST_METHOD'</span><span class="token punctuation">:</span><span class="token string">'POST'</span><span class="token punctuation">,</span>
                    <span class="token string">'CONTENT_TYPE'</span><span class="token punctuation">:</span> handler<span class="token punctuation">.</span>headers<span class="token punctuation">[</span><span class="token string">'Content-Type'</span><span class="token punctuation">]</span><span class="token punctuation">}</span>
        <span class="token punctuation">)</span>
        <span class="token keyword">for</span> name <span class="token keyword">in</span> data<span class="token punctuation">:</span>
            <span class="token keyword">if</span> name <span class="token keyword">in</span> FILTERS<span class="token punctuation">:</span>
                args <span class="token operator">=</span> data<span class="token punctuation">.</span>getfirst<span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span>
                <span class="token keyword">break</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> args<span class="token punctuation">:</span>
            <span class="token keyword">return</span> handler<span class="token punctuation">.</span>send_error<span class="token punctuation">(</span><span class="token number">401</span><span class="token punctuation">,</span> <span class="token string">"no filter provided"</span><span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        args <span class="token operator">=</span> handler<span class="token punctuation">.</span>query
    handler<span class="token punctuation">.</span>send_response<span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span>
    handler<span class="token punctuation">.</span>send_header<span class="token punctuation">(</span><span class="token string">'Transfer-Encoding'</span><span class="token punctuation">,</span> <span class="token string">'chunked'</span><span class="token punctuation">)</span>
    handler<span class="token punctuation">.</span>end_headers<span class="token punctuation">(</span><span class="token punctuation">)</span>
    quit <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">False</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> item <span class="token keyword">in</span> filter_content<span class="token punctuation">(</span><span class="token builtin">id</span><span class="token punctuation">,</span> method<span class="token punctuation">,</span> name<span class="token punctuation">,</span> args<span class="token punctuation">,</span> quit<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">try</span><span class="token punctuation">:</span>
            handler<span class="token punctuation">.</span>wfile<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'%X\r\n%s\r\n'</span><span class="token operator">%</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">except</span> socket<span class="token punctuation">.</span>error<span class="token punctuation">:</span>
            quit<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> quit<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        handler<span class="token punctuation">.</span>wfile<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'0\r\n\r\n'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="对流消息进行过滤"><a href="#对流消息进行过滤" class="headerlink" title="对流消息进行过滤"></a>对流消息进行过滤</h4><p>一个大型的网站每时每刻都有大量的事件发生，如果将这些事件全部传输给客户端会带来大量的带宽消耗，因此让服务器只发送客户端需要的消息就非常重要了。<br>这里我们使用Redis的发布-订阅机制来实现部分功能：当用户发送一条消息时，将其发送给某一个频道，各个过滤器通过订阅那个频道来接收消息并当消息匹配时回传给客户端。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">create_status</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> uid<span class="token punctuation">,</span> message<span class="token punctuation">,</span> <span class="token operator">**</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>
    pipeline <span class="token operator">=</span> conn<span class="token punctuation">.</span>pipeline<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>hget<span class="token punctuation">(</span><span class="token string">'user:%s'</span><span class="token operator">%</span>uid<span class="token punctuation">,</span> <span class="token string">'login'</span><span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>incr<span class="token punctuation">(</span><span class="token string">'status:id:'</span><span class="token punctuation">)</span>
    login<span class="token punctuation">,</span> <span class="token builtin">id</span> <span class="token operator">=</span> pipeline<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">if</span> <span class="token keyword">not</span> login<span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">None</span>
    data<span class="token punctuation">.</span>update<span class="token punctuation">(</span><span class="token punctuation">{</span>
        <span class="token string">'message'</span><span class="token punctuation">:</span> message<span class="token punctuation">,</span>
        <span class="token string">'posted'</span><span class="token punctuation">:</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token string">'id'</span><span class="token punctuation">:</span> <span class="token builtin">id</span><span class="token punctuation">,</span>
        <span class="token string">'uid'</span><span class="token punctuation">:</span> uid<span class="token punctuation">,</span>
        <span class="token string">'login'</span><span class="token punctuation">:</span> login
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>hmset<span class="token punctuation">(</span><span class="token string">'status:%s'</span><span class="token operator">%</span><span class="token builtin">id</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>hincrby<span class="token punctuation">(</span><span class="token string">'user:%s'</span><span class="token operator">%</span>uid<span class="token punctuation">,</span> <span class="token string">'posts'</span><span class="token punctuation">)</span>
    <span class="token comment"># 新添加的代码，用于向过滤器发送消息</span>
    pipeline<span class="token punctuation">.</span>publish<span class="token punctuation">(</span><span class="token string">'streaming:status:'</span><span class="token punctuation">,</span> json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token builtin">id</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>而当要删除某条消息时，则要向频道中传输一条该消息已被删除的消息。如果程序本身就纪录了发送消息的状态，那这一步就不需要了，不过这样做带来的是管理上的难度。如果我们通过传递删除消息给过滤器，就可以避免存储状态信息，简化了服务器设计且降低了内存占用。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">delete_status</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> uid<span class="token punctuation">,</span> status_id<span class="token punctuation">)</span><span class="token punctuation">:</span>
    key <span class="token operator">=</span> <span class="token string">'status:%s'</span><span class="token operator">%</span>status_id
    lock <span class="token operator">=</span> acquire_lock_with_timeout<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> lock<span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">None</span>
    <span class="token keyword">if</span> conn<span class="token punctuation">.</span>hget<span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token string">'uid'</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token builtin">str</span><span class="token punctuation">(</span>uid<span class="token punctuation">)</span><span class="token punctuation">:</span>
        release_lock<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> key<span class="token punctuation">,</span> lock<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">None</span>
    pipeline <span class="token operator">=</span> conn<span class="token punctuation">.</span>pipeline<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    <span class="token comment"># 新增的代码，将已经删除了的消息发送给指定频道 </span>
    status <span class="token operator">=</span> conn<span class="token punctuation">.</span>hgetall<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
    status<span class="token punctuation">[</span><span class="token string">'deleted'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>
    pipeline<span class="token punctuation">.</span>publish<span class="token punctuation">(</span><span class="token string">'streaming:status'</span><span class="token punctuation">,</span> json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>delete<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>zrem<span class="token punctuation">(</span><span class="token string">'profile:%s'</span><span class="token operator">%</span>uid<span class="token punctuation">,</span> status_id<span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>zrem<span class="token punctuation">(</span><span class="token string">'home:%s'</span><span class="token operator">%</span>uid<span class="token punctuation">,</span> status_id<span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>hincrby<span class="token punctuation">(</span><span class="token string">'user:%s'</span><span class="token operator">%</span>uid<span class="token punctuation">,</span> <span class="token string">'posts'</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
    pipeline<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span>
    release_lock<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> key<span class="token punctuation">,</span> lock<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>处理好了发布消息的函数，接下来就要添加负责接收和处理流消息的函数了<br>首先创建一个过滤器来判断内容是否要发送给客户端。接着从频道中获取消息并取出消息状态；之后检查消息是否匹配，状态是否正常，如果消息已被删除则给客户端返回一个消息已删除的信息否则就返回整个消息。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token decorator annotation punctuation">@redis_connection</span><span class="token punctuation">(</span><span class="token string">'social-netword'</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">filter_content</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> <span class="token builtin">id</span><span class="token punctuation">,</span> method<span class="token punctuation">,</span> name<span class="token punctuation">,</span> args<span class="token punctuation">,</span> quit<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">match</span> <span class="token operator">=</span> create_filter<span class="token punctuation">(</span><span class="token builtin">id</span><span class="token punctuation">,</span> method<span class="token punctuation">,</span> name<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
    pubsub <span class="token operator">=</span> conn<span class="token punctuation">.</span>pubsub<span class="token punctuation">(</span><span class="token punctuation">)</span>
    pubsub<span class="token punctuation">.</span>subscribe<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'streaming:status:'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> item <span class="token keyword">in</span> pubsub<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        message <span class="token operator">=</span> item<span class="token punctuation">[</span><span class="token string">'data'</span><span class="token punctuation">]</span>
        decoded <span class="token operator">=</span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>message<span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token keyword">match</span><span class="token punctuation">(</span>decoded<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> decoded<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'deleted'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">yield</span> json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span><span class="token punctuation">{</span>
                    <span class="token string">'id'</span><span class="token punctuation">:</span> decoded<span class="token punctuation">[</span><span class="token string">'id'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
                    <span class="token string">'deleted'</span><span class="token punctuation">:</span> <span class="token boolean">True</span>
                <span class="token punctuation">}</span><span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">yield</span> message
            <span class="token keyword">if</span> quit<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                <span class="token keyword">break</span>
    pubsub<span class="token punctuation">.</span>reset<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>之后具体的过滤器创建就不多赘述了，可以根据自己的业务要求创建需要的过滤器。</p>
<h2 id="降低内存占用"><a href="#降低内存占用" class="headerlink" title="降低内存占用"></a>降低内存占用</h2><h3 id="短结构"><a href="#短结构" class="headerlink" title="短结构"></a>短结构</h3><p>对于长度比较短的结构，Redis提供了一系列配置选项，可以让它以更节约空间的方式存储长度较短的结构。<br>在列表、散列和有序集合的长度较短或者体积较小的时候，Redis可以选择使用一种名为_压缩列表_（ziplist）的紧凑存储方式来存储这些结构。压缩列表是列表、散列和有序集合这3种不同类型的对象的一种非结构化（unstructured）表示。<br>压缩列表会以序列化的方式存储数据，每次读取都要对数据进行解码，每次写入也要进行局部的重新编码，并且可能需要对内存里的数据进行移动。</p>
<h4 id="压缩列表表示"><a href="#压缩列表表示" class="headerlink" title="压缩列表表示"></a>压缩列表表示</h4><p>在讲压缩列表之前，我们先看一下Redis列表的存储方式。<br><img lazyload="" src="/images/loading.svg" data-src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/redis/20220914144938.png" alt="Redis长列表存储格式"></p>
<p>Redis在存储长列表时，会存储一个指向前面节点和后面节点的指针。在包含字符串的指针中，又会存储当前节点的字符串长度以及剩余可用的字节数量。也就是说每个节点都需要额外存储3个指针，两个整数，以及字符串内的一个额外字节，算下来每个节点都至少需要21个字节的额外开销。</p>
<p>而压缩列表则是用节点组成的序列，每个节点都用两个长度值和一个字符串组成。第一个长度值记录的是前一个节点的长度，这个长度值会被用来进行从后向前的遍历，第二个长度值记录了当前节点的长度，最后则是真正的字符串。压缩列表就是这样通过避免存储额外的元数据和指针来减少存储空间的占用。</p>
<p>Redis配置文件的设置</p>
<pre class="line-numbers language-none"><code class="language-none">list-max-ziplist-entries 512
list-max-ziplist-value 64

hash-max-ziplist-entries 512
hash-max-ziplist-value 64

zset-max-ziplist-entries 128
zset-max-ziplist-value 64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>entries表示列表散列和有序集合在被编码为压缩列表的情况下允许包含的最大元素<br>value表示压缩列表每个节点的最大体积是多少个字节</p>
<h4 id="集合的整数集合编码"><a href="#集合的整数集合编码" class="headerlink" title="集合的整数集合编码"></a>集合的整数集合编码</h4><p>对于体积较小，并且成员都可以被解释为十进制整数的集合，Redis就会以有序数组的方式存储集合，这种存储方式又称为整数集合。</p>
<p>配置文件设置</p>
<pre class="line-numbers language-none"><code class="language-none">set-max-intset-entries 512<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="短结构存在的性能问题"><a href="#短结构存在的性能问题" class="headerlink" title="短结构存在的性能问题"></a>短结构存在的性能问题</h4><p>前面提到，Redis存储短结构时，是将他们序列化后存储在内存中，这就代表他在读写时多了编解码操作，因此当短结构的体积很大时，它反而会带来巨大的性能问题。<br>而对于整数集合来说，虽然它本身不需要序列化存储，但每一次插入都需要进行数据的移动，当数据量非常大时，这个操作就会很消耗时间。</p>
<h3 id="分片结构"><a href="#分片结构" class="headerlink" title="分片结构"></a>分片结构</h3><p>分片：本质上是基于某些简单的规则将数据划分为更小的部分，然后根据数据所属的部分来决定将数据发送到哪个位置上面。<br>ps：分片对有序集合来说提升并不明显，因为有序集合需要等待所有的分片完成操作之后才能获得结果。</p>
<h4 id="分片式散列"><a href="#分片式散列" class="headerlink" title="分片式散列"></a>分片式散列</h4><p>对散列进行分片首先需要选择一个方法来对数据进行划分。因为散列本身就存储着一些键，所以程序在对键进行划分的时候，可以把散列存储的键用作其中一个信息源，并使用散列函数为键计算出一个数字散列值。然后程序会根据需要存储的键的总数量以及每个分片需要存储的键数量，计算出所需的分片数量，并使用这个分片数量和键的散列值来决定应该把键存储到哪个分片里面。</p>
<p>分片函数：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">shard_key</span><span class="token punctuation">(</span>base<span class="token punctuation">,</span> key<span class="token punctuation">,</span> total_elements<span class="token punctuation">,</span> shard_size<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">or</span> key<span class="token punctuation">.</span>isdigit<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        shard_id <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">//</span> shard_size
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        shards <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> total_elements <span class="token operator">//</span> shard_size
        shard_id <span class="token operator">=</span> binascii<span class="token punctuation">.</span>crc32<span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">%</span> shards
    <span class="token keyword">return</span> <span class="token string">"%s:%s"</span><span class="token operator">%</span><span class="token punctuation">(</span>base<span class="token punctuation">,</span> shard_id<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面例子中的分片函数需要用户传入基础散列的名字，将要被存储到分片散列里的键，预计的元素总数量以及请求的分片数量<br>在对非数字键进行分片时，需要<code>total_elements</code>和<code>shard_size</code>用于计算实际所需的分片总数量。因此这两个参数都应尽量不发生变化，即使真的需要修改，也要使用<code>resharding</code>(重新分片)来讲数据从旧分片迁移到新分片。</p>
<p>分片的使用</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">shard_hset</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> base<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> total_elements<span class="token punctuation">,</span> shard_size<span class="token punctuation">)</span><span class="token punctuation">:</span>
    shard <span class="token operator">=</span> shard_key<span class="token punctuation">(</span>base<span class="token punctuation">,</span> key<span class="token punctuation">,</span> total_elements<span class="token punctuation">,</span> shard_size<span class="token punctuation">)</span>
    <span class="token keyword">return</span> conn<span class="token punctuation">.</span>hset<span class="token punctuation">(</span>shard<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">shard_hget</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> base<span class="token punctuation">,</span> key<span class="token punctuation">,</span> total_elements<span class="token punctuation">,</span> shard_size<span class="token punctuation">)</span><span class="token punctuation">:</span>
    shard <span class="token operator">=</span> shard_key<span class="token punctuation">(</span>base<span class="token punctuation">,</span> key<span class="token punctuation">,</span> total_elements<span class="token punctuation">,</span> shard_size<span class="token punctuation">)</span>
    <span class="token keyword">return</span> conn<span class="token punctuation">.</span>hget<span class="token punctuation">(</span>shard<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="分片集合"><a href="#分片集合" class="headerlink" title="分片集合"></a>分片集合</h4><p>之前我们提到过计算网站唯一访客的数量，这里提一下另一种做法：使用集合存储到访用户的id，但如果单纯使用集合存储，那往往会导致最终集合的体积异常庞大，这时就可以使用到分片技术了。<br>只要使用上一节讲的分片方法，我们就能很轻易的实现分片集合，但由于我们存储的是UUID，它的过长的长度会导致我们无法享受到整数集合带来的好处。因此，我们可以将UUID的前15个十六进制数字用作分片的键。<br>使用UUID的前15个十六进制数字可以大幅减少内存的占用，同时让Redis能够以整数集合的方式存储。</p>
<p>具体实现<br>思路：根据用户的会话id生成传入Redis的id，并获取预期的访客数量，交给分片集合函数进行处理。如果成功添加，就将当天的访客数+1</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">shard_sadd</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> base<span class="token punctuation">,</span> member<span class="token punctuation">,</span> total_elements<span class="token punctuation">,</span> shard_size<span class="token punctuation">)</span><span class="token punctuation">:</span>
    shard <span class="token operator">=</span> shard_key<span class="token punctuation">(</span>base<span class="token punctuation">,</span> <span class="token string">'x'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>member<span class="token punctuation">)</span><span class="token punctuation">,</span> total_elements<span class="token punctuation">,</span> shard_size<span class="token punctuation">)</span>
    <span class="token keyword">return</span> conn<span class="token punctuation">.</span>sadd<span class="token punctuation">(</span>shard<span class="token punctuation">,</span> member<span class="token punctuation">)</span>

SHARD_SIZE <span class="token operator">=</span> <span class="token number">512</span>
<span class="token keyword">def</span> <span class="token function">count_visit</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> session_id<span class="token punctuation">)</span><span class="token punctuation">:</span>
    today <span class="token operator">=</span> date<span class="token punctuation">.</span>today<span class="token punctuation">(</span><span class="token punctuation">)</span>
    key <span class="token operator">=</span> <span class="token string">'unique:%s'</span><span class="token operator">%</span>today<span class="token punctuation">.</span>isoformat<span class="token punctuation">(</span><span class="token punctuation">)</span>
    expected <span class="token operator">=</span> get_expected<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> key<span class="token punctuation">,</span> today<span class="token punctuation">)</span>
    <span class="token builtin">id</span> <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>session_id<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'-'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> shard_sadd<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token builtin">id</span><span class="token punctuation">,</span> expected<span class="token punctuation">,</span> SHARD_SIZE<span class="token punctuation">)</span><span class="token punctuation">:</span>
        conn<span class="token punctuation">.</span>incr<span class="token punctuation">(</span>key<span class="token punctuation">)</span>

DAILY_EXPECTED <span class="token operator">=</span> <span class="token number">1000000</span>
EXPECTED <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">def</span> <span class="token function">get_expected</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> key<span class="token punctuation">,</span> today<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> key <span class="token keyword">in</span> DAILY_EXPECTED<span class="token punctuation">:</span>
        <span class="token keyword">return</span> EXPECTED<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
    exkey <span class="token operator">=</span> key <span class="token operator">+</span> <span class="token string">':expected'</span>
    expected <span class="token operator">=</span> conn<span class="token punctuation">.</span>get<span class="token punctuation">(</span>exkey<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> expected<span class="token punctuation">:</span>
        yesterday <span class="token operator">=</span> <span class="token punctuation">(</span>today <span class="token operator">-</span> timedelta<span class="token punctuation">(</span>days<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>isoformat<span class="token punctuation">(</span><span class="token punctuation">)</span>
        expected <span class="token operator">=</span> conn<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'unique:%s'</span><span class="token operator">%</span>yesterday<span class="token punctuation">)</span>
        expected <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>expected <span class="token keyword">or</span> DAILY_EXPECTED<span class="token punctuation">)</span>
        expected <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">**</span><span class="token builtin">int</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span>ceil<span class="token punctuation">(</span>math<span class="token punctuation">.</span>log<span class="token punctuation">(</span>expected<span class="token operator">*</span><span class="token number">1.5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> conn<span class="token punctuation">.</span>setnx<span class="token punctuation">(</span>exkey<span class="token punctuation">,</span> expected<span class="token punctuation">)</span><span class="token punctuation">:</span>
            expected <span class="token operator">=</span> conn<span class="token punctuation">.</span>get<span class="token punctuation">(</span>exkey<span class="token punctuation">)</span>
    EXPECTED<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>expected<span class="token punctuation">)</span>
    <span class="token keyword">return</span> EXPECTED<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="扩展Redis"><a href="#扩展Redis" class="headerlink" title="扩展Redis"></a>扩展Redis</h2><h3 id="扩展读性能"><a href="#扩展读性能" class="headerlink" title="扩展读性能"></a>扩展读性能</h3><p>在开始扩展性能之前，先回顾一下可以提高性能的几个途径：</p>
<ol>
<li>使用上一章提到的短结构时，确保压缩列表的最大长度不会太大以至于影响性能。</li>
<li>根据程序需要执行的查询类型，选择能为这种查询提供最好性能的结构。</li>
<li>在将大体积的对象缓存到Redis里之前，考虑先对它进行压缩以减少读取和写入对象时所需的网络带宽。</li>
<li>使用流水线和连接池。</li>
</ol>
<p>接下来就可以开始考虑提升Redis读取能力的方法了，最容易想到的就是添加只读从服务器。<br>在使用只读从服务器时，必须牢记只可以对Redis主服务器进行写入。</p>
<p>在使用多个Redis从服务器处理查询时可能会遇到的最棘手的问题就是主服务器临时下线或者永久下线。所以每当有从服务器尝试与主服务器建立连接时，主服务器都会为从服务器创建一个快照，如果有多个从服务器建立连接，他们最后都会收到同一个快照。这大幅减少了创建快照的工作负担。<br>不过大量的发送快照副本也会大量消耗主服务器的带宽，导致主服务器延迟变高，甚至主服务器已经建立的连接断开。</p>
<p>因此，想要解决服务器重同步问题的办法之一，就是减少主服务器传送给从服务器的数据量。而最简单的实现方法，就是添加一个中间层，让中间层的服务器负责转发数据副本。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/redis/20220923104227.png"></p>
<p>中间层可以有效分担主服务器传输数据副本的压力，不过这也导致了复杂的网络拓扑结构，增加了处理故障的难度。</p>
<p>除了添加服务器群组之外，解决重同步的另一个方向就是对网络连接进行压缩，从而减少需要传送的数据量。</p>
<blockquote>
<p>[!note]+ 加密和压缩开销</p>
</blockquote>
<p>使用带压缩的SSH隧道可以有效减少网络负载。<br>SSH隧道：在SSH客户端与SSH服务端之间建立一个隧道，将网络数据通过该隧道转发至指定端口，从而进行网络通信。SSH隧道自动提供了相应的加密及解密服务，保证了数据传输的安全性。<br>SSH的加密算法并不会占用很多的处理器资源，一般来说会将SSH压缩的等级控制在5级以下。因为5级压缩可以在1级压缩的基础上，将数据的总体积减少10%～20%，并且只需要相当于1级压缩2～3倍的处理时间。</p>
<blockquote>
<p>[!note]+ 使用OPENVPN进行压缩</p>
</blockquote>
<p>初看上去，使用AES加密和lzo压缩的OpenVPN似乎是一个绝妙的现成解决方案，跟SSH需要使用第三方脚本才能进行自动重连接相比，OpenVPN不仅提供加密和压缩功能，而且还具有对用户透明的重连接功能。遗憾的是，我能够找到的大部分信息都显示OpenVPN在开启lzo压缩之后，对于10兆网络连接的性能提升只有25%～30%，而对于速度更快的连接，lzo压缩不会给性能带来任何提升。</p>
<blockquote>
<p>[!def]+ Sentinal</p>
</blockquote>
<p>Redis的哨兵可以配合Redis的复制功能使用，并对下线的主服务器进行故障转移。哨兵会监视系一列主服务器以及这些主服务器的从服务器。<br>通过向主服务器发送PUBLISH和SUBSCRIBE命令(确认主服务器能够正确收发消息)，并向主从服务器发送PING命令，各个哨兵进程可以自主识别可用的从服务器和其他的哨兵。当主服务器失效时，监视该主服务器的所有哨兵会基于彼此共有的信息选出一个哨兵，并选出一个新的主服务器。选出的哨兵会负责让剩余的从服务器去复制这个新的主服务器。</p>
<h3 id="扩展写性能"><a href="#扩展写性能" class="headerlink" title="扩展写性能"></a>扩展写性能</h3><p>在扩展写性能之前，我们同样需要检查是否已经尽一切可能降低了内存占用，并且是否尽可能介绍了需要写入的数据量。</p>
<ul>
<li>尽可能减少程序需要读取的数据量</li>
<li>将无关的功能迁移至其他服务器</li>
<li>在对Redis进行写入之前，尝试在本地内存中对将要写入的数据进行聚合运算</li>
<li>使用锁去替换可能会给速度带来限制的<code>WATCH/MULTI/EXEC</code>事务</li>
<li>降低命令长度</li>
</ul>
<p>如果以上的操作都基本已经做到极限了，就代表达到了单台服务器的性能瓶颈。这时就可以将数据分片到多台机器上了。</p>
<blockquote>
<p>[!tip]+ 预先分片</p>
</blockquote>
<p>在为了应对未来可能出现的流量增长而对系统进行预先分片的时候，我们可能会陷入这样一种处境：目前拥有的数据实在太少，按照预先分片方法计算出的机器数量去存储这些数据只会得不偿失。为了能够如常地对数据进行分割，我们可以在单台机器上面运行多个Redis服务器，并将每个服务器用作一个分片；或者使用单个Redis服务器上的多个Redis数据库。然后以此为起点，复制和配置管理方法，将数据迁移到多台机器上面。</p>
<h4 id="分片配置信息处理"><a href="#分片配置信息处理" class="headerlink" title="分片配置信息处理"></a>分片配置信息处理</h4><p>由于各个分片分布在不同的机器上，因此需要一个函数来根据分片动态获取对应的Redis连接。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">get_redis_connection</span><span class="token punctuation">(</span>component<span class="token punctuation">,</span> wait<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    key <span class="token operator">=</span> <span class="token string">'config:redis:'</span> <span class="token operator">+</span> component
    <span class="token comment"># 获取旧配置</span>
    old_config <span class="token operator">=</span> CONFIGS<span class="token punctuation">.</span>get<span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token builtin">object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment"># 获取新配置</span>
    config <span class="token operator">=</span> get_config<span class="token punctuation">(</span>
        config_connection<span class="token punctuation">,</span> <span class="token string">'redis'</span><span class="token punctuation">,</span> component<span class="token punctuation">,</span> wait<span class="token punctuation">)</span>
    <span class="token comment"># 如果新旧配置不同，就创建一个新的连接</span>
    <span class="token keyword">if</span> config <span class="token operator">!=</span> old_config<span class="token punctuation">:</span>
        REDIS_CONNECTIONS<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> redis<span class="token punctuation">.</span>Redis<span class="token punctuation">(</span><span class="token operator">**</span>config<span class="token punctuation">)</span>
    <span class="token keyword">return</span> REDIS_CONNECTIONS<span class="token punctuation">.</span>get<span class="token punctuation">(</span>key<span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">get_sharded_connection</span><span class="token punctuation">(</span>component<span class="token punctuation">,</span> key<span class="token punctuation">,</span> shard_count<span class="token punctuation">,</span> wait<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    shard <span class="token operator">=</span> shard_key<span class="token punctuation">(</span>component<span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token operator">+</span><span class="token builtin">str</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> shard_count<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> get_redis_connection<span class="token punctuation">(</span>shard<span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="创建分片服务器连接装饰器"><a href="#创建分片服务器连接装饰器" class="headerlink" title="创建分片服务器连接装饰器"></a>创建分片服务器连接装饰器</h4><p>接下来我们就需要使用<code>get_sharded_connection</code>写出一个能够自动创建分片连接，并将分片连接传递给底层函数的装饰器。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">sharded_connection</span><span class="token punctuation">(</span>component<span class="token punctuation">,</span> shard_count<span class="token punctuation">,</span> wait<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span>function<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token decorator annotation punctuation">@functools<span class="token punctuation">.</span>wraps</span><span class="token punctuation">(</span>function<span class="token punctuation">)</span>
        <span class="token keyword">def</span> <span class="token function">call</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
            conn <span class="token operator">=</span> get_sharded_connection<span class="token punctuation">(</span>
                component<span class="token punctuation">,</span> key<span class="token punctuation">,</span> shard_count<span class="token punctuation">,</span> wait
            <span class="token punctuation">)</span>
            <span class="token keyword">return</span> function<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>
        <span class="token keyword">return</span> call
    <span class="token keyword">return</span> wrapper<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个包装器可以实现在不修改<code>count_visit()</code>的情况下直接对它进行封装。但要注意的是，由于count_visit需要维持聚合计数信息，而获取这些信息需要通过get_expected，这个函数没有必要分片并且会在不同的时期被不同的用户使用，所以需要对它进行非分片连接。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token decorator annotation punctuation">@sharded_connection</span><span class="token punctuation">(</span><span class="token string">'unique'</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">count_visit</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> session_id<span class="token punctuation">)</span><span class="token punctuation">:</span>
    today <span class="token operator">=</span> date<span class="token punctuation">.</span>today<span class="token punctuation">(</span><span class="token punctuation">)</span>
    key <span class="token operator">=</span> <span class="token string">'unique:%s'</span><span class="token operator">%</span>today<span class="token punctuation">.</span>isoformat<span class="token punctuation">(</span><span class="token punctuation">)</span>
    conn2<span class="token punctuation">,</span> expected <span class="token operator">=</span> get_expected<span class="token punctuation">(</span>key<span class="token punctuation">,</span> today<span class="token punctuation">)</span>
    <span class="token builtin">id</span> <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>session_id<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'-'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> shard<span class="token punctuation">.</span>shard_sadd<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token builtin">id</span><span class="token punctuation">,</span> expected<span class="token punctuation">,</span> shard<span class="token punctuation">.</span>SHARD_SIZE<span class="token punctuation">)</span><span class="token punctuation">:</span>
        conn2<span class="token punctuation">.</span>incr<span class="token punctuation">(</span>key<span class="token punctuation">)</span>

<span class="token comment"># 获取非分片连接</span>
<span class="token decorator annotation punctuation">@redis_connection</span><span class="token punctuation">(</span><span class="token string">'unique'</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">get_expected</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> key<span class="token punctuation">,</span> today<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> key <span class="token keyword">in</span> DAILY_EXPECTED<span class="token punctuation">:</span>
        <span class="token keyword">return</span> EXPECTED<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
    exkey <span class="token operator">=</span> key <span class="token operator">+</span> <span class="token string">':expected'</span>
    expected <span class="token operator">=</span> conn<span class="token punctuation">.</span>get<span class="token punctuation">(</span>exkey<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> expected<span class="token punctuation">:</span>
        yesterday <span class="token operator">=</span> <span class="token punctuation">(</span>today <span class="token operator">-</span> timedelta<span class="token punctuation">(</span>days<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>isoformat<span class="token punctuation">(</span><span class="token punctuation">)</span>
        expected <span class="token operator">=</span> conn<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'unique:%s'</span><span class="token operator">%</span>yesterday<span class="token punctuation">)</span>
        expected <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>expected <span class="token keyword">or</span> DAILY_EXPECTED<span class="token punctuation">)</span>
        expected <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">**</span><span class="token builtin">int</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span>ceil<span class="token punctuation">(</span>math<span class="token punctuation">.</span>log<span class="token punctuation">(</span>expected<span class="token operator">*</span><span class="token number">1.5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> conn<span class="token punctuation">.</span>setnx<span class="token punctuation">(</span>exkey<span class="token punctuation">,</span> expected<span class="token punctuation">)</span><span class="token punctuation">:</span>
            expected <span class="token operator">=</span> conn<span class="token punctuation">.</span>get<span class="token punctuation">(</span>exkey<span class="token punctuation">)</span>
    EXPECTED<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>expected<span class="token punctuation">)</span>
    <span class="token comment"># 返回非分片连接，使得count_visit()在有需要时可以对唯一计数器操作</span>
    <span class="token keyword">return</span> conn<span class="token punctuation">,</span> EXPECTED<span class="token punctuation">[</span>key<span class="token punctuation">]</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="Redis的Lua脚本编程"><a href="#Redis的Lua脚本编程" class="headerlink" title="Redis的Lua脚本编程"></a>Redis的Lua脚本编程</h2><h3 id="将Lua脚本载入Redis"><a href="#将Lua脚本载入Redis" class="headerlink" title="将Lua脚本载入Redis"></a>将Lua脚本载入Redis</h3><p>SCRIPT LOAD: 载入Lua脚本，返回一个SHA1校验和<br>EVALSHA: 调用SHA校验和对应的脚本</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">script_load</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">:</span>
    sha <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">]</span>
    <span class="token keyword">def</span> <span class="token function">call</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> keys<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> force_eval<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> force_eval<span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> sha<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                sha<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> conn<span class="token punctuation">.</span>execute_command<span class="token punctuation">(</span>
                    <span class="token string">"SCRIPT"</span><span class="token punctuation">,</span> <span class="token string">"LOAD"</span><span class="token punctuation">,</span> script<span class="token punctuation">,</span> parse<span class="token operator">=</span><span class="token string">"LOAD"</span>
                <span class="token punctuation">)</span>
        <span class="token keyword">try</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> conn<span class="token punctuation">.</span>execute_command<span class="token punctuation">(</span>
                <span class="token string">"EVALSHA"</span><span class="token punctuation">,</span> sha<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>keys<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>keys<span class="token operator">+</span>args<span class="token punctuation">)</span>
            <span class="token punctuation">)</span>
        <span class="token keyword">except</span> redis<span class="token punctuation">.</span>exceptions<span class="token punctuation">.</span>ResponseError <span class="token keyword">as</span> msg<span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> msg<span class="token punctuation">.</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>starswith<span class="token punctuation">(</span><span class="token string">"NOSCRIPT"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">raise</span>
        <span class="token keyword">return</span> conn<span class="token punctuation">.</span>execute_command<span class="token punctuation">(</span>
            <span class="token string">"EVAL"</span><span class="token punctuation">,</span> script<span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>keys<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>keys<span class="token operator">+</span>args<span class="token punctuation">)</span>
        <span class="token punctuation">)</span>
    <span class="token keyword">return</span> call<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面是一个加载Lua脚本的函数，这个脚本允许我们使用任何指定的连接而无需显示创建新的脚本对象。在调用该函数第一次执行命令时，会调用<code>SCRIPT LOAD</code>，之后会调用<code>EVALSHA</code>。<br>由于脚本在返回各种不同类型的数据时可能会产生含糊不清的结果，所以应该尽量显示的返回字符串，然后手动进行分析操作。</p>
<h3 id="创建新的状态信息"><a href="#创建新的状态信息" class="headerlink" title="创建新的状态信息"></a>创建新的状态信息</h3><p><strong>Lua脚本跟单个Redis命令一样，都是单个原子操作</strong>。因为Redis一次只会执行一个命令，所以EVAL，EVALSHA这两个命令也会被当作单个命令来处理。<br>这有效的帮助我们消除了竞态条件，不过这就导致<em>已经对结构进行了修改的Lua脚本无法被中断</em>。<br>对于不执行写命令的脚本来说，在脚本允许事件超过lua-time-limit指定的时间之后，就可以执行SCRIPT KILL命令杀死正在运行的脚本。<br>但如果脚本已经对存储的数据进行了写入，杀死脚本就会带来数据不一致的问题，这时就只能直接用SHUTDOWN NOSAVE杀死服务器。</p>
<p>Lua脚本一个最显著的优势就是它减少了与服务器的通讯次数，这不仅减少了多次通信的时间开销，还避免了 WATCH/MULTI/EXEC 事务冲突。</p>
<p>在开始Lua脚本演示之前，先介绍一下Redis使用Lua脚本的基本格式<br><code>EVAL script numkeys key [key ...] arg [arg ...]</code><br>在宿主语言的Lua脚本代码中key和arg分别用KEYS和ARGV表示，需要注意的是，Lua中数组的下标从1开始。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">create_status</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> uid<span class="token punctuation">,</span> message<span class="token punctuation">,</span> <span class="token operator">**</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>
    args <span class="token operator">=</span> <span class="token punctuation">[</span>
        <span class="token string">'message'</span><span class="token punctuation">,</span> message<span class="token punctuation">,</span>
        <span class="token string">'posted'</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token string">'uid'</span><span class="token punctuation">,</span> uid<span class="token punctuation">,</span>
    <span class="token punctuation">]</span>
    <span class="token keyword">for</span> key<span class="token punctuation">,</span> value <span class="token keyword">in</span> data<span class="token punctuation">.</span>iteritems<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        args<span class="token punctuation">.</span>append<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
        args<span class="token punctuation">.</span>append<span class="token punctuation">(</span>value<span class="token punctuation">)</span>

    <span class="token keyword">return</span> create_status_lua<span class="token punctuation">(</span>
        conn<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'user:%s'</span><span class="token operator">%</span>uid<span class="token punctuation">,</span> <span class="token string">'status:id:'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> args
    <span class="token punctuation">)</span>

create_status_lua <span class="token operator">=</span> script_load<span class="token punctuation">(</span><span class="token triple-quoted-string string">'''
local login = redis.call('hget', KEYS[1], 'login')
if not login then
    return false
end
local id = redis.call('incr', KEYS[2])
local key = string.format('status:%s', id)
redis.call('hmset', key,
    'login', login,
    'id', id,
    unpack(ARGV))
redis.call('hincrby', KEYS[1], 'posts', 1)
return id
)
'''</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>以上就是用Lua脚本执行创建状态信息命令的表示，我们主要将它拆分成两部分，第一部分负责组装Lua脚本需要的参数，第二部分是Lua脚本本身。</p>
<h3 id="重写锁实现"><a href="#重写锁实现" class="headerlink" title="重写锁实现"></a>重写锁实现</h3><h4 id="Lua实现脚本的原因"><a href="#Lua实现脚本的原因" class="headerlink" title="Lua实现脚本的原因"></a>Lua实现脚本的原因</h4><ol>
<li>在EVAL命令或EVALSHA命令执行Lua脚本时，跟在脚本或SHA1校验和之后的第一组参数就是Lua脚本需要读取或者写入的键。这样做的主要目的是让集群可以拒绝那些尝试在指定分片上，对不可用的键进行读取或写入的脚本。如果事先不知道哪些键会被读取和写入，就应该使用WATCH/MULTI/EXEC</li>
<li>在处理Redis存储的数据时，程序可能会需要一些数据，而这些数据无法在最开始的调用中获取。如果在在读取时不进行一定的限制，可能会导致服务器对数据库进行许多多余的访问，造成性能下降，甚至新数据被旧数据覆盖。</li>
</ol>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">acquire_lock_with_timeout</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> lockname<span class="token punctuation">,</span> acquire_timeout<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span> lock_timeout<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    identifier <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">(</span>uuid<span class="token punctuation">.</span>uuid4<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    lockname <span class="token operator">=</span> <span class="token string">'lock:'</span> <span class="token operator">+</span> lockname
    lock_timeout <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span>ceil<span class="token punctuation">(</span>lock_timeout<span class="token punctuation">)</span><span class="token punctuation">)</span>

    acquired <span class="token operator">=</span> <span class="token boolean">False</span>
    end <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> acquire_timeout
    <span class="token keyword">while</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> end <span class="token keyword">and</span> <span class="token keyword">not</span> acquired<span class="token punctuation">:</span>
        <span class="token comment"># 执行实际的锁获取操作，确保Lua调用已经执行成功</span>
        acquired <span class="token operator">=</span> acquire_lock_with_timeout_lua<span class="token punctuation">(</span>
            conn<span class="token punctuation">,</span> <span class="token punctuation">[</span>lockname<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>lock_timeout<span class="token punctuation">,</span> identifier<span class="token punctuation">]</span>
        <span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'OK'</span>
        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">.001</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">not</span> acquired<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> acquired <span class="token keyword">and</span> identifier

<span class="token comment"># 检测锁是否存在，然后用给定的ttl和标识符设置键</span>
acquire_lock_with_timeout_lua <span class="token operator">=</span> script_load<span class="token punctuation">(</span><span class="token triple-quoted-string string">'''
    if redis.call('exists', KEYS[1] == 0) then
        return redis.call('setex', KEYS[1], unpack(ARGV))
    end
'''</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="Lua实现计数信号量"><a href="#Lua实现计数信号量" class="headerlink" title="Lua实现计数信号量"></a>Lua实现计数信号量</h3><p>由于Lua版本的信号量获取操作都是在Redis内部完成，也就是说消除了系统时间不同的不公平，因为请求到来的时间统一按照Redis的内部时间计算，因此不再需要计数器以及信号量拥有者的集合。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">acquire_semaphore</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> semname<span class="token punctuation">,</span> limit<span class="token punctuation">,</span> timeout<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    now <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> acquire_semaphore_lua<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> <span class="token punctuation">[</span>semname<span class="token punctuation">]</span><span class="token punctuation">,</span>
        <span class="token punctuation">[</span>now <span class="token operator">-</span> timeout<span class="token punctuation">,</span> limit<span class="token punctuation">,</span> now<span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">(</span>uuid<span class="token punctuation">.</span>uuid4<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

acquire_semaphore_lua <span class="token operator">=</span> script_load<span class="token punctuation">(</span><span class="token triple-quoted-string string">'''
    redis.call('zremrangebyscore', KEYS[1], '-inf', ARGV[1])
    if redis.call('zcard', KEYS[1]) &lt; tonumber(ARGV[2]) then
        redis.call('zadd', KEYS[1], ARGV[3], ARGV[4])
        return ARGV[4]
    end
'''</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">refresh_semaphore</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> semname<span class="token punctuation">,</span> identifier<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> refresh_semaphore_lua<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> <span class="token punctuation">[</span>semname<span class="token punctuation">]</span><span class="token punctuation">,</span>
        <span class="token punctuation">[</span>identifier<span class="token punctuation">,</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token boolean">None</span>

refresh_semaphore_lua <span class="token operator">=</span> script_load<span class="token punctuation">(</span><span class="token triple-quoted-string string">'''
    if redis.call('zscore', KEYS[1], ARGV[1]) then
        return redis.call('zadd', KEYS[1], ARGV[2], ARGV[1]) or true
    end
'''</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="移除WATCH-x2F-MULTI-x2F-EXEC"><a href="#移除WATCH-x2F-MULTI-x2F-EXEC" class="headerlink" title="移除WATCH/MULTI/EXEC"></a>移除WATCH/MULTI/EXEC</h3><p>由于WATCH等命令使用的是乐观锁机制，因此在并发量很高的情况下，会导致错误出现的次数越来越频繁，产生大量重试。并且对这些异常的处理也会导致代码变得非常臃肿，下面将使用Lua脚本优化掉这些命令。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">autocomplete_on_prefix</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> guild<span class="token punctuation">,</span> prefix<span class="token punctuation">)</span><span class="token punctuation">:</span>
    start<span class="token punctuation">,</span> end <span class="token operator">=</span> auto_complete<span class="token punctuation">.</span>find_prefix_range<span class="token punctuation">(</span>prefix<span class="token punctuation">)</span>
    identifier <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">(</span>uuid<span class="token punctuation">.</span>uuid4<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    items <span class="token operator">=</span> autocomplete_on_prefix_lua<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> 
        <span class="token punctuation">[</span><span class="token string">'members:'</span> <span class="token operator">+</span> guild<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>start<span class="token operator">+</span>identifier<span class="token punctuation">,</span> end<span class="token operator">+</span>identifier<span class="token punctuation">]</span>
    <span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span>item <span class="token keyword">for</span> item <span class="token keyword">in</span> items <span class="token keyword">if</span> <span class="token string">'{'</span> <span class="token keyword">not</span> <span class="token keyword">in</span> item<span class="token punctuation">]</span>

autocomplete_on_prefix_lua <span class="token operator">=</span> script_load<span class="token punctuation">(</span><span class="token triple-quoted-string string">'''
redis.call('zadd', KEYS[1], 0, ARGV[1], 0, ARGV[2])
local sindex = redis.call('zrank', KEYS[1], ARGV[1])
local eindex = redis.call('zrank', KEYS[1], ARGV[2])
eindex = math.min(sindex + 9, eindex - 2)
redis.call('zrem', KEYS[1], unpack(ARGV))
return redis.call('zrange', KEYS[1], sindex, eindex)
'''</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用Lua脚本的程序减少了通信往返带来的额外开销，并且消除了事务竞争带来的WATCH错误。</p>
<h3 id="使用Lua对列表进行分片"><a href="#使用Lua对列表进行分片" class="headerlink" title="使用Lua对列表进行分片"></a>使用Lua对列表进行分片</h3><p>本节将创建一种分片列表表示，并使用它去降低长度较大的列表的内存占用。这个分片列表支持对列表两端进行推入操作，以及阻塞和非阻塞的弹出操作。<br>为了能够对分片列表的两端执行推入和弹出操作，程序在构建分片列表时除了需要存储组成列表的各个分片之外，还需要记录列表第一个分片的ID以及最后一个分片的ID。这里按照<code>&lt;listname&gt;:first</code>和<code>&lt;listname&gt;:last</code>的格式将内容存储到Redis字符串里。<br>除此之外，组成分片的每一个分片都会被命名为<code>&lt;listname&gt;:&lt;shardid&gt;</code>并按顺序进行分配。</p>
<h4 id="将元素推入分片列表"><a href="#将元素推入分片列表" class="headerlink" title="将元素推入分片列表"></a>将元素推入分片列表</h4><p>在将元素推入分片列表之前，程序需要将数据拆分成块以便进行发送。因为在程序向分片列表发送数据的时候，虽然可以直到列表的总容量，但并不清楚是否有客户端正在对列表进行阻塞弹出操作，因此用户在推入大量元素的时候，程序可能需要进行多次数据发送操作。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">shard_push_helper</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token operator">*</span>items<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
    items <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span>items<span class="token punctuation">)</span>
    total <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">while</span> items<span class="token punctuation">:</span>
        pushed <span class="token operator">=</span> sharded_push_lua<span class="token punctuation">(</span>conn<span class="token punctuation">,</span>
            <span class="token punctuation">[</span>key <span class="token operator">+</span> <span class="token string">':'</span><span class="token punctuation">,</span> key <span class="token operator">+</span> <span class="token string">':first'</span><span class="token punctuation">,</span> key <span class="token operator">+</span> <span class="token string">':last'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
            <span class="token punctuation">[</span>kwargs<span class="token punctuation">[</span><span class="token string">'cmd'</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> items<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        total <span class="token operator">+=</span> pushed
        <span class="token keyword">del</span> items<span class="token punctuation">[</span><span class="token punctuation">:</span>pushed<span class="token punctuation">]</span>
    <span class="token keyword">return</span> total

<span class="token keyword">def</span> <span class="token function">sharded_lpush</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token operator">*</span>items<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> shard_push_helper<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token operator">*</span>items<span class="token punctuation">,</span> cmd<span class="token operator">=</span><span class="token string">'lpush'</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">sharded_rpush</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token operator">*</span>items<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> shard_push_helper<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token operator">*</span>items<span class="token punctuation">,</span> cmd<span class="token operator">=</span><span class="token string">'rpush'</span><span class="token punctuation">)</span>

sharded_push_lua <span class="token operator">=</span> script_load<span class="token punctuation">(</span><span class="token triple-quoted-string string">'''
local max = tonumber(redis.call('config', 'get', 'list-max-ziplist-entries')[2])
if #ARGV &lt; 2 or max &lt; 2 then return 0 end
local skey = ARGV[1] == 'lpush' and KEYS[2] or KEYS[3]
local shard = redis.call('get', skey) or '0'
while 1 do
    local current = tonumber(redis.call('llen', KEYS[1]..shard))
    local topush = math.min(#ARGV - 1, max - current - 1)
    if topush &gt; 0 then
        redis.call(ARGV[1], KEYS[1]..shard, unpack(ARGV, 2, topush - 1))
        return topush
    end
    shard = redis.call(ARGV[1] == 'lpush' and 'decr' or 'incr', skey)
end
'''</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>以上就是将元素推入列表的实现，下面简单讲解一下Lua脚本所做的操作：</p>
<ol>
<li>首先检查每个列表分片的最大长度，如果没有元素需要推入，或压缩列表的最大长度太小，拒绝推入。</li>
<li>接下来根据要执行的命令获取分片列表的一端</li>
<li>在循环中先获取当前分片剩余的大小，在允许的情况下尽可能多的推入元素。此外在列表里保留一个节点的空间用来应对可能的阻塞弹出操作。</li>
<li>如果分片已经装满，修改该分片的首个/末尾分片的编号，将数据推入新的分片中。</li>
</ol>
<p>限制：由于这个分片列表的实现无法预知元素会被推入哪一个分片里，因此无法被应用到多台服务器。</p>
<h4 id="从分片中弹出元素"><a href="#从分片中弹出元素" class="headerlink" title="从分片中弹出元素"></a>从分片中弹出元素</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">sharded_lpop</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> sharded_list_pop_lua<span class="token punctuation">(</span>
        conn<span class="token punctuation">,</span> <span class="token punctuation">[</span>key<span class="token operator">+</span><span class="token string">':'</span><span class="token punctuation">,</span> key<span class="token operator">+</span><span class="token string">':first'</span><span class="token punctuation">,</span> key<span class="token operator">+</span><span class="token string">':last'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'lpop'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">sharded_rpop</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> sharded_list_pop_lua<span class="token punctuation">(</span>
        conn<span class="token punctuation">,</span> <span class="token punctuation">[</span>key<span class="token operator">+</span><span class="token string">':'</span><span class="token punctuation">,</span> key<span class="token operator">+</span><span class="token string">':first'</span><span class="token punctuation">,</span> key<span class="token operator">+</span><span class="token string">':last'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'rpop'</span><span class="token punctuation">]</span>
    <span class="token punctuation">)</span>

sharded_list_pop_lua <span class="token operator">=</span> script_load<span class="token punctuation">(</span><span class="token triple-quoted-string string">'''
local skey = ARGV[1] == 'lpop' and KEYS[2] or KEYS[3]
local okey = ARGV[1] ~= 'lpop' and KEYS[2] or KEYS[3]
local shard = redis.call('get', skey) or '0'

local ret = redis.call(ARGV[1], KEYS[1]..shard)
if not ret or redis.call('llen', KEYS[1]..shard) == '0' then
    local oshard = redis.call('get', okey) or '0'
    if shard == oshard then
        return ret
    end
    local cmd = ARGV[1] == 'lpop' and 'incr' or 'decr'
    shard = redis.call(cmd, skey)
    if not ret then
        ret = redis.call(ARGV[1], KEYS[1]..shard)
    end
end
return ret
'''</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>从分片中弹出元素的操作非常简单。程序需要找到位于列表一端的分片，然后在分片非空的情况下，从分片中弹出一个元素。如果列表在执行弹出操作之后不再包含任何元素，就对记录这列表端分片信息的字符串键进行修改。完成修改之后，如果当前列表中还有元素，就尝试从新的分片中弹出元素。</p>
<h4 id="对分片列表执行阻塞弹出操作"><a href="#对分片列表执行阻塞弹出操作" class="headerlink" title="对分片列表执行阻塞弹出操作"></a>对分片列表执行阻塞弹出操作</h4><p>因为Lua脚本和<code>WATCH/MULTI/EXEC</code>事务目前提供的语义和命令在某些情况下还是可能会产生不正确的数据，所以在不需要实际地阻塞客户端并且等待请求的情况下，程序应该尽可能地使用分片列表的非阻塞操作。<br>要想实现阻塞弹出需要使用到一些特殊操作。首先，程序会在一个给定的时限里面，尝试通过执行非阻塞弹出操作来获得元素。如果没有成功获得，那将在循环中执行几个指定的步骤直到获取到元素或超时。<br>在这一系列操作中，首先要执行的就是非阻塞弹出命令。如果未能弹出元素，就会获取第一个和最后一个分片ID，然后对指定端点尝试弹出。<br>由于通信往返的延迟，在程序获取分片列表端点之后，直到开始尝试弹出这段时间里，列表的端点可能已经发生了变化。为了解决这个问题，程序在执行阻塞弹出操作之前，会先发送一个被流水线包裹的<em>EVAL</em>脚本调用。这个脚本会检查程序是否在尝试从正确的列表里弹出元素，如果是的话不做任何操作，之后的阻塞弹出也会正常进行。但如果弹出操作针对的是错误的列表，就需要向那个列表推入一个额外的伪元素，这个元素会在之后被弹出操作弹出，告诉客户端分片端点发生变化。<br>尽管如此，仍存在一个潜在的竞态条件：如果一个客户端在Lua脚本执行之后，弹出操作之前向服务器执行了推入或弹出操作，就会导致程序得到不正确的数据。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">DUMMY <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">(</span>uuid<span class="token punctuation">.</span>uuid4<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">sharded_bpop_helper</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> key<span class="token punctuation">,</span> timeout<span class="token punctuation">,</span> pop<span class="token punctuation">,</span> bpop<span class="token punctuation">,</span> endp<span class="token punctuation">,</span> push<span class="token punctuation">)</span><span class="token punctuation">:</span>
    pipe <span class="token operator">=</span> conn<span class="token punctuation">.</span>pipeline<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>
    timeout <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>timeout<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">or</span> <span class="token number">2</span><span class="token operator">**</span><span class="token number">64</span>
    end <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> timeout

    <span class="token keyword">while</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> end<span class="token punctuation">:</span>
        result <span class="token operator">=</span> pop<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
        <span class="token keyword">if</span> result <span class="token keyword">not</span> <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">,</span> DUMMY<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> result

        shard <span class="token operator">=</span> conn<span class="token punctuation">.</span>get<span class="token punctuation">(</span>key <span class="token operator">+</span> endp<span class="token punctuation">)</span> <span class="token keyword">or</span> <span class="token string">'0'</span>
        sharded_bpop_helper_lua<span class="token punctuation">(</span>pipe<span class="token punctuation">,</span> <span class="token punctuation">[</span>key <span class="token operator">+</span> <span class="token string">':'</span><span class="token punctuation">,</span> key <span class="token operator">+</span> endp<span class="token punctuation">]</span><span class="token punctuation">,</span>
            <span class="token punctuation">[</span>shard<span class="token punctuation">,</span> push<span class="token punctuation">,</span> DUMMY<span class="token punctuation">]</span><span class="token punctuation">,</span> force_eval<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
        <span class="token builtin">getattr</span><span class="token punctuation">(</span>pipe<span class="token punctuation">,</span> bpop<span class="token punctuation">)</span><span class="token punctuation">(</span>key <span class="token operator">+</span> <span class="token string">':'</span> <span class="token operator">+</span> shard<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
        result <span class="token operator">=</span> <span class="token punctuation">(</span>pipe<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">or</span> <span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
        <span class="token keyword">if</span> result <span class="token keyword">not</span> <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">,</span> DUMMY<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> result

<span class="token keyword">def</span> <span class="token function">sharded_blpop</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> key<span class="token punctuation">,</span> timeout<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> sharded_bpop_helper<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> key<span class="token punctuation">,</span> timeout<span class="token punctuation">,</span> sharded_lpop<span class="token punctuation">,</span> <span class="token string">'blpop'</span><span class="token punctuation">,</span> <span class="token string">':first'</span><span class="token punctuation">,</span> <span class="token string">'lpush'</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">sharded_brpop</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> key<span class="token punctuation">,</span> timeout<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> sharded_bpop_helper<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> key<span class="token punctuation">,</span> timeout<span class="token punctuation">,</span> sharded_rpop<span class="token punctuation">,</span> <span class="token string">'brpop'</span><span class="token punctuation">,</span> <span class="token string">':last'</span><span class="token punctuation">,</span> <span class="token string">'rpush'</span><span class="token punctuation">)</span>

sharded_bpop_helper_lua <span class="token operator">=</span> script_load<span class="token punctuation">(</span><span class="token triple-quoted-string string">'''
local shard = redis.call('get', KEYS[2]) or '0'
if shard ~= ARGV[1] then
    redis.call(ARGV[2], KEYS[1]..ARGV[1], ARGV[3])
end
'''</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩是指，大量的key过期或Redis宕机导致大量请求到达数据库，使得数据库压力骤增。严重时可能会造成数据库宕机，甚至引发一系列连锁反应。</p>
<p><strong>解决措施</strong></p>
<ol>
<li><p>大量key过期</p>
<ul>
<li>均匀设置过期时间</li>
<li>互斥锁<br>业务线程处理用户请求时，如果发现数据不在缓存中，就加一个互斥锁，保证同一时间只有一个请求在构建缓存。当查询完毕时，将查询结果插入到Redis，其他请求就可以继续从缓存中获取数据。<ul>
<li>双key策略<br>互斥锁策略的缺点在于，如果构建缓存的线程长时间不释放锁，就会导致其余线程都被阻塞住。而双key策略则很好的解决了这个问题，对缓存数据可以使用两个key，一个主key设置过期时间，一个从key不设置过期时间。当线程发现主key过期了，就去从key获取数据。<br>这样的好处在于，即使缓存过期，服务端也可以做出快速响应。当主key过期时通知后台进程进行更新，不会阻塞其他请求。</li>
<li>后台更新缓存<br>缓存不再设置过期时间，由后台线程定时更新缓存。不过这么做的缺陷在于，Redis可能会因为系统资源紧张而淘汰一些key，此时对于客户端来说这些数据就好像消失了一样。<br>这种问题的解决方案是，当业务线程发现缓存失效后，就发送通知给后台进程，让他更新对应的key的缓存。</li>
</ul>
</li>
</ul>
</li>
<li><p>Redis宕机</p>
<ol>
<li>构建高可用Redis集群</li>
<li>服务熔断或请求限流</li>
</ol>
</li>
</ol>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿指的是<strong>热点数据</strong>的缓存过期，导致大量请求到达数据库。</p>
<p>处理方案和缓存雪崩类似，可以使用互斥锁策略或后台更新缓存策略</p>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透指的是，某个请求的目标既不存在于缓存中也不存在于数据库中，这就导致无法构建缓存。当有大量这种请求到来时，就会给数据库造成巨大压力。</p>
<p><strong>解决方案</strong></p>
<ol>
<li><p>非法请求的限制<br>入参校验，若判断出是恶意请求直接返回错误</p>
</li>
<li><p>缓存空值或默认值</p>
</li>
<li><p>使用布隆过滤器<br>在写入数据库时，使用布隆过滤器进行标记，当请求到来时通过布隆过滤器判断数据是否存在于数据库中，避免恶意请求到达数据库。</p>
</li>
</ol>
<blockquote>
<p>布隆过滤器<br>布隆过滤器包含两个部分：初始值都为0的位图数组，N个哈希函数。当要进行存储操作时，通过N个哈希函数计算出N个哈希值，并将这N个哈希值于位图数组长度取模，将位图对应位置置为1。<br>当查询数据时，计算N个哈希值，查看对应位是否都为1，成立则代表存在。<br>不过由于可能的哈希冲突，过滤器判断存在不代表一定存在，但判断不存在就代表一定不存在。</p>
</blockquote>
<h3 id="数据库和缓存一致性"><a href="#数据库和缓存一致性" class="headerlink" title="数据库和缓存一致性"></a>数据库和缓存一致性</h3><p>要保证数据库和缓存的一致性，最容易想到的方式就是更新数据库的同时更新缓存。但这种方式会有很严重的并发问题，如果线程A先更新了数据库，然后线程B更新了数据库与缓存，最后线程A更新了缓存。这就会导致数据库与缓存不一致。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/20230126115012.png" alt="先更新数据库，再更新缓存"></p>
<p>先更新缓存再更新数据库也会有一样的问题</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/20230126115051.png" alt="先更新缓存，再更新数据库"></p>
<p>为了解决同时更新带来的并发问题，我们需要采取Cache-Aside策略</p>
<p>也就是当数据库更新时，将缓存删除，读取时再重新构建缓存。</p>
<p>不过这种策略也同样有点问题，如果先删除缓存再更新数据库，仍可能出现不一致。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/20230126115612.png" alt="先删除缓存，再更新数据库"></p>
<p>先更新数据库再删除缓存也有可能出现不一致，不过这种情况出现的概率非常低。因为缓存的操作远比数据库快，后来的请求不太可能在先到的更新请求的数据库更新与缓存清除操作间完成所有任务。</p>
<p>综上所述，最好的方式是先更新数据库再删除缓存。而为了万无一失，最好还是给缓存key设置一个过期时间。</p>
<p>不过即使采用了上述所有策略，仍有可能会出现bug，一旦缓存删除失败就会导致旧数据暴露给用户。</p>
<p>究其原因是我们保证两个操作的原子性。这有以下两种解决方案：</p>
<ol>
<li><p>重试机制<br> 将缓存删除操作存储到消息队列中，由消费者读取数据并重试删除操作</p>
</li>
<li><p>订阅MySQL binlog<br>通过类似Canal的中间件订阅MySQL的binlog，获取具体需要的操作，然后再执行缓存删除</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/20230126120926.png" alt="Canal工作流程"></p>
</li>
</ol>

        </div>

        
            <div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
                <div class="article-copyright-info-container">
    <ul>
        <li><strong>标题:</strong> Redis入门</li>
        <li><strong>作者:</strong> Zephyr</li>
        <li><strong>创建于
                :</strong> 2023-01-25 11:01:27</li>
        
            <li>
                <strong>更新于
                    :</strong> 2023-03-11 14:50:03
            </li>
        
        <li>
            <strong>链接:</strong> https://faustpromaxpx.github.io/2023/01/25/redis/
        </li>
        <li>
            <strong>
                版权声明:
            </strong>
            

            
                本文章采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a> 进行许可。
            
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
                
                    <li class="tag-item mx-0.5">
                        <a href="/tags/redis/">#redis</a>&nbsp;
                    </li>
                
                    <li class="tag-item mx-0.5">
                        <a href="/tags/python/">#python</a>&nbsp;
                    </li>
                
                    <li class="tag-item mx-0.5">
                        <a href="/tags/%E7%BC%93%E5%AD%98/">#缓存</a>&nbsp;
                    </li>
                
            </ul>
        

        

        
            <div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
                
                    <div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
                        <a class="prev"
                        rel="prev"
                        href="/2023/02/07/os/"
                        >
                            <span class="left arrow-icon flex justify-center items-center">
                                <i class="fa-solid fa-chevron-left"></i>
                            </span>
                            <span class="title flex justify-center items-center">
                                <span class="post-nav-title-item">操作系统</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
                        <a class="next"
                        rel="next"
                        href="/2022/10/09/network/"
                        >
                            <span class="title flex justify-center items-center">
                                <span class="post-nav-title-item">计算机网络</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex justify-center items-center">
                                <i class="fa-solid fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        


        
            <div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
                <div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        评论
    </div>
    

        
            
    <div id="waline"></div>
    <script type="module" data-swup-reload-script>
      import { init } from '/js/libs/waline.mjs';

      function loadWaline() {
        init({
          el: '#waline',
          serverURL: 'https://example.example.com',
          lang: 'zh-CN',
          dark: 'body[class~="dark-mode"]',
          requiredMeta: ['nick', 'mail'],
          emoji: [],
          recaptchaV3Key: "wasd",
          
        });
      }

      if (typeof swup !== 'undefined') {
        loadWaline();
      } else {
        window.addEventListener('DOMContentLoaded', loadWaline);
      }
    </script>



        
    
</div>

            </div>
        
    </div>

    
        <div class="toc-content-container">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">此页目录</div>
        <div class="page-title">Redis入门</div>
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E5%9C%A8Web%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-text">Redis在Web中的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E7%90%86%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E4%BC%9A%E8%AF%9D"><span class="nav-text">管理用户登录会话</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AD%E7%89%A9%E8%BD%A6%E5%8A%9F%E8%83%BD"><span class="nav-text">购物车功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E9%A1%B5%E7%BC%93%E5%AD%98"><span class="nav-text">网页缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E8%A1%8C%E7%BC%93%E5%AD%98"><span class="nav-text">数据行缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E9%A1%B5%E5%88%86%E6%9E%90"><span class="nav-text">网页分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E5%91%BD%E4%BB%A4"><span class="nav-text">Redis命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%97%E8%A1%A8"><span class="nav-text">列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-text">集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%A3%E5%88%97"><span class="nav-text">散列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88"><span class="nav-text">有序集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85"><span class="nav-text">发布与订阅</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E5%91%BD%E4%BB%A4"><span class="nav-text">排序命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E4%BA%8B%E5%8A%A1"><span class="nav-text">基本事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%AE%E7%9A%84%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="nav-text">键的过期时间</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-text">Redis线程模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BF%9D%E9%9A%9C"><span class="nav-text">数据安全与性能保障</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E9%80%89%E9%A1%B9"><span class="nav-text">持久化选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E7%85%A7"><span class="nav-text">快照</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF"><span class="nav-text">AOF</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6"><span class="nav-text">复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F%E6%95%85%E9%9A%9C"><span class="nav-text">处理系统故障</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%A8%E5%85%B5"><span class="nav-text">哨兵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1"><span class="nav-text">事务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E6%94%AF%E6%8C%81%E7%A8%8B%E5%BA%8F"><span class="nav-text">构建支持程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95"><span class="nav-text">日志记录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8Redis%E4%B8%AD%E5%AD%98%E5%82%A8%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-text">在Redis中存储计数器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE"><span class="nav-text">存储统计数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E6%89%BEIP%E5%B1%9E%E5%9C%B0%E4%BB%A5%E5%8F%8A%E5%9B%BD%E5%AE%B6"><span class="nav-text">查找IP属地以及国家</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%BB%84%E4%BB%B6"><span class="nav-text">构建应用程序组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8"><span class="nav-text">自动补全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-text">分布式锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E6%95%B0%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-text">计数信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97"><span class="nav-text">任务队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E6%8B%89%E5%8F%96"><span class="nav-text">消息拉取</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%90%9C%E7%B4%A2%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="nav-text">基于搜索的应用程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Redis%E8%BF%9B%E8%A1%8C%E6%90%9C%E7%B4%A2"><span class="nav-text">使用Redis进行搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%8C%E4%BD%8D%E6%90%9C%E7%B4%A2"><span class="nav-text">职位搜索</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E7%AE%80%E5%8D%95%E7%9A%84%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%AB%99"><span class="nav-text">构建简单的社交网站</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E5%92%8C%E7%8A%B6%E6%80%81"><span class="nav-text">用户和状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E9%A1%B5%E6%97%B6%E9%97%B4%E7%BA%BF"><span class="nav-text">主页时间线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E4%BF%A1%E6%81%AF%E7%9A%84%E5%8F%91%E5%B8%83%E4%B8%8E%E5%88%A0%E9%99%A4"><span class="nav-text">状态信息的发布与删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81API"><span class="nav-text">流API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%8D%E4%BD%8E%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8"><span class="nav-text">降低内存占用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%AD%E7%BB%93%E6%9E%84"><span class="nav-text">短结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%89%87%E7%BB%93%E6%9E%84"><span class="nav-text">分片结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A9%E5%B1%95Redis"><span class="nav-text">扩展Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E8%AF%BB%E6%80%A7%E8%83%BD"><span class="nav-text">扩展读性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E5%86%99%E6%80%A7%E8%83%BD"><span class="nav-text">扩展写性能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E7%9A%84Lua%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B"><span class="nav-text">Redis的Lua脚本编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86Lua%E8%84%9A%E6%9C%AC%E8%BD%BD%E5%85%A5Redis"><span class="nav-text">将Lua脚本载入Redis</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E7%8A%B6%E6%80%81%E4%BF%A1%E6%81%AF"><span class="nav-text">创建新的状态信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E9%94%81%E5%AE%9E%E7%8E%B0"><span class="nav-text">重写锁实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lua%E5%AE%9E%E7%8E%B0%E8%AE%A1%E6%95%B0%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-text">Lua实现计数信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%BB%E9%99%A4WATCH-x2F-MULTI-x2F-EXEC"><span class="nav-text">移除WATCH&#x2F;MULTI&#x2F;EXEC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Lua%E5%AF%B9%E5%88%97%E8%A1%A8%E8%BF%9B%E8%A1%8C%E5%88%86%E7%89%87"><span class="nav-text">使用Lua对列表进行分片</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98"><span class="nav-text">缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="nav-text">缓存雪崩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="nav-text">缓存击穿</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="nav-text">缓存穿透</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-text">数据库和缓存一致性</span></a></li></ol></li></ol>

    </div>
</div>
        </div>
    
</div>



                

            </div>

            

        </div>

        <div class="main-content-footer">
            <footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2024</span>
              -
            
            2024&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">Zephyr</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        共 24 篇文章
                    </span>
                    
                        <span>
                            共 224.2k 字
                        </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">访问人数</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">总访问量</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a> 驱动</span>
            <span class="text-sm lg:block">主题&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.6.1</a></span>
        </div>
        
        
            <div>
                博客已运行 <span class="odometer" id="runtime_days" ></span> 天 <span class="odometer" id="runtime_hours"></span> 小时 <span class="odometer" id="runtime_minutes"></span> 分钟 <span class="odometer" id="runtime_seconds"></span> 秒
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="article-tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fa-regular fa-comments"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-side-tools-container">
        <div class="side-tools-container">
    <ul class="hidden-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="visible-tools-list">
        <li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
            <li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fa-solid fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fa-solid fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>


    
<script src="/js/libs/Swup.min.js"></script>

<script src="/js/libs/SwupSlideTheme.min.js"></script>

<script src="/js/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>







<script src="/js/tools/imageViewer.js" type="module"></script>

<script src="/js/utils.js" type="module"></script>

<script src="/js/main.js" type="module"></script>

<script src="/js/layouts/navbarShrink.js" type="module"></script>

<script src="/js/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/layouts/categoryList.js" type="module"></script>



    
<script src="/js/tools/localSearch.js" type="module"></script>




    
<script src="/js/tools/codeBlock.js" type="module"></script>




    
<script src="/js/layouts/lazyload.js" type="module"></script>




    
<script src="/js/tools/runtime.js"></script>

    
<script src="/js/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/libs/Typed.min.js"></script>

  
<script src="/js/plugins/typed.js" type="module"></script>









<div class="post-scripts" data-swup-reload-script>
    
        
<script src="/js/tools/tocToggle.js" type="module"></script>

<script src="/js/layouts/toc.js" type="module"></script>

<script src="/js/plugins/tabs.js" type="module"></script>

    
</div>


</body>
</html>
