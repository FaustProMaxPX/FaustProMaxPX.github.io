<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>rookie db</title>
      <link href="/2022/07/05/rookie-db/"/>
      <url>/2022/07/05/rookie-db/</url>
      
        <content type="html"><![CDATA[<h1 id="Rookie-DB-实现"><a href="#Rookie-DB-实现" class="headerlink" title="Rookie DB 实现"></a>Rookie DB 实现</h1><p>cs186 project实现</p><span id="more"></span><h2 id="Joins-and-Query-Optimization"><a href="#Joins-and-Query-Optimization" class="headerlink" title="Joins and Query Optimization"></a>Joins and Query Optimization</h2><h3 id="Join-Algorithm"><a href="#Join-Algorithm" class="headerlink" title="Join Algorithm"></a>Join Algorithm</h3><h4 id="task-1：BNLJ"><a href="#task-1：BNLJ" class="headerlink" title="task 1：BNLJ"></a>task 1：BNLJ</h4><p>本阶段要实现的方法 <code>fetchNextRecord</code>, <code>fetchNextLeftBlock</code>, <code>fetchNextRightBlock</code></p><p>获取左表下一部分数据块</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">fetchNextLeftBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 左表遍历完毕，退出</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>leftSourceIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> limit <span class="token operator">=</span> numBuffers <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>leftBlockIterator <span class="token operator">=</span> <span class="token function">getBlockIterator</span><span class="token punctuation">(</span>leftSourceIterator<span class="token punctuation">,</span> <span class="token function">getLeftSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getSchema</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> limit<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>leftBlockIterator<span class="token punctuation">.</span><span class="token function">markNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    leftRecord <span class="token operator">=</span> leftBlockIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>左表可用缓冲大小为总缓冲数 - 2，每次获取新的数据块迭代器，都要标记其中的第一个数据，用于之后的回溯。</p><p>获取右表的下一部分数据</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">fetchNextRightPage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rightSourceIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>rightPageIterator <span class="token operator">=</span> <span class="token function">getBlockIterator</span><span class="token punctuation">(</span>rightSourceIterator<span class="token punctuation">,</span> <span class="token function">getRightSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getSchema</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>rightPageIterator<span class="token punctuation">.</span><span class="token function">markNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>使用的缓冲大小为1，即每次只读取被驱动表的一页数据到内存进行匹配，同样地，获取到的迭代器也要进行标记。</p><p>获取下一跳满足条件的记录</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Record <span class="token function">fetchNextRecord</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rightPageIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            Record rightRecord <span class="token operator">=</span> rightPageIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compare</span><span class="token punctuation">(</span>leftRecord<span class="token punctuation">,</span> rightRecord<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> leftRecord<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>rightRecord<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>leftBlockIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            leftRecord <span class="token operator">=</span> leftBlockIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            rightPageIterator<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            rightPageIterator<span class="token punctuation">.</span><span class="token function">markNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rightSourceIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token function">fetchNextRightPage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            leftBlockIterator<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            leftBlockIterator<span class="token punctuation">.</span><span class="token function">markNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            leftRecord <span class="token operator">=</span> leftBlockIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>leftSourceIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token function">fetchNextLeftBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            rightSourceIterator<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            rightSourceIterator<span class="token punctuation">.</span><span class="token function">markNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">fetchNextRightPage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>总共有四种情况</p><p>约定： L为驱动表， R为被驱动表</p><p>case 1：right page迭代器还有值可用，表明R在内存中的内容还没有完全被探索完毕。此时继续获取迭代器中的值，并进行匹配。</p><p>case 2：R的页迭代器被耗尽，但L的块迭代器还有值，代表L当前记录已经探索完了R在内存中的记录，此时需要获取L的下一条记录，并重置R的页迭代器。</p><p>case 3：L的块迭代器耗尽，但R的源迭代器还有值，代表L放在内存中的数据已经探索完了R在内存中的记录，此时要获取新的R的数据页，并将L的块迭代器重置，开始新一轮匹配。</p><p>case 4：R的源迭代器耗尽，L的源迭代器还有值，代表L在内存中的记录已经探索完了整张R，此时获取L新的数据块，并重置R的源迭代器，开始新一轮匹配。</p><p>当L的迭代器耗尽时，匹配完毕。</p><p>错误示范：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Record <span class="token function">fetchNextRecord</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>leftRecord <span class="token operator">!=</span> null <span class="token operator">||</span> leftSourceIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 左表数据块迭代器与右表所有的页迭代器的循环</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>rightSourceIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> rightPageIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 针对某一块左表记录的循环</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>leftRecord <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 针对某一左表记录的循环</span>                <span class="token comment" spellcheck="true">// 扫描右表当前页的记录，寻找匹配</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>rightPageIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    Record rightRecord <span class="token operator">=</span> rightPageIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>leftRecord<span class="token punctuation">,</span> rightRecord<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                        <span class="token keyword">return</span> leftRecord<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>rightRecord<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 换到下一个左表记录</span>                leftRecord <span class="token operator">=</span> leftBlockIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> leftBlockIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> null<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 重置右表迭代器</span>                rightPageIterator<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                rightPageIterator<span class="token punctuation">.</span><span class="token function">markNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 重置左表迭代器</span>            leftBlockIterator<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            leftBlockIterator<span class="token punctuation">.</span><span class="token function">markNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            leftRecord <span class="token operator">=</span> leftBlockIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> leftBlockIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> null<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 获取新的右表迭代器</span>            <span class="token function">fetchNextRightPage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取新的左表块迭代器</span>        <span class="token function">fetchNextLeftBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 重置整个右表迭代器</span>        rightSourceIterator<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        rightSourceIterator<span class="token punctuation">.</span><span class="token function">markNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 重新获取右表迭代器</span>        <span class="token function">fetchNextRightPage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>上方的写法看上去差不多，但是如果被驱动表被读取完毕，而驱动表块迭代器没有迭代完，就会直接去fetch下一个驱动表块迭代器<br>其判断逻辑为：先看驱动表有没有剩余数据，再看被驱动表有无剩余数据，然后检查驱动表块有无剩余数据，最后匹配，与题目要求恰好相反。因为被驱动表必定会先被读完，因此每块只有第一个数据能完整探索被驱动表</p><h4 id="task-2：GHJ"><a href="#task-2：GHJ" class="headerlink" title="task 2：GHJ"></a>task 2：GHJ</h4><p>本阶段要实现<code>partition</code>, <code>buildAndProbe</code>, <code>run</code>以及思考SHJ与GHJ失效的可能情况。</p><p>分区实现</p><p>比较简单，根据记录参与join的字段以及当前分区的轮次生成对应的哈希值，在哈希对应的分区下添加记录。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">partition</span><span class="token punctuation">(</span>Partition<span class="token punctuation">[</span><span class="token punctuation">]</span> partitions<span class="token punctuation">,</span> Iterable<span class="token operator">&lt;</span>Record<span class="token operator">></span> records<span class="token punctuation">,</span> <span class="token keyword">boolean</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> pass<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Record record <span class="token operator">:</span> records<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> columnIndex <span class="token operator">=</span> left <span class="token operator">?</span> <span class="token function">getLeftColumnIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">getRightColumnIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        DataBox columnValue <span class="token operator">=</span> record<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span>columnIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> hash <span class="token operator">=</span> HashFunc<span class="token punctuation">.</span><span class="token function">hashDataBox</span><span class="token punctuation">(</span>columnValue<span class="token punctuation">,</span> pass<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> hash <span class="token operator">%</span> partitions<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            index <span class="token operator">+=</span> partitions<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        partitions<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>record<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>左右分区的连接实现</p><p>首先选择驱动表，只有当左右分区中有一个分区的数据页数小于缓冲区数-2（剩下两个缓冲区，一个用于输入被驱动表，一个输出结果），该方法才能进行。</p><p>然后将驱动表的数据哈希过后写入哈希表中。然后从被驱动表中读取数据，探索整张哈希表进行匹配。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">buildAndProbe</span><span class="token punctuation">(</span>Partition leftPartition<span class="token punctuation">,</span> Partition rightPartition<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// true if the probe records come from the left partition, false otherwise</span>    <span class="token keyword">boolean</span> probeFirst<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// We'll build our in memory hash table with these records</span>    Iterable<span class="token operator">&lt;</span>Record<span class="token operator">></span> buildRecords<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// We'll probe the table with these records</span>    Iterable<span class="token operator">&lt;</span>Record<span class="token operator">></span> probeRecords<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// The index of the join column for the build records</span>    <span class="token keyword">int</span> buildColumnIndex<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// The index of the join column for the probe records</span>    <span class="token keyword">int</span> probeColumnIndex<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>leftPartition<span class="token punctuation">.</span><span class="token function">getNumPages</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>numBuffers <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        buildRecords <span class="token operator">=</span> leftPartition<span class="token punctuation">;</span>        buildColumnIndex <span class="token operator">=</span> <span class="token function">getLeftColumnIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        probeRecords <span class="token operator">=</span> rightPartition<span class="token punctuation">;</span>        probeColumnIndex <span class="token operator">=</span> <span class="token function">getRightColumnIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        probeFirst <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rightPartition<span class="token punctuation">.</span><span class="token function">getNumPages</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>numBuffers <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        buildRecords <span class="token operator">=</span> rightPartition<span class="token punctuation">;</span>        buildColumnIndex <span class="token operator">=</span> <span class="token function">getRightColumnIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        probeRecords <span class="token operator">=</span> leftPartition<span class="token punctuation">;</span>        probeColumnIndex <span class="token operator">=</span> <span class="token function">getLeftColumnIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        probeFirst <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span>        <span class="token string">"Neither the left nor the right records in this partition "</span> <span class="token operator">+</span>        <span class="token string">"fit in B-2 pages of memory."</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    Map<span class="token operator">&lt;</span>DataBox<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Record<span class="token operator">>></span> hashTable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Record buildRecord <span class="token operator">:</span> buildRecords<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        DataBox buildJoinValue <span class="token operator">=</span> buildRecord<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span>buildColumnIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>hashTable<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>buildJoinValue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            hashTable<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>buildJoinValue<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        hashTable<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>buildJoinValue<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>buildRecord<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Record probeRecord <span class="token operator">:</span> probeRecords<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        DataBox probeJoinValue <span class="token operator">=</span> probeRecord<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span>probeColumnIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>hashTable<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>probeJoinValue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Record<span class="token operator">></span> matchRecords <span class="token operator">=</span> hashTable<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>probeJoinValue<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Record matchRecord <span class="token operator">:</span> matchRecords<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            Record record<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>probeFirst<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                record <span class="token operator">=</span> matchRecord<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>probeRecord<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                record <span class="token operator">=</span> probeRecord<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>matchRecord<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>joinedRecords<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>record<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>运行实现</p><p>首先获取左右表的分区，在遍历分区时，两张表共用下标索引（分区使用的是同一个哈希函数，如果左右表分区数不一致，那可以直接判断不一致的分区必然不存在匹配，因此不必考虑）。</p><p>如果两个分区有任意一个满足探索条件，即可调用对应方法，否则递归调用run，将这两个分区进行进一步的划分然后连接。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span>Iterable<span class="token operator">&lt;</span>Record<span class="token operator">></span> leftRecords<span class="token punctuation">,</span> Iterable<span class="token operator">&lt;</span>Record<span class="token operator">></span> rightRecords<span class="token punctuation">,</span> <span class="token keyword">int</span> pass<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">assert</span> pass <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pass <span class="token operator">></span> <span class="token number">5</span><span class="token punctuation">)</span>         <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"Reached the max number of passes"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Create empty partitions</span>    Partition<span class="token punctuation">[</span><span class="token punctuation">]</span> leftPartitions <span class="token operator">=</span> <span class="token function">createPartitions</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Partition<span class="token punctuation">[</span><span class="token punctuation">]</span> rightPartitions <span class="token operator">=</span> <span class="token function">createPartitions</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Partition records into left and right</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">partition</span><span class="token punctuation">(</span>leftPartitions<span class="token punctuation">,</span> leftRecords<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> pass<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">partition</span><span class="token punctuation">(</span>rightPartitions<span class="token punctuation">,</span> rightRecords<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> pass<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> leftPartitions<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        Partition leftPartition <span class="token operator">=</span> leftPartitions<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        Partition rightPartition <span class="token operator">=</span> rightPartitions<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> limit <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>numBuffers <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>leftPartition<span class="token punctuation">.</span><span class="token function">getNumPages</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> limit <span class="token operator">||</span> rightPartition<span class="token punctuation">.</span><span class="token function">getNumPages</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> limit<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token function">buildAndProbe</span><span class="token punctuation">(</span>leftPartition<span class="token punctuation">,</span> rightPartition<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token function">run</span><span class="token punctuation">(</span>leftPartition<span class="token punctuation">,</span> rightPartition<span class="token punctuation">,</span> pass <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>在有SHJ参照的情况下GHJ的实现可以说相当简单。</p><blockquote><p>SHJ失效，GHJ保持有效的情况</p></blockquote><p>SHJ在驱动表的分区大小大于B-2时会失效，因此只要驱动表中有足够多的冗余数据，便可使其失效。</p><p>但由于GHJ要保持有效，因此pass不能过深，保持被驱动表的大小满足条件即可。</p><p>由题知，缓冲区大小为6，每个数据页存储8个数据，因此只需要往一个分区中填入(6-2)*8+1&#x3D;33个数据即可</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Pair<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Record<span class="token operator">></span><span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Record<span class="token operator">>></span> <span class="token function">getBreakSHJInputs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    ArrayList<span class="token operator">&lt;</span>Record<span class="token operator">></span> leftRecords <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ArrayList<span class="token operator">&lt;</span>Record<span class="token operator">></span> rightRecords <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">33</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        leftRecords<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">createRecord</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// GHJ只要有一张表的分区数据页小于B-2就不会加深pass</span>    <span class="token comment" spellcheck="true">// 因此这里在右表只放1个数据，确保不需要多次递归</span>    rightRecords<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">createRecord</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>leftRecords<span class="token punctuation">,</span> rightRecords<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><blockquote><p>GHJ失效</p></blockquote><p>GHJ的生效条件是两个分区中有一个满足条件，且pass不能过大，因此让其失效只要破坏这两个条件即可。在本题中，只需让被驱动表也不满足探索条件，且有大量冗余数据即可完成。</p><p>因为冗余数据会带来不断的无效分区，导致pass数急速上升。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Pair<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Record<span class="token operator">></span><span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Record<span class="token operator">>></span> <span class="token function">getBreakGHJInputs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    ArrayList<span class="token operator">&lt;</span>Record<span class="token operator">></span> leftRecords <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ArrayList<span class="token operator">&lt;</span>Record<span class="token operator">></span> rightRecords <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 首先同样要让表数据页大小超过缓冲区数-2</span>    <span class="token comment" spellcheck="true">// 但在本题中，但要让GHJ提高pass，必须让两张表都满足上述条件</span>    <span class="token comment" spellcheck="true">// 而对于GHJ来说，如果表中均为冗余数据，则会不断造成无效分区，pass急速增加</span>    <span class="token comment" spellcheck="true">// 因此，在两表中添加大量冗余数据即可达成目标。</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">33</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        leftRecords<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">createRecord</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        rightRecords<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">createRecord</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>leftRecords<span class="token punctuation">,</span> rightRecords<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h4 id="task-3：External-Sort"><a href="#task-3：External-Sort" class="headerlink" title="task 3：External Sort"></a>task 3：External Sort</h4><p>本题中要实现<code>sortRun</code>, <code>mergeSortedRuns</code>, <code>mergePass</code>, and <code>sort</code></p><p>sortRun</p><p>pass0的操作，将排序段内的数据排序，实现很简单。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Run <span class="token function">sortRun</span><span class="token punctuation">(</span>Iterator<span class="token operator">&lt;</span>Record<span class="token operator">></span> records<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>Record<span class="token operator">></span> recordList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>records<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        recordList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>records<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    recordList<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>comparator<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">makeRun</span><span class="token punctuation">(</span>recordList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>mergeSortedRuns</p><p>对一系列有序的排序段做归并操作</p><p>此处使用优先队列来提取要进入输出排序段的记录，同时在优先队列中，每条记录以&lt;Record, Integer&gt;的形式存储，整型数追踪该记录来源的排序段，每当一个记录被送到输出段，就从该记录来源的排序段再提取一个记录放入队列。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Run <span class="token function">mergeSortedRuns</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Run<span class="token operator">></span> runs<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">assert</span> <span class="token punctuation">(</span>runs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>numBuffers <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// TODO(proj3_part/1): implement</span>    PriorityQueue<span class="token operator">&lt;</span>Pair<span class="token operator">&lt;</span>Record<span class="token punctuation">,</span> Integer<span class="token operator">>></span> pq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RecordPairComparat</span>    List<span class="token operator">&lt;</span>Iterator<span class="token operator">&lt;</span>Record<span class="token operator">>></span> iterators <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 先获取每一个排序段的迭代器</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Run run <span class="token operator">:</span> runs<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        iterators<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>run<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取每个排序段中的最小元素，并将其填入优先队列</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Iterator<span class="token operator">&lt;</span>Record<span class="token operator">></span> iterator <span class="token operator">:</span> iterators<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            pq<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>Record<span class="token operator">></span> output <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>pq<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        Pair<span class="token operator">&lt;</span>Record<span class="token punctuation">,</span> Integer<span class="token operator">></span> pair <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Record record <span class="token operator">=</span> pair<span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        output<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>record<span class="token punctuation">)</span><span class="token punctuation">;</span>        Iterator<span class="token operator">&lt;</span>Record<span class="token operator">></span> it <span class="token operator">=</span> iterators<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>pair<span class="token punctuation">.</span><span class="token function">getSecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            pq<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> pair<span class="token punctuation">.</span><span class="token function">getSecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">makeRun</span><span class="token punctuation">(</span>output<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>mergePass</p><p>一轮pass要做的归并操作，将排序段B-1个一组进行归并，生成一个新的有序排序段</p><p>主要工作为计算归并次数并给排序段分组，实现也很简单。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> List<span class="token operator">&lt;</span>Run<span class="token operator">></span> <span class="token function">mergePass</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Run<span class="token operator">></span> runs<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>Run<span class="token operator">></span> output <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 每次归并都有n-1个缓冲区用于输入，1个缓冲区用于输出</span>    <span class="token keyword">int</span> runsNum <span class="token operator">=</span> numBuffers <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 计算归并次数</span>    <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> Math<span class="token punctuation">.</span><span class="token function">ceil</span><span class="token punctuation">(</span>runs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> runsNum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 划分出与缓冲区大小相同的run</span>        List<span class="token operator">&lt;</span>Run<span class="token operator">></span> curRuns<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> runsNum <span class="token operator">></span> runs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            curRuns <span class="token operator">=</span> runs<span class="token punctuation">.</span><span class="token function">subList</span><span class="token punctuation">(</span>i <span class="token operator">*</span> runsNum<span class="token punctuation">,</span> runs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            curRuns <span class="token operator">=</span> runs<span class="token punctuation">.</span><span class="token function">subList</span><span class="token punctuation">(</span>i <span class="token operator">*</span> runsNum<span class="token punctuation">,</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> runsNum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 调用归并有序排序段方法</span>        Run out <span class="token operator">=</span> <span class="token function">mergeSortedRuns</span><span class="token punctuation">(</span>curRuns<span class="token punctuation">)</span><span class="token punctuation">;</span>        output<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> output<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>sort</p><p>外部排序的驱动方法，只需要先按缓冲区大小划分出排序段，然后为每个排序段排序(调用sortRun)，再不断归并，直到只剩下一个排序段。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Run <span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Iterator over the records of the relation we want to sort</span>    Iterator<span class="token operator">&lt;</span>Record<span class="token operator">></span> sourceIterator <span class="token operator">=</span> <span class="token function">getSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>Iterator<span class="token operator">&lt;</span>Record<span class="token operator">>></span> initialStates <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>sourceIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将程序划分为若干个排序段，每一个排序段的大小与缓冲区一致</span>        BacktrackingIterator<span class="token operator">&lt;</span>Record<span class="token operator">></span> it <span class="token operator">=</span> <span class="token function">getBlockIterator</span><span class="token punctuation">(</span>sourceI        initialStates<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>Run<span class="token operator">></span> runs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 对每一个排序段进行排序</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Iterator<span class="token operator">&lt;</span>Record<span class="token operator">></span> state <span class="token operator">:</span> initialStates<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        Run run <span class="token operator">=</span> <span class="token function">sortRun</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>        runs<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>run<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 不断归并，直到列表中只剩下唯一一个排序段</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>runs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        runs <span class="token operator">=</span> <span class="token function">mergePass</span><span class="token punctuation">(</span>runs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">assert</span> runs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> runs<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 项目实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Remake | CS50 AI入门笔记</title>
      <link href="/2022/07/02/AI/"/>
      <url>/2022/07/02/AI/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction-to-AI"><a href="#Introduction-to-AI" class="headerlink" title="Introduction  to  AI"></a>Introduction  to  AI</h1><span id="more"></span><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ol><li><p>actions</p><p>在某一状态下可以作出的选择</p><p>ACTION(s) 返回在状态s下可以采取的行动集合。</p></li><li><p>transition model</p><p>针对某个状态采取某个动作后产生的结果</p><p>RESULT(s, action)返回由当前状态采取某行动后生成的新模型。</p></li><li><p>state space</p><p>从初始状态开始经过一系列行为可能产生的状态。</p></li></ol><h2 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h2><p>search problems contain</p><ol><li>initial state</li><li>actions</li><li>transition model</li><li>goal test 测试给定的状态是否为目标状态</li><li>path cost function 代价计算</li></ol><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>是一种记录当前状态信息的数据结构，其中包含：</p><ol><li>当前状态描述</li><li>父状态</li><li>由父状态转移到当前状态采取的行动</li><li>到达当前状态的消耗</li></ol><h3 id="MiniMax"><a href="#MiniMax" class="headerlink" title="MiniMax"></a>MiniMax</h3><p>进行二元博弈时，做最坏的打算，尽最大的努力。</p><p>博弈结果用分数来表示，A胜加分，B胜减分。一方尽可能的使分数增大，一方尽可能的使分数减少。</p><p>由于任何一方在做决策时都会受到另一方之前所作决策的影响。例如A要在B尽可能降低了分数的情况下，作出最大程度提高分数的决策。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">MAX_VALUE</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 若当前状态对局已结束，则返回对局结果</span>    <span class="token keyword">if</span> TERMINAL<span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> UTILITY<span class="token punctuation">(</span>state<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 初始化当前分数为负无穷</span>    v <span class="token operator">=</span> <span class="token operator">-</span>INFINITY    <span class="token comment" spellcheck="true"># 尝试所有可以由当前状态派生出的状态，计算对手在派生状态中采取的降低分数的决策。选取所有派生中仍旧能带来最大收益的状态。</span>    <span class="token keyword">for</span> action <span class="token keyword">in</span> ACTIONS<span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">:</span>        v <span class="token operator">=</span> MAX<span class="token punctuation">(</span>v<span class="token punctuation">,</span> MIN_VALUE<span class="token punctuation">(</span>RESULT<span class="token punctuation">(</span>state<span class="token punctuation">,</span> action<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> v</code></pre><p>如此递归的求解可能的状态，效率并不高，因此可以做一定的剪枝操作，例如当派生状态1的最小收益为4时，若派生状态2已经确定其最小值小于4（孙子状态有收益值已经小于4了，则对手采取操作后该派生的最大收益必定不可能大于4）。此时可以直接忽略该状态。</p><p>Limit Minimax</p><p>限制minimax的求解次数，例如限制搜索树的深度，每一步决策只尝试计算之后X步的可能状态。同时添加一个估计函数，判断达成目标的可能性。</p><h2 id="Knowledge"><a href="#Knowledge" class="headerlink" title="Knowledge"></a>Knowledge</h2><p>model:负责对所有可能的逻辑语句作出判断</p><p>knowledge base: 计算机初始情况下已知正误的逻辑语句集合</p><p>model check：依据已有的知识来推断给定的语句是否成立。罗列所有的可能性，判断何时前置条件与查询结果均成立。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">model_check</span><span class="token punctuation">(</span>knowledge<span class="token punctuation">,</span> qeury<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">check_all</span><span class="token punctuation">(</span>knowledge<span class="token punctuation">,</span> query<span class="token punctuation">,</span> symbols<span class="token punctuation">,</span> model<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># all of the symbols have been assigned</span>        <span class="token keyword">if</span> <span class="token operator">not</span> symbols<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># if this model is compatiable with knowledge</span>            <span class="token comment" spellcheck="true"># return whether query is compatiable with model</span>            <span class="token keyword">if</span> knowledge<span class="token punctuation">.</span>evaluate<span class="token punctuation">(</span>model<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> query<span class="token punctuation">.</span>evaluate<span class="token punctuation">(</span>model<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># else this model is nonsense to us</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            remaining <span class="token operator">=</span> symbols<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># pop a symbol to assign</span>            p <span class="token operator">=</span> remaining<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 分两种情况讨论，当前条件为真或当前条件为假</span>            model_true <span class="token operator">=</span> model<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>            model_true<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>            model_false <span class="token operator">=</span> model<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>            model_false<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">False</span>            <span class="token comment" spellcheck="true"># 如果两种情况无法同时为真，就代表还有其他条件影响结果，此时不能得出结论。但若同时为真，就代表无论其余条件是什么，目前已有知识已经足够作出判断</span>            <span class="token keyword">return</span> check_all<span class="token punctuation">(</span>knowledge<span class="token punctuation">,</span> query<span class="token punctuation">,</span> remaining<span class="token punctuation">,</span> model_true<span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token operator">&amp;</span> chekc_all<span class="token punctuation">(</span>knowledge<span class="token punctuation">,</span> query<span class="token punctuation">,</span> remaining<span class="token punctuation">,</span> model_false<span class="token punctuation">)</span>        symbols <span class="token operator">=</span> set<span class="token punctuation">.</span>union<span class="token punctuation">(</span>knowledge<span class="token punctuation">,</span> query<span class="token punctuation">)</span>    check_all<span class="token punctuation">(</span>knowledge<span class="token punctuation">,</span> query<span class="token punctuation">,</span> symbols<span class="token punctuation">,</span> dict<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h2 id="Probability"><a href="#Probability" class="headerlink" title="Probability"></a>Probability</h2><blockquote><p>unconditional probability</p></blockquote><p>在没有任何前提条件的情况下作出判断</p><blockquote><p>conditional probability</p></blockquote><p>基于某些前提，判断某件事发生的可能性。</p><p>符号表示P(a | b)，在b发生的前提下，a发生的可能性。</p><blockquote><p>random variable</p></blockquote><p>象征所有可能出现的情况。</p><blockquote><p>independence</p></blockquote><p>某事件的发生不会影响其他事件发生的可能性。</p><p>即某两个事件相互之间没有关联。</p><h3 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h3><p>P(b | a) &#x3D; P(a | b) * P(b) &#x2F; P(a)</p><p>可以通过该公式，可以推算出一些难以观测的情况的发生概率</p><p>已知在某未知原因下某件有明显影响事件的发生概率，就可以推算出在该明显影响下，对应的未知原因发生的概率。</p><p>例如，每一份疾病报告的正确性难以观测，但在疾病发生的前提下，对应报告的正确率容易采集，这样就可以推算出一份报告检测出疾病的概率。</p><h3 id="贝叶斯网络"><a href="#贝叶斯网络" class="headerlink" title="贝叶斯网络"></a>贝叶斯网络</h3><p>用于表示random variables之间依赖关系的数据结构。</p><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><ol><li><p>有向图</p></li><li><p>每一个节点象征一个随即变量</p></li><li><p>从X指向Y的箭头表示X是Y的父节点</p></li><li><p>每一个节点都有可能性分布 P(X | Parent(X))</p><p><img src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/img/AIbyese%20network.png" alt="byese network"></p></li></ol><h4 id="推论操作"><a href="#推论操作" class="headerlink" title="推论操作"></a>推论操作</h4><ol><li>枚举</li></ol><ul><li>Query X：需要计算概率分布的变量</li><li>Evidence variables E：已知的事件e的变量</li><li>Hidden variable Y：不是以上二者的变量</li></ul><p>$$<br>P(X|e) &#x3D; αP(X,e)&#x3D;α\sum_yP(X,e,y)<br>$$</p><ol start="2"><li><p>样本</p><p>生成一定数量的样本，在样本中筛选出符合条件的样本用于计算概率。</p><p>例如，若要求推断火车准点的概率，则查看火车准点在样本中的占比。若有前提条件，则先筛选出满足前提的样本，然后根据这些样本推断概率。</p><p>优化：由于样本生成没有规律，若某个前提条件发生的可能性很小，那么就会导致大量的算力被浪费在生成无用的样本上。</p><p>此时可以采取可能性加权的方式进行优化。</p><p>在获取样本时，固定前提条件必然满足，之后计算在该样本的所有前置条件中，要求的前提条件满足的可能性，可能性越高，权重越大。</p><p>例如：前提条件是火车准点，则在生成一个样本后，根据样本中的天气情况以及道路维护状态计算火车准点的可能性，依此为样本赋予权重。</p></li></ol><h3 id="Markov-model"><a href="#Markov-model" class="headerlink" title="Markov model"></a>Markov model</h3><p>用于模拟伪随机变化系统的随即模型，假设当前的状态只与依赖有限的过去的状态。</p><h4 id="Markov-chain"><a href="#Markov-chain" class="headerlink" title="Markov chain"></a>Markov chain</h4><p>一个随机变量序列，其中每一个变量的分布都遵循Markov假设。</p><h4 id="Hidden-Markov-model"><a href="#Hidden-Markov-model" class="headerlink" title="Hidden Markov model"></a>Hidden Markov model</h4><p>也是一条Markov链，但其中的状态很难被直接且准确地观测到。但一些可观测到的事件可以帮助推断出隐藏的状况。例如：街上的人都带着雨伞 -&gt; 今天下雨。</p><table><thead><tr><th>Task</th><th>Definition</th></tr></thead><tbody><tr><td>filtering</td><td>根据目前已知的观测结果，计算当前状况的概率分布。</td></tr><tr><td>prediction</td><td>根据目前已知的观测结果，计算未来状况的概率分布。</td></tr><tr><td>smoothing</td><td>根据目前已知的观测结果，计算过去状况的概率分布。</td></tr><tr><td>most likely explanation</td><td>根据目前已知的观测结果，计算最可能的状态序列。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Remake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2022/06/30/MySQL/"/>
      <url>/2022/06/30/MySQL/</url>
      
        <content type="html"><![CDATA[<p>MySQL 简易笔记</p><span id="more"></span><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="SQL语句的分类"><a href="#SQL语句的分类" class="headerlink" title="SQL语句的分类"></a>SQL语句的分类</h2><p>1.DQL:数据查询语言（所有带有select的语句）<br>2.DML:数据操作语言（insert，delete，update）<strong>操作表中的数据</strong><br>3.DDL:数据定义语言(create, drop, alter) <strong>操作表的结构</strong><br>4.TCL:事物控制语言(事务提交 commit 事务回滚 rollback)<br>5.DCL:数据控制语言(授权 grant 撤销授权 revoke)</p><h2 id="常用命令-大小写不敏感"><a href="#常用命令-大小写不敏感" class="headerlink" title="常用命令(大小写不敏感)"></a>常用命令(大小写不敏感)</h2><p>连接到Mysql服务的指令：mysql -h 主机名 -P 端口 -u 用户名 -p密码(没有空格)<br>若没有-h，默认是本机，若没有-P，默认是3306<br>1.登录:mysql -uroot -p<br>2.退出:exit<br>3.查看mysql中有哪些数据库:show databases;<br>4.使用数据库 use (dataname)<br>5.创建数据库 create database (dataname) [character set (编码格式) collate(校对规则)]<br>若没有指定编码格式，校对规则，则默认与数据库的编码格式和校对规则相同。<br>6.查看当前库有什么表: show tables;<br>7.查看创建特定表时用到的MySQL语句：show create database (dataname);<br>8.查看表列相关信息：show columns from (dataname) &#x3D; describe (dataname)<br>9.删除数据库：drop database (dataname);<br>10.备份数据库：mysqldump -u root -p -B 数据库0 数据库1 … 数据库n &gt; 备份文件存放路径 (在dos下执行) <strong>(备份实际上就是创建该库所要用的SQL语句)</strong> (-B表明要备份的是一个数据库)<br>11.备份表：mysqldump -u root -p  数据库 表1 表2 … &gt; 备份文件存放路径 (在dos下执行)<br>11.恢复数据库：source 备份文件路径<br>12.创建表：create table [tablename] (field1 datatype, field2 datatype…) character set… collate… engine…<br>13.修改表<br>    添加列 alter table tablename add column datatype [default expr]<br>    修改列 alter table tablename modify column datatype [default expr]<br>    删除列 alter table tablename drop column<br>    修改表名 rename table 表名 to 新表名<br>    修改表字符集 alter table tablename character set 字符集<br>    修改列名 alter table tablename change prename newname datatype [default expr]<br>14.删除表：drop table tablename</p><h3 id="insert操作"><a href="#insert操作" class="headerlink" title="insert操作"></a>insert操作</h3><p>insert into tablename (要插入数据的字段) values(),(),()…<br>若是给所有字段添加数据，可以不写前面的字段名称<br>默认值的使用：当不给某个字段值时，如果有默认值就会添加默认值，否则报错。</p><h3 id="update操作"><a href="#update操作" class="headerlink" title="update操作"></a>update操作</h3><p>update tablename set xxx &#x3D; xx, aaa &#x3D; aa,… [where key &#x3D; X] 若没有where语句，则修改该列所有数据</p><h3 id="delete操作"><a href="#delete操作" class="headerlink" title="delete操作"></a>delete操作</h3><p>delete from tablename [where xxx &#x3D; xx] 若没有where，整张表都会被删</p><h3 id="select操作"><a href="#select操作" class="headerlink" title="select操作"></a>select操作</h3><p>select [distinct] * &#x2F; {column1, column2…} from tablename  distinct可起到去重作用<br>select可以配合表达式操作 select expression… from tablename<br>eg:select (a + b + c) from tablename (a,b,c均为列)<br>取别名 select column&#x2F;expression as xxx …. from tablename</p><p>**列与列之间用“，”分隔，若以空格分隔，则默认后者是前者的别名。</p><h4 id="在where子句中常用的运算符"><a href="#在where子句中常用的运算符" class="headerlink" title="在where子句中常用的运算符"></a>在where子句中常用的运算符</h4><p>比较运算符: </p><ul><li>&gt; &lt; &lt;&#x3D; &gt;&#x3D; &#x3D; &lt; &gt; !&#x3D; </li><li>between…and…</li><li>in(set)</li><li>like… &#x2F; not like… 模糊查询<br>like操作符（模糊）： %表示0到多个字符  _:表示单个字符 </li><li>is null<br>逻辑运算符:<br>and, or, not</li></ul><h4 id="order-by排序查找结果"><a href="#order-by排序查找结果" class="headerlink" title="order by排序查找结果"></a>order by排序查找结果</h4><p>select column1, column2, … from tablename order by coloumn asc&#x2F;desc [, column2 asc&#x2F;desc …]<br>默认升序，且该子句应位于select语句的结尾</p><h4 id="group-by-having"><a href="#group-by-having" class="headerlink" title="group by, having"></a>group by, having</h4><p>group by用于对查询的结果分组统计  先分组然后在组内统计。<br>having子句用于限制分组显示结果  类似于where的效果。</p><h3 id="加密和系统函数"><a href="#加密和系统函数" class="headerlink" title="加密和系统函数"></a>加密和系统函数</h3><ul><li>user() 查询当前用户</li><li>database() 查询数据库名称</li><li>md5(str) 加密</li></ul><h3 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a>流程控制函数</h3><p>if(expr1, expr2, expr3) 若expr1为真，则执行expr2否则执行expr3，在if语句中，null才被判定为假<br>ifnull(expr1, expr2) 若expr1不为null，则返回expr1，否则执行expr2<br>select case when expr1 then expr2 when expr3 then expr4 … else exprN 若expr1为真，则执行expr2，若expr3成立，则执行expr4 … 否则执行exprN（只会返回一个值）</p><h2 id="表的理解"><a href="#表的理解" class="headerlink" title="表的理解"></a>表的理解</h2><p><strong>数据库中最基本的单元是表</strong><br>数据库中是以表格的形式表示数据的</p><p>行(row):数据&#x2F;记录<br>列(col):字段(属性：字段名，数据类型，约束等)</p><h3 id="mysql表查询-–-增强"><a href="#mysql表查询-–-增强" class="headerlink" title="mysql表查询 – 增强"></a>mysql表查询 – 增强</h3><p>基本语法：select … limit start, rows;   表示从<em>start+1</em>行开始取，取出rows行<br>语法顺序：group by…  having…  order by…  limit…</p><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p>默认情况下对两个表进行查询时，采用笛卡尔积：<br>从第一张表中取出一行与第二张表中的每一行结合，返回记录数&#x3D;表1行数*表2行数<br>因此需要使用where子句对提取出来的数据进行筛选</p><h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><p>特点：把同一张表当作两张表使用   但在使用中要给两张表取不同的名字<br>应用场景：需要的数据在同一张表中但不在同一行中<br>select x from [databasename] as a, [databasename] as b where…</p><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>子查询是指嵌入在其他sql语句中的select语句，也叫嵌套语句</p><ul><li><p>单行子查询<br>单行子查询是指只返回一行数据的子查询语句</p></li><li><p>多行子查询<br>多行子查询指返回多行数据的子查询 <em>使用关键字in</em></p></li></ul><p>格式：select * from emp where salarys &#x3D; (select salarys from emp where name &#x3D; ‘pcx’)</p><p><strong>子查询的结果可以作为一张临时表使用</strong></p><h3 id="all和any"><a href="#all和any" class="headerlink" title="all和any"></a>all和any</h3><p>all表示达成全部条件，any表示达成某一条件。</p><h3 id="表复制"><a href="#表复制" class="headerlink" title="表复制:"></a>表复制:</h3><p>insert into table1 select (数据列名) from table2 (复制数据)<br>create table [tablename] like [table2] (拷贝表结构)</p><h3 id="合并查询"><a href="#合并查询" class="headerlink" title="合并查询"></a>合并查询</h3><p>关键字:union<br>使用场景：</p><ul><li>在单个查询中从不同的表返回类似结构的数据</li><li>对单个表执行多个查询，要求返回单张表<br>union all 不去重  union 去重</li></ul><h3 id="外部链接"><a href="#外部链接" class="headerlink" title="外部链接"></a>外部链接</h3><p>使用场景：在将一个表中的行与另一个表中的行相关联，需要包含没有关联行的那部分行时<br>关键字：left outer join &#x2F; right outer join    on<br>语法: select xxx from [table1] left&#x2F;right outer join [table2] on 条件</p><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><h4 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h4><p>主键<em>不能重复</em>并且<em>不能为null</em><br>一张表最多只能有一个主键，但可以是复合主键<br>主键指定方式：</p><ul><li>在字段名后指定</li><li>在表定义的最后指定</li></ul><h4 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h4><p>表示该列中的值都是唯一的</p><h4 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h4><p>将从表的某字段与主表的某字段绑定<br>语法：表定义的最后 foreign key(从表字段) references 主表名(主表字段)<br><em>主表中的字段必须是主键或有unique约束</em></p><p>细节：<br>1.类型为innodb的表才支持外键<br>2.外键字段的类型要和关联字段的类型一致<br>3.外键字段的值必须要在关联字段中出现过或者为null<br>4.一旦建立主外键关系，数据就不能随意删除<br>（只有当从表中关联的外键全部被删除时，关联字段才允许被删除）</p><h4 id="自增长"><a href="#自增长" class="headerlink" title="自增长"></a>自增长</h4><p>设置为自增长的列在每一次添加一条记录时自动增量<br>语法 column datatype […] auto_increment<br>自增长默认从1开始，也可使用语句 alter table tablename auto_increment &#x3D; x;来修改起始值</p><ul><li>只有一列数据可以使用自增长</li><li>被设为自增长的列必须能被索引。</li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>语法：<br>create [unique] index 索引名 on 表名(对应字段)<br>alter table 表名 add index 索引名(对应字段)<br>添加主键索引: alter table 表名 add primary key(列名)<br>删除索引:drop index 索引名 on 表名<br>删除主键索引:alter table 表名 drop primary key</p><p>原理：<br>程序会根据索引字段建立一棵二叉搜索树（也有可能用的别的数据结构）<br>若没有索引则会进行全表扫描<br>劣势：</p><ul><li>内存空间消耗</li><li>对增删改语句的效率造成影响（数据结构必须做出对应调整）</li></ul><p>索引的类型：</p><ul><li>主键索引，主键自动为主索引</li><li>唯一索引 unique</li><li>普通索引 index</li><li>全文索引 fulltext  Mysql自带的全文索引使用不多</li></ul><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务处理：管理必须<strong>成批执行</strong>的MySQL操作<br>术语：<br>事务：一组SQL语句<br>回退：撤销指定的SQL语句<br>提交：将未存储的SQL语句结果写入数据库表<br>保留点：事务处理中设置的临时占位符，可以对它发布回退</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>start transaction 开始事务<br>savepoint 保留点名  设置保留点<br>rollback [to 保留点名] 回滚（默认回滚到初始状态）<br>commit 提交修改</p><p>注意：每一次回退都会将路径上的保留点全部删除</p><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>隔离：多个连接开启各自事务操作数据库中数据时，数据库所做的保证各个连接获取数据的准确性的操作</p><p>脏读：当前连接在事务进行中时可以读取到其他连接事务中还未提交的操作<br>不可重复读：当前连接在事务进行中时可以读取到其他连接的修改操作<br>幻读：当前连接在事务可以读取到其他连接的增添或删除操作<br>    在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</p><p>隔离级别：</p><ul><li>读未提交(read uncommitted) 可能发生脏读、不可重复读、幻读</li><li>读已提交(read committed) 可能发生不可重复读、幻读</li><li>可重复读(repeatable read) 可能发生幻读（但在Mysql中被解决）  不上锁</li><li>可串行化(serializable) 安全  上锁</li></ul><p>锁：当程序检测到有连接在对数据库进行操作时，会终止其他连接对数据库进行操作</p><p>查看当前隔离级别：select @@transaction_isolation<br>查看系统当前隔离级别：select @@global.transaction_isolation<br>设置当前会话隔离级别：set session transaction isolation level [目标隔离级别]<br>设置系统隔离级别：set global transaction isolation level [目标隔离级别]</p><p>acid特性：</p><ul><li>原子性：事务中的操作要么都发生，要么都不发生</li><li>一致性：事务必须使数据库从一个一致性状态变换到另一个一致性状态</li><li>隔离性：数据库为每一个用户开启的事务不能被其他事务的操作数据干扰，多个并发事务之间要相互隔离</li><li>持久性：一个事务一旦提交，他对数据库中的数据的改变就是永久性的，</li></ul><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>不支持事务，也不支持外键，但访问速度快，对事务完整性没有要求（适用于只需要CRUD的情况）</p><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>提供了具有提交、回滚和崩溃恢复能力的事务安全，但处理效率稍差一些，且要占据更多的磁盘空间来保留数据和索引</p><h3 id="MEMORY"><a href="#MEMORY" class="headerlink" title="MEMORY"></a>MEMORY</h3><p>使用<strong>存在内存中的内容</strong>来创建表。默认使用Hash索引，因此有极高的访问速度。</p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图是根据基表创建的一张<strong>虚拟表</strong><br>创建视图只会创建一个表结构，并将基表中的数据<strong>映射</strong>到视图中（可以理解为视图中存储着基表数据的引用）<br>不管对视图还是基表进行修改，都会对另一方造成影响 </p><p>视图的使用</p><ul><li>创建：create view 视图名 as select column1, … from 基表</li><li>修改：alter view 视图名 as select column1, … from 基表</li><li>删除：drop view 视图名1，视图名2</li></ul><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>创建用户：create user ‘用户名‘@’ip地址’ identified by ‘密码’<br>修改密码：alter user ‘用户名‘@’ip地址’ identified by ‘密码’<br>删除用户：drop user ‘用户名‘@’ip地址’ </p><h3 id="用户权限管理"><a href="#用户权限管理" class="headerlink" title="用户权限管理"></a>用户权限管理</h3><p>赋予权限： grant 权限列表 on 库.对象 to ‘用户名‘@’ip地址’ [identified by ‘密码’]<br>回收权限：revoke 权限列表 on 库.对象 from ‘用户名‘@’ip地址’ [identified by ‘密码’]</p><p>注意：</p><ul><li>在创建用户时如果不指定Host，则为%，表示可以从任意IP登录该用户</li><li>指定host时，192.168.0.%表示192.168.0.*</li><li>在删除用户时，若host不是%，则需要明确指定IP</li></ul><h2 id="常用数据类型"><a href="#常用数据类型" class="headerlink" title="常用数据类型"></a>常用数据类型</h2><p>decimal (M,D) M表示该数总位数, D表示小数点后位数 【默认情况下M是10，D是0】</p><h3 id="数学相关函数"><a href="#数学相关函数" class="headerlink" title="数学相关函数"></a>数学相关函数</h3><p>ABS(num) 绝对值<br>BIN(decimal_number) 十进制转二进制<br>ceiling(num) 向上取整<br>conv(num, from_base, to_base) 进制转换<br>floor(num) 向下取整<br>format(num, decimal_places) 保留小数位数<br>hex (decimalnumber) 转十六进制<br>least (num1, num2, …) 最小值<br>mod(num, denominator) 求余<br>rand([seed]) 随机数 范围为 0 &lt;&#x3D; v &lt;&#x3D; 10</p><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p>char 固定长度字符串，最大255<strong>字符</strong><br>varchar <strong>可变</strong>长度字符串 最大65532<strong>字节</strong>(有3个字节被用于记录大小)<br>字符串使用细节：<br>char(4),varchar(4) 此时的4表示<strong>字符数</strong>，不区分字母与汉字，其占用空间大小视编码格式决定<br>char(4)是<strong>定长</strong><br>varchar(4)是<strong>变长</strong>，其占用空间可伸缩，而varchar本身需要1-3个字节来存放长度大小<br>若数据定长，推荐使用char，re：char的查询速度更快。<br>若varchar不够用，则可使用mediumtext或longtext</p><h4 id="字符串相关函数"><a href="#字符串相关函数" class="headerlink" title="字符串相关函数"></a>字符串相关函数</h4><p>** 字符串起始下标为1**</p><ul><li>charset(str) 返回字符字符集</li><li>concat(str1, …) 连接字符串</li><li>instr(string, substring) 返回substring在string中出现的位置，若没有则返回0</li><li>ucase(string) 转换成大写</li><li>lcase(string) 转换成小写</li><li>left(string, length) 从string中的左边起取length个字符</li><li>length(string) string长度</li><li>replace(str, search_str, replace_str) 在str中用replace_str替换search_str</li><li>strcmp(string1, string2) 逐字符比较两子串大小</li><li>substring(str, position [, length]) 从str的position位置开始，取length个字符</li><li>ltrim(string) rtrim(string) trim 去除前端&#x2F;后端&#x2F;前后端空格。</li></ul><h3 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h3><p>date 年月日<br>datetime 年月日时分秒<br>timestamp 时间戳 （在insert和update时自动更新）配置代码 timestamp xxx not null default current_timestamp update current_timestamp</p><h4 id="时间日期函数"><a href="#时间日期函数" class="headerlink" title="时间日期函数"></a>时间日期函数</h4><p>current_date() 当前日期<br>current_time() 当前时间<br>current_timestamp() 当前时间数<br>date(datetime) 返回datetime日期部分<br>date_add(date, interval d_value d_type) 在date上加上日期或时间<br>date_sub(date. interval d_value d_type) 在date上减去日期或时间<br>datediff(date1, date2) 两个日期差（结果是天） 日期需要年月日时分秒<br>timediff(date1, date2) 两个时间差（多少小时多少分钟多少秒）<br>now() 当前时间<br>unix_timestamp()返回1970-1-1 00:00:00至今的秒数<br>last_day(date)返回传入日期所在月份的最后一天</p><p>*日期类型可以用大于小于号比较，但要将日期用单引号括起来</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字节青训 | 网络</title>
      <link href="/2022/06/30/Internet/"/>
      <url>/2022/06/30/Internet/</url>
      
        <content type="html"><![CDATA[<p>啥都听不懂的青训营 摸鱼笔记之网络</p><span id="more"></span><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><p>网络接入 —— 路由</p><p>路由不是对称的，根据当前的网络情况，响应包的路径也可能跟请求包不同</p><p>路由也不会修改IP地址，在数据包传输过程中，源IP与目的IP均不会发生变化，只会修改MAC地址，同时在发出数据包时不仅要知道目的MAC，还要知道发出的端口。</p><p>ARP请求不会跨网段发送，若目的与源不在同一网段，则会先寻找下一跳的MAC地址，利用ARP逐级跳转。</p><blockquote><p>免费ARP</p></blockquote><p>发送一个包含新IP的ARP数据包，提示所有服务器刷新ARP表</p><ul><li>当网段中新增了一台机器时，可以通过这种方式让其余机器刷新ARP表，而避免在使用时临时刷新。</li><li>当服务器有新增IP时，可以通过免费ARP检测IP冲突。</li></ul><p>PS：Mac地址不能替代IP地址 -&gt; IP地址的存在实际上就是为了解决二层协议（包括Mac）的兼容问题。</p><blockquote><p>SSL&#x2F;TLS非对称加密</p></blockquote><p>将数据进行加密之后再传输，并且使用的加密算法也进行加密，接收方通过与发送方协商获知所使用的加密算法。</p><h2 id="网络提速"><a href="#网络提速" class="headerlink" title="网络提速"></a>网络提速</h2><p>对于静态资源，使用CDN缓存</p><p>对于动态API，优化网络路径</p><h3 id="网络容灾"><a href="#网络容灾" class="headerlink" title="网络容灾"></a>网络容灾</h3><p>故障发生-&gt;故障感知-&gt;自动切换-&gt;服务恢复</p><ol><li>外网容灾<br><img src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/img/high_performance2022-05-19%2020-30-07%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"></li></ol><p>内部专线出现故障后，切换为外网连接</p><ol start="2"><li>降级容灾</li></ol><p><img src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/img/high_performance2022-05-19%2020-32-53%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"></p><p>网址会被映射到两个机房，其中一个机房出现问题时，首先进行故障感知，然后判断机房B能否承受住那部分流量，最后才进行切换。</p><ol start="3"><li>缓存</li></ol><p>当程序故障后，就用缓存先响应用户请求</p><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><h3 id="DNS记录类型"><a href="#DNS记录类型" class="headerlink" title="DNS记录类型"></a>DNS记录类型</h3><ol><li>A&#x2F;AAAA：IP指向记录，前者指向IPv4, 后者指向IPv6</li><li>CNAME：别名记录，配置值为别名或主机名，客户端根据别名继续解析以提取IP地址</li><li>TXT：文本记录，购买证书时需要</li><li>MX：邮件交换记录，用于指向邮件交换服务器</li><li>NS：解析服务器记录，用于指定哪台服务器对于该域名解析</li><li>SOA：起始授权机构记录</li></ol><h2 id="HTTP接入协议"><a href="#HTTP接入协议" class="headerlink" title="HTTP接入协议"></a>HTTP接入协议</h2><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>对称加密：使用相同的秘钥来加密传输内容，一端加密后，对端收到数据会用相同的秘钥来解密</p><p>非对称加密：如果用公钥对数据进行加密，只有用对应的私钥才能解密；如果用私钥对数据进行加密，那么只有用对应的公钥才能解密。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> 青训摸鱼笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字节青训 | 高质量编程与性能调优</title>
      <link href="/2022/06/30/high-quality-programming/"/>
      <url>/2022/06/30/high-quality-programming/</url>
      
        <content type="html"><![CDATA[<p>啥都听不懂的青训营 摸鱼笔记之高质量编程</p><span id="more"></span><h1 id="高质量编程与性能调优"><a href="#高质量编程与性能调优" class="headerlink" title="高质量编程与性能调优"></a>高质量编程与性能调优</h1><blockquote><p>编程原则</p></blockquote><ol><li><p>简单性</p><p>消除“多余的复杂性”，以简单清晰的逻辑编写代码</p></li><li><p>可读性</p></li><li><p>生产力</p></li></ol><h2 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h2><p>   注释：</p><ol><li><p>注释应该解释代码作用， 适合注释公共符号</p></li><li><p>注释应该解释代码如何做的，适合注释实现过程</p></li><li><p>注释应该解释代码实现的原因，适合解释代码的外部因素，提供额外的上下文。</p></li><li><p>注释应该解释代码什么情况会出错，适合解释代码的限制条件。</p></li><li><p>公共符号始终需要注释</p><p>PS：代码是最好的注释，注释应提供代码未表达出的上下文信息。</p></li></ol><p>变量命名：</p><ol><li>简洁</li><li>缩略词全部大写，当其位于变量开头其不需要导出时，全部小写</li><li>变量与实际使用位置距离越远，需要携带的上下文信息越多</li></ol><p>函数命名：</p><ol><li>函数名不携带包名的上下文信息</li><li>简短</li><li>当名为foo的包某个函数返回类型Foo时，可以省略类型信息。</li></ol><p>包名：</p><ol><li>只由小写字母组成。不包含大写字母和下划线等字符</li><li>简短并包含一定上下文信息</li><li>不要与标准库同名</li></ol><p>控制流程：</p><ol><li>线性原理，避免嵌套</li><li>正常代码最小缩进</li></ol><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>Go提供benchmark工具进行基准性能测试</p><pre class=" language-shell"><code class="language-shell">go test -bench=. -benchmen</code></pre><h3 id="性能优化建议"><a href="#性能优化建议" class="headerlink" title="性能优化建议"></a>性能优化建议</h3><h3 id="预分配"><a href="#预分配" class="headerlink" title="预分配"></a>预分配</h3><p>尽量在make阶段确定切片&#x2F;对象大小</p><p>slice进行扩容时会在已有切片基础上创建切片，不会创建新的底层数组。</p><blockquote><p>场景</p></blockquote><ol><li>原切片较大，代码在原切片基础上新建小切片</li><li>原底层数组在内存中有引用，得不到释放</li></ol><p>此时可以使用copy代替re-slice</p><h3 id="空结构体"><a href="#空结构体" class="headerlink" title="空结构体"></a>空结构体</h3><p>使用空结构体节省内存</p><p>空结构体struct{}实例不占据任何的内存空间</p><p>使用场景：</p><ul><li>节省资源</li><li>空结构体本身具备很强的语义，可以作为占位符使用</li></ul><h3 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h3><p>锁是通过操作系统来实现，属于系统调用</p><p>atomic操作通过硬件实现，效率更高</p><p>sync.Mutex应该用于保护一段逻辑，而不仅仅是用于保护一个变量</p>]]></content>
      
      
      <categories>
          
          <category> 青训摸鱼笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高质量编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字节青训 | 高性能Go语言发行版优化与落地实践</title>
      <link href="/2022/06/30/high-performance-go/"/>
      <url>/2022/06/30/high-performance-go/</url>
      
        <content type="html"><![CDATA[<p>啥都听不懂的青训营 摸鱼笔记之高性能Go语言发行版优化与落地实践</p><span id="more"></span><h1 id="高性能Go语言发行版优化与落地实践"><a href="#高性能Go语言发行版优化与落地实践" class="headerlink" title="高性能Go语言发行版优化与落地实践"></a>高性能Go语言发行版优化与落地实践</h1><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><blockquote><p>业务层优化</p></blockquote><ul><li>针对特定场景，具体问题，具体分析</li><li>容易获得较大性能收益</li></ul><blockquote><p>语言运行时优化</p></blockquote><ul><li>解决更通用的性能问题</li><li>考虑更多场景</li><li>tradeoffs</li></ul><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="自动内存管理"><a href="#自动内存管理" class="headerlink" title="自动内存管理"></a>自动内存管理</h3><p>由程序语言的运行时系统回收动态内存</p><ul><li>避免手动内存管理，专注于业务逻辑</li><li>保证内存使用的正确性和安全性</li></ul><blockquote><p> 三个任务</p></blockquote><ul><li>为新对象分配空间</li><li>找到存活对象</li><li>回收死亡对象的内存空间</li></ul><blockquote><p>相关概念</p></blockquote><ul><li>Mutator:业务线程，分配新对象，修改对象指向关系</li><li>Collector:GC线程，找到存活对象，回收死亡对象的内存空间</li><li>Serial GC: 只有一个Collector，每次进行GC操作时需要暂停程序</li><li>Parallel GC: 支持多个Collector同时回收GC算法</li><li>Concurrent GC:业务代码与垃圾回收同时执行（Collector必须感知对象指向关系的改变）</li></ul><h3 id="追踪垃圾回收"><a href="#追踪垃圾回收" class="headerlink" title="追踪垃圾回收"></a>追踪垃圾回收</h3><p>对象被回收的条件：指针指向关系不可达的对象</p><p>标记根对象：静态变量，全局变量，常量，线程栈等（所有在程序运行时永远存活的对象）</p><p>标记：找到可达对象</p><p>清理：所有不可达对象（根据对象的生命周期，使用不同的标记和清理策略）</p><ul><li>将存活对象复制到另外的内存空间</li><li>将死亡对象的内存标记为“可分配”</li><li>移动并整理存活对象</li></ul><h3 id="分代GC"><a href="#分代GC" class="headerlink" title="分代GC"></a>分代GC</h3><p>Intution:很多对象在分配出来后很快就不再使用了</p><p>每个对象的年龄：经历过GC的次数</p><p>不同年龄的对象处于heap的不同区域</p><ol><li><p>年轻代</p><p>常规的对象分配</p><p>由于存活对象很少，可以直接复制到其他空间</p><p>GC吞吐率高</p></li><li><p>老年代</p><p>对象趋向于一直活着，反复复制开销大</p><p>可以采用标记对象的方法。</p></li></ol><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>每个对象都有一个与之关联的引用数目</p><p>对象存活的条件：当且仅当引用数大于0</p><p>优点：</p><ol><li>内存管理的操作被平摊到程序执行过程中</li><li>内存管理不需要了解runtime的实现细节</li></ol><p>缺点：</p><ol><li>维护引用计数的开销较大：通过原子操作保证对引用技术操作的原子性和可见性</li><li>无法回收环形数据结构 （所有对象相互之间会引用，虽然该数据结构已经不可达，但因为其中每个对象的引用数不会降为0，所以无法被回收）</li><li>内存开销：每个对象都引入的额外内存空间存储引用数目</li><li>回收内存依然可能引发暂停</li></ol><h3 id="Balanced-GC"><a href="#Balanced-GC" class="headerlink" title="Balanced GC"></a>Balanced GC</h3><p>GAB对于Go内存管理来说是个对象</p><p>本质：将多个小对象的分配合并成一次对象的分配</p><p>利用三个指针标记内存块的起点和终点，以及下一块可用内存的地址</p><p>问题：GAB的对象分配方式会导致内存被延迟释放。例如，GAB中仅存活了1个小对象，此时GAB无法释放，但又浪费了大量内存。</p><p>解决：当GAB总大小超过一定阈值时，将GAB中存活的对象复制到另外分配的GAB中（用copying GC 的算法管理小对象）</p><h2 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h2><h3 id="编译器的结构"><a href="#编译器的结构" class="headerlink" title="编译器的结构"></a>编译器的结构</h3><p><img src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/img/high_performance2022-05-14%2022-00-44%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"></p><h3 id="函数内联"><a href="#函数内联" class="headerlink" title="函数内联"></a>函数内联</h3><p>将被调用函数的函数体的副本替换到调用位置，同时重写代码以反映参数的绑定</p><p>优点：</p><ol><li>消除函数调用开销，例如传递参数，保存寄存器等</li><li>将过程间分析转化为过程内分析，帮助其他优化</li></ol><p>缺点：</p><ol><li>函数体变大，(icache)不友好</li><li>编译生成的Go镜像变大</li></ol><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>分析代码中指针的动态作用域，指针在何处可以被访问</p><p>思路：</p><p>从对象分配处出发，沿着控制流，观察对象的数据流</p><p>若发现指针p在当前作用域s：</p><ol><li><p>作为参数传递给其他函数</p></li><li><p>传递给全局变量</p></li><li><p>传递给其他的goroutine</p></li><li><p>传递给已逃逸的指针指向的对象</p><p>即，若该对象可以被外部函数调用，则称其逃逸出s</p></li></ol><p>优化：增加函数的内联，扩大函数边界，使得原本逃逸的对象只能作用在当前作用域。而未逃逸的对象可以在栈上分配，并且无论是分配还是回收都很快，同时也减少了在heap上的分配，减小GC负担。</p>]]></content>
      
      
      <categories>
          
          <category> 青训摸鱼笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 高性能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="/2022/06/30/Linux/"/>
      <url>/2022/06/30/Linux/</url>
      
        <content type="html"><![CDATA[<p>Linux基本知识及Shell基础用法</p><span id="more"></span><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>实质:内核<br>应用场景:**服务器领域(最强的领域)**，桌面开发，嵌入式<br>特性:免费稳定高效<br>主要发行版:ubuntu, CentOS, RedHat</p><p><strong>Linux中一切皆文件</strong><br>隐藏文件以 . 打头</p><h2 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h2><p><img src="https://www.runoob.com/wp-content/uploads/2014/06/d0c50-linux2bfile2bsystem2bhierarchy.jpg" alt="目录结构"></p><ol><li><p>&#x2F;bin [<strong>常用</strong>] (&#x2F;usr&#x2F;bin, &#x2F;usr&#x2F;local&#x2F;bin)<br>存放经常使用的命令</p></li><li><p>&#x2F;sbin (&#x2F;usr&#x2F;sbin, &#x2F;usr&#x2F;local&#x2F;sbin)<br>存放系统管理员使用的系统管理程序</p></li><li><p>&#x2F;home <strong>[常用]</strong><br>存放<strong>普通用户</strong>的主目录，在Linux中每个用户都有一个自己的目录。</p></li><li><p>&#x2F;root <strong>[常用]</strong><br>该目录为系统管理员，也称作超级权限者的用户主目录。</p></li><li><p>&#x2F;lib </p><p>系统开机所需要最基本的动态连接共享库。</p></li><li><p>&#x2F;etc <strong>[常用]</strong><br>所有的系统管理所需要的配置文件和子目录</p></li><li><p>&#x2F;usr <strong>[常用]</strong><br>存放用户的应用程序和文件。</p></li><li><p>&#x2F;boot <strong>[常用]</strong><br>存放的是启动Linux的核心文件，包括一些连接文件以及镜像文件。</p></li><li><p>&#x2F;dev<br>类似于设备管理器， 把所有的硬件用文件的形式存储。</p></li><li><p>&#x2F;media <strong>[常用]</strong><br>Linux系统会自动识别一些设备，当识别后，Linux会把识别的设备挂载到这个目录下。</p></li><li><p>&#x2F;mnt <strong>[常用]</strong><br>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂在&#x2F;mnt&#x2F;上</p></li><li><p>&#x2F;opt</p><p>是给主机额外安装软件所存放的目录(尽量将安装软件存放到这)。</p></li><li><p>&#x2F;usr&#x2F;local <strong>[常用]</strong><br>给主机额外安装软件的目录，一般源码安装的软件在这。</p></li></ol><h2 id="vi和vim"><a href="#vi和vim" class="headerlink" title="vi和vim"></a>vi和vim</h2><p>vi：Linux中内置的文本编辑器<br>vim：具有程序编辑的能力，可以看作是vi的增强版本，类似vscode</p><h3 id="vi和vim常用的三种模式"><a href="#vi和vim常用的三种模式" class="headerlink" title="vi和vim常用的三种模式"></a>vi和vim常用的三种模式</h3><p>正常模式：<br>默认模式，可以移动光标，删除字符或删除整行类处理档案内容，也可以复制粘贴<br>包含操作：<br>(n)yy 拷贝当前开始n行<br>p:粘贴<br>(n)dd 删除当前开始n行<br>G:到最末行<br>gg:到首行<br>u:撤回上一步操作<br>行号 shift g:定位到对应行号</p><p>插入模式：<br>按i进入编辑模式<br>命令行模式：<br>按:或&#x2F;进入<br>包含操作：<br>wq(保存并推出)，q(退出)，q!(强制退出)<br>查找内容：命令行下 &#x2F;关键字 回车， 输入n查找一个<br>设置行号：set nu 取消行号:set nonu<br>通过提供相关指令，完成读取，存盘，替换，离开vim，显示行号等动作。</p><h2 id="文件基本属性"><a href="#文件基本属性" class="headerlink" title="文件基本属性"></a>文件基本属性</h2><p>chown(change owner):修改所属用户与组</p><p>chmod(change mode):修改用户的权限</p><h4 id="file-type"><a href="#file-type" class="headerlink" title="file type"></a>file type</h4><ul><li>d:目录</li><li>-:文件</li><li>l:链接文档</li><li>b:装置文件里面的可供储存的接口设备</li><li>c:表示装装置文件里面的穿行端口设备</li></ul><h3 id="文件属主和属组"><a href="#文件属主和属组" class="headerlink" title="文件属主和属组"></a>文件属主和属组</h3><p>对于文件来说，都有一个特定的所有者。</p><p>同时，在Linux中，用户是按组分类的，一个用户属于一个或多个组</p><p>文件所有者以外的用户又可分为文件所有者的同组用户和其他用户</p><h3 id="更改文件属性"><a href="#更改文件属性" class="headerlink" title="更改文件属性"></a>更改文件属性</h3><ol><li><p>chgrp</p><p>更改文件属组</p><p>语法：chgrp [-R] 属组名  文件名</p><p>-R:递归更改文件属组</p></li><li><p>chown</p><p>更改文件属主，也可以同时更改文件属组</p><p>语法：chown [-R] 属主名[:属组名] 文件名</p></li><li><p>chmod</p><p>更改文件九个属性(owner&#x2F;group&#x2F;others的rwx权限)</p><p>各权限的权值：</p><p>​r:4</p><p>​w:2</p><p>​x:1</p><p>语法：chmod [-R] xyz 文件或目录</p></li></ol><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><h4 id="硬连接"><a href="#硬连接" class="headerlink" title="硬连接"></a>硬连接</h4><p>硬链接指通过索引节点[文件的编号]来进行连接，可以理解为他们直接指向指定的数据。若有多个硬连接指向同一个文件，则删除其中一个并不会造成影响。</p><p>意义：允许一个文件拥有多个有效路径名，可以避免误删重要文件。只有当所有的硬链接均被删除后，文件的数据块及目录才会被释放（有点类似Java对类的管理）</p><h4 id="软连接"><a href="#软连接" class="headerlink" title="软连接"></a>软连接</h4><p>又称符号链接，该文件实际上是个文本文件，其中包含了另一文件的位置信息（类似于指针），可以理解为Windows中的快捷方式。删除符号链接不会对源文件造成影响，删除源文件会导致符号链接指向一个无效连接。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>ln [-s] src des  将desc连接到src上 </p><p>-s:创建连接</p><h2 id="文件目录指令"><a href="#文件目录指令" class="headerlink" title="文件目录指令"></a>文件目录指令</h2><p>绝对路径：由根目录**&#x2F;**写起</p><p>相对路径：不是由&#x2F;写起</p><p>功能描述：显示当前工作目录的绝对路径</p><ul><li><p>pwd指令</p><p>显示当前所在目录</p><p>常用选项：</p><p>-P:显示出确实的路径，而非使用连结路径</p></li><li><p>ls指令<br>基本语法：ls  [选项] [目录或是文件]<br>常用选项：<br>-a：显示当前目录所有的文件和目录，包括隐藏的。<br>-l：以列表的方式显示信息，包含文件的属性与权限等等数据。<br>-h：更人性化的显示（一般与l合用）<br>-d：长数据串列输出，包含文件的属性与权限等等数据</p></li><li><p>cd指令<br>基本语法：cd [参数] （功能描述：切换到指定目录）<br>理解：绝对路径和相对路径<br>cd ~ 或者cd：回到自己的家目录<br>cd .. 回到目前目录的上一级目录</p></li><li><p>mkdir指令</p><p>创建目录</p><p>mkdir 目录 （默认只能创建一级<strong>目录</strong>）</p><p>常用选项：</p><p>-m 配置权限</p><p>-p  递归创建文件夹</p></li><li><p>rmdir指令<br>rmdir [指令] 要删除的<strong>空目录</strong><br>rmdir删除的是<strong>空目录</strong>，若目录下有内容时无法删除<br>如果要删除非空目录，需要使用 rm -rf 要删除的目录。</p><p>常用选项：</p><p>-p：从该目录起，一次删除多级空目录</p></li><li><p>touch指令<br>创建空文件<br>touch 文件名称</p></li><li><p>cp指令<br>拷贝文件到指定目录<br>基本语法：cp [选项] source(原文件路径) dest(目标路径)<br>常用选项：</p><ul><li><p>-r 递归复制整个文件夹</p></li><li><p>-f 若目标档已存在且无法开启，则移除后再尝试一次</p></li><li><p>-p 连同文件的属性一起复制过去</p></li></ul><p>强制覆盖指令 \cp</p></li><li><p>rm指令<br>移除文件或目录<br>基本语法：rm [选项] 要删除的文件或目录<br>常用选项：<br>-r：递归删除整个文件夹<br>-f：强制删除不提示</p></li><li><p>mv指令<br>移动或重命名文件<br>mv source destination<br>若两个文件处于用以文件夹下，且为同一类型，则表示重命名，否则表示移动</p></li><li><p>cat指令<br>查看文件内容 <strong>只能浏览文件而不能修改文件</strong><br>基本语法：<br>cat [选项] 要查看的文件<br>常用选项：-n 显示行号</p></li><li><p>echo指令<br>输出内容到控制台<br>基本语法：echo [选项]  [输出内容]<br>eg:输出环境变量：echo $PATH</p></li><li><p>head指令<br>用于显示文件的开头部分内容，默认情况下head指令显示文件的前10行内容<br>基本语法：<br>head 文件<br>head -n x 文件（查看文件头x行内容）</p></li><li><p>.tail 指令<br>用于显示文件的开头部分内容，默认情况下tail指令显示文件的最后10行内容<br>基本语法：<br>tail 文件<br>tail -n x 文件（查看文件尾x行内容）<br>tail -f 实时追踪文件的更新</p></li><li><p>&gt;指令和&gt;&gt;指令<br>&gt; 覆写， &gt;&gt; 追加</p></li></ul><p><strong>软连接：存放了链接其他文件的路劲，相当于快捷方式</strong><br>创建软连接： ln -s [原文件或目录]  [软连接所处目录]</p><p>history<br>查看已经执行过的历史命令，也可以执行历史命令<br>基本语法：<br>history 显示所有历史命令<br>history x 显示最近使用过的10个命令<br>!x 执行历史编号为x的命令</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>帮助指令：<br>man 获得帮助信息<br>基本语法：man[命令或配置文件]（功能描述：获得帮助信息）</p><p>help指令 获得shell内置命令的帮助信息<br>基本语法:help 命令</p><h2 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h2><h3 id="用户登录和注销"><a href="#用户登录和注销" class="headerlink" title="用户登录和注销"></a>用户登录和注销</h3><p>切换用户 su - 用户名<br>注销用户 logout** (在运行级别3下有效)**</p><h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><p>useradd 用户名 添加一个用户并在&#x2F;home&#x2F;中创建一个同名文件夹<br>useradd -d 文件路径 用户名 在指定路径中创建用户文件夹</p><p>常用选项：</p><ul><li>-c comment   指定一段注释性描述</li><li>-g 用户组   指定用户所属的用户组</li><li>-G 用户组…   指定用户所属的附加组</li><li>-s Shell文件  指定用户的登录Shell</li></ul><h3 id="指定-x2F-修改密码"><a href="#指定-x2F-修改密码" class="headerlink" title="指定&#x2F;修改密码"></a>指定&#x2F;修改密码</h3><p>passwd 用户名 (若不指定用户名默认修改当前用户密码)</p><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><p>删除用户但保留home中的文件夹 userdel 用户名<br>彻底删除 userdel -r 用户名</p><h3 id="查询用户信息"><a href="#查询用户信息" class="headerlink" title="查询用户信息"></a>查询用户信息</h3><p>id 用户名<br>whoami 查看<strong>登录用户</strong></p><h3 id="角色组"><a href="#角色组" class="headerlink" title="角色组"></a>角色组</h3><p>系统可以对有共性&#x2F;权限的用户进行统一管理。</p><p>添加组 groupadd 组名<br>删除组 groupdel 组名<br>往组中添加用户 useradd -g 用户组 用户名（若没有指定组，则默认会生成一个与用户同名的组，然后将用户放进去）<br>修改用户组别：usermod -g 用户组 用户名</p><h3 id="用户和组相关文件"><a href="#用户和组相关文件" class="headerlink" title="用户和组相关文件"></a>用户和组相关文件</h3><p>&#x2F;etc&#x2F;passwd 文件<br>用户的配置文件，记录用户的各种信息<br>每行的含义：用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</p><p>&#x2F;etc&#x2F;shadow 文件<br>口令的配置文件<br>每行的含义：登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</p><p>&#x2F;etc&#x2F;group 文件<br>组的配置文件，记录Linux包含的组的信息<br>每行含义：组名:口令:组标识号:组内用户列表</p><h2 id="搜索查找指令"><a href="#搜索查找指令" class="headerlink" title="搜索查找指令"></a>搜索查找指令</h2><ul><li><p>find指令</p><ul><li>从指定目录向下递归遍历各个子目录，将满足条件的文件或目录显示在终端</li><li>基本语法：find [搜索范围] [选项]</li><li>选项说明：<ul><li><ol><li>-name&lt;文件名&gt; 按照指定的文件名格式查找文件</li></ol></li><li><ol start="2"><li>-user &lt;用户名&gt; 查找属于指定用户名所有文件</li></ol></li><li><ol start="3"><li>-size &lt;文件大小&gt;(单位：k,M,G) 按照指定的文件大小查找文件</li></ol></li></ul></li></ul></li><li><p>locate指令</p><ul><li>locate指令可以快速定位文件路径。locate会利用<strong>事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件</strong>(不包含&#x2F;tmp文件夹)。该指令**无需遍历整个系统文件 **，查询速度较快，但必须定期更新数据库。</li><li>基本语法：locate 搜索文件             updatedb更新数据库</li></ul></li><li><p>grep指令</p><ul><li>grep过滤查找</li><li>基本语法： grep [选项] 查找内容 源文件</li><li>常用选项：-n 显示匹配及行号  -j 忽略字母大小写</li></ul></li><li><p>**管道符号 | **</p><ul><li>表示将前一个命令的处理结果传递给后面的命令处理。</li></ul></li></ul><h2 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h2><p>0：关机<br>1：单用户【找回丢失密码】<br>2：多用户状态没有网络服务<br>3：多用户状态有网络服务<br>4：系统未使用保留给用户（没什么用）<br>5：图形界面<br>6：系统重启</p><p>调整运行级别：init [0123456]<br>查看当前运行级别：systemctl get-default<br>调整默认运行级别：systemctl set-default TARGET.target<br>multi-user.target:多用户级别<br>graphical.target:图形化级别</p><h2 id="磁盘管理（待补全）"><a href="#磁盘管理（待补全）" class="headerlink" title="磁盘管理（待补全）"></a>磁盘管理（待补全）</h2><p>df</p><p>列出文件系统的整体磁盘使用量</p><table><thead><tr><th>选项参数</th><th>功能</th></tr></thead><tbody><tr><td>-a</td><td>列出所有的文件系统</td></tr><tr><td>-k</td><td>以KBytes的容量显示各文件系统</td></tr><tr><td>-m</td><td>以MBytes的容量显示各文件系统</td></tr><tr><td>-h</td><td>以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示</td></tr><tr><td>-T</td><td>显示文件系统类型</td></tr><tr><td>-i</td><td>不用硬盘容量，而以inode的数量来表示</td></tr></tbody></table><p>du</p><p>查询指定目录的磁盘占用情况</p><table><thead><tr><th>选项参数</th><th>功能</th></tr></thead><tbody><tr><td>-a</td><td>列出所有的文件系统</td></tr><tr><td>-k</td><td>以KBytes的容量显示各文件系统</td></tr><tr><td>-m</td><td>以MBytes的容量显示各文件系统</td></tr><tr><td>-h</td><td>以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示</td></tr><tr><td>-s</td><td>列出总量而已，而不列出每个各别的目录占用容量</td></tr><tr><td>-S</td><td>不包括子目录下的总计</td></tr></tbody></table><h2 id="任务调度-Crond"><a href="#任务调度-Crond" class="headerlink" title="任务调度 Crond"></a>任务调度 Crond</h2><h3 id="Crontab"><a href="#Crontab" class="headerlink" title="Crontab"></a>Crontab</h3><p>定时执行某项任务</p><p> 语法：crontab [-u user] {-l | -r | -e}</p><p>-u user  设定指定user的时程表</p><table><thead><tr><th>常用选项</th><th>功能</th></tr></thead><tbody><tr><td>-e</td><td>执行文字编辑器来设定时程表，内定的文字编辑器是 VI，如果你想用别的文字编辑器，则请先设定 VISUAL 环境变数来指定使用那个文字编辑器(比如说 setenv VISUAL joe)</td></tr><tr><td>-r</td><td>删除目前的时程表</td></tr><tr><td>-l</td><td>列出目前的时程表</td></tr></tbody></table><p>时间格式：</p><pre><code>f1 f2 f3 f4 f5 program</code></pre><ul><li>其中 f1 是表示分钟，f2 表示小时，f3 表示一个月份中的第几日，f4 表示月份，f5 表示一个星期中的第几天。program 表示要执行的程序。</li><li>当 f1 为 * 时表示每分钟都要执行 program，f2 为 * 时表示每小时都要执行程序，其馀类推</li><li>当 f1 为 a-b 时表示从第 a 分钟到第 b 分钟这段时间内要执行，f2 为 a-b 时表示从第 a 到第 b 小时都要执行，其馀类推</li><li>当 f1 为 *&#x2F;n 时表示每 n 分钟个时间间隔执行一次，f2 为 *&#x2F;n 表示每 n 小时个时间间隔执行一次，其馀类推</li><li>当 f1 为 a, b, c,… 时表示第 a, b, c,… 分钟要执行，f2 为 a, b, c,… 时表示第 a, b, c…个小时要执行，其馀类推</li></ul><p>重启Crond服务</p><p>service crond restart</p><h3 id="at"><a href="#at" class="headerlink" title="at"></a>at</h3><p>at命令是一次性定时计划任务，at的守护进程atd会以后台模式运行，检查作业队列来进行</p><p>默认情况下，atd守护进程每60秒检查作业队列，有作业时，会检查作业运行时间，如果时间于当前时间匹配，则运行此作业</p><p>语法：at [选项] [时间]</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-m</td><td>当 at 工作完成后，无论命令是否输出，都用 E-mail 通知执行 at 命令的用户。</td></tr><tr><td>-c 工作标识号</td><td>显示该 at 工作的实际内容。</td></tr><tr><td>-t 时间</td><td>在指定时间提交工作并执行，时间格式为 [[CC]YY]MMDDhhmm。</td></tr><tr><td>-d</td><td>删除某个工作，需要提供相应的工作标识号（ID），同 atrm 命令的作用相同。</td></tr><tr><td>-l</td><td>列出当前所有等待运行的工作，和 atq 命令具有相同的额作用。</td></tr><tr><td>-f 脚本文件</td><td>指定所要提交的脚本文件。</td></tr></tbody></table><p>时间格式</p><table><thead><tr><th>格式</th><th>用法</th></tr></thead><tbody><tr><td>HH:MM</td><td>比如 04:00 AM。如果时间已过，则它会在第二天的同一时间执行。</td></tr><tr><td>Midnight（midnight）</td><td>代表 12:00 AM（也就是 00:00）。</td></tr><tr><td>Noon（noon）</td><td>代表 12:00 PM（相当于 12:00）。</td></tr><tr><td>Teatime（teatime）</td><td>代表 4:00 PM（相当于 16:00）。</td></tr><tr><td>英文月名 日期 年份</td><td>比如 January 15 2018 表示 2018 年 1 月 15 号，年份可有可无。</td></tr><tr><td>MMDDYY、MM&#x2F;DD&#x2F;YY、MM.DD.YY</td><td>比如 011518 表示 2018 年 1 月 15 号。</td></tr><tr><td>now+时间</td><td>以 minutes、hours、days 或 weeks 为单位，例如 now+5 days 表示命令在 5 天之后的此时此刻执行。</td></tr></tbody></table><p>eg：</p><pre class=" language-shell"><code class="language-shell">[root@localhost ~J# at 02:00 2013-07-26at> /bin/syncat> /sbin/shutdown -h nowat> <EOT>job 9 at 2013-07-26 02:00#在指定的时间关机。在一个at任务中是可以执行多个系统命令的</code></pre><p>atq:查看当前等待运行的job</p><p>atrm [工作号] 删除指定的job</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Remake | git</title>
      <link href="/2022/06/30/git/"/>
      <url>/2022/06/30/git/</url>
      
        <content type="html"><![CDATA[<p>git极简指南</p><span id="more"></span><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="1-处理数据的方式"><a href="#1-处理数据的方式" class="headerlink" title="1. 处理数据的方式"></a>1. 处理数据的方式</h2><p>记录当前项目快照，而非像其他版本管理工具一样记录更改。</p><p>对于在没有改动的文件，会让其指向之前版本的对应文件。</p><p><img src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/img/gitdealdata.png" alt="dealdata"></p><blockquote><p>git中数据的三种状态</p></blockquote><p>modified : 文件内容被修改，但还未被添加到暂存区</p><p>staged : 文件修改被提交到暂存区，下个版本会体现该修改</p><p>committed : 修改被提交到本地仓库</p><blockquote><p>git 存储数据的结构</p></blockquote><p>Git 用 tree 来表示每一份项目快照。对于没有修改的文件，git不会重复存储。</p><p>git会保留每一个文件的所有版本</p><p><img src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/img/gitobject%20graph.png" alt="object graph"></p><h2 id="2-基本用法"><a href="#2-基本用法" class="headerlink" title="2. 基本用法"></a>2. 基本用法</h2><blockquote><p>git clone <em>URI-of-remote-repo</em> [<em>project-name</em>]</p></blockquote><p>克隆远程仓库到本地</p><blockquote><p>git init</p></blockquote><p>初始化本地仓库</p><p>–initial-branch 初始化分支</p><p>–bare 创建一个裸仓库（纯git目录，无法进行添加文件等操作，一般用于服务器）</p><p>–template 通过模板来构建自定义目录</p><blockquote><p>git diff</p></blockquote><p>查看修改的内容(不包含在暂存区的修改)</p><p>–staged 包含在暂存区的修改</p><blockquote><p>git show [id : filename]</p></blockquote><p>显示历史版本&#x2F;指定版本信息，同时显示文件被修改的具体内容。</p><p>类似于 git log -p</p><blockquote><p>git status</p></blockquote><p>查看当前版本的详细情况</p><blockquote><p>git stash</p></blockquote><p>将当前修改保存，并恢复到修改之前的状态</p><p>git stash list 查看当前保存的修改</p><p>git stash pop 弹出保存的修改，并于后来进行的修改合并</p><blockquote><p>git pull</p></blockquote><p>获取远程仓库的修改，并将其与本地仓库最新版本合并</p><blockquote><p>git merge</p></blockquote><p>合并修改</p><p>若出现合并冲突，使用<code>git status</code>查看冲突文件并手动处理</p><p>解决冲突后要将文件重新提交到本地仓库</p><p>–continue 继续合并  –abort 抛弃本次合并</p><blockquote><p>git reset</p></blockquote><p>取消文件的暂存状态</p><p>git reset HEAD filename</p><blockquote><p>git restore</p></blockquote><p>git restore filename 丢弃工作区更改</p><p>git restore –staged filename 取消暂存</p><blockquote><p>git fetch</p></blockquote><p> 拉取远程某些分支的最新代码，不会执行merge操作</p><blockquote><p>git remote</p></blockquote><p>配置远程仓库</p><p>git remote add 远程仓库名 [url]</p><p>git remote set-url –add –push 远程仓库名 [url]  修改指定远程仓库的push目的地</p><blockquote><p>git gc</p></blockquote><p>删除一些不必要的object并进行压缩</p><p>git reflog expire –expire&#x3D;now –all 取消操作记录日志</p><p>git gc –prune&#x3D;now 让gc处理当前时间点前的object</p><blockquote><p>密钥配置</p></blockquote><p>ssh-keygen -t ed25519(加密算法) -C [email]</p><h2 id="3-原理介绍"><a href="#3-原理介绍" class="headerlink" title="3.原理介绍"></a>3.原理介绍</h2><h3 id="3-1-Objects"><a href="#3-1-Objects" class="headerlink" title="3.1 Objects"></a>3.1 Objects</h3><p>commit, tree, blob在git中统称为Object</p><p>blob：存储文件内容</p><p>Tree：存储文件目录信息</p><p>commit：存储提交信息，一个commit可以对应唯一的一个版本代码</p><h3 id="3-2-Refs"><a href="#3-2-Refs" class="headerlink" title="3.2 Refs"></a>3.2 Refs</h3><p>refs的内容就是对应的commit ID</p><p>refs&#x2F;head前缀表示的是分支</p><h3 id="3-3历史版本"><a href="#3-3历史版本" class="headerlink" title="3.3历史版本"></a>3.3历史版本</h3><p>commit中有parent字段，可通过串联获取历史版本</p><blockquote><p>修改历史版本</p></blockquote><p>git commit –amend</p><p>修改上一次提交的message，只会新增一个commit object，相关的tree ,parent都不变</p><p>git fsck –lost-found查找悬空的commit（没有refs指向他）</p><h3 id="3-4-代码合并"><a href="#3-4-代码合并" class="headerlink" title="3.4 代码合并"></a>3.4 代码合并</h3><blockquote><p>Fast-Forward</p></blockquote><p>不会产生一个merge节点，合并后保持线性历史，如果目标分支有更新，则要通过rebase操作更新源分支</p><p>git merge 分支名 –ff-only</p><p><img src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/img/gitfast-forward.png" alt="fast-forward"></p><blockquote><p>Three way forward</p></blockquote><p>三方合并，会产生一个merge节点。</p><p>git merge –no-ff</p>]]></content>
      
      
      <categories>
          
          <category> Remake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++</title>
      <link href="/2022/06/30/Cpp/"/>
      <url>/2022/06/30/Cpp/</url>
      
        <content type="html"><![CDATA[<p>C++极简笔记</p><span id="more"></span><h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><blockquote><p>ostream</p></blockquote><p>只能使用<code>&lt;&lt;</code>运算符</p><p><strong>将任何类型的数据转换成字符串并传输给流</strong></p><blockquote><p>istream</p></blockquote><p>只能使用<code>&gt;&gt;</code>运算符</p><p><strong>将流中的字符串转换成对应的数据类型</strong></p><blockquote><p>cin</p></blockquote><p>每一次读取数据只会读取到下一个空白符为止。所有没有被读走的数据会保留在缓冲区。</p><blockquote><p>4种表示流状态的的bit</p></blockquote><p>Good bit : 准备好读写</p><p>Fail bit : 之前的操作失败，之后的所有bit都被冻结</p><p>EOF bit :  之前的bit已经到达文件尾部</p><p>Bad bit : 外部错误，无法从外部数据源读取数据到缓冲区，通常无法恢复</p><h2 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h2><blockquote><p>vector</p></blockquote><p>若直接使用下标访问，会将数组超限错误静默处理。建议使用at()方法。</p><blockquote><p>deque</p></blockquote><p>头插速度更加快，但是访问元素速度相对较慢。</p><blockquote><p>map&#x2F;set</p></blockquote><p>数据按照键排序存储（排序方式自定义），在迭代访问一系列元素时速度较快</p><blockquote><p>unordered_map&#x2F;unordered_set</p></blockquote><p>数据无序存储，访问单个元素时较快。</p><blockquote><p>multimap</p></blockquote><p>一个键可以对应多个值</p><pre class=" language-C++"><code class="language-C++">unordered_multimap<string,int> map;    map.insert(&#123;"cxc", 1&#125;);    map.insert(&#123;"cxc", 10&#125;);</code></pre><blockquote><p>iterator</p></blockquote><p>分类：</p><ul><li>输入&#x2F;输出迭代器</li><li>Forward iterator : 同时具备写入与读取的功能</li><li>Bidirectional iterator : 具有以上所有功能，且既可以向前也可以向后移动，接受<code>--</code>运算符</li><li>Random Access iterator : 具有以上所有功能，且可对迭代器任意加减某个数。</li></ul><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>struct 就是一个特殊的类，但是他的所有属性都是公开的。</p><h4 id="修饰词"><a href="#修饰词" class="headerlink" title="修饰词"></a>修饰词</h4><blockquote><p>private</p></blockquote><p>通常包含所有的类属性。并且用户不能直接访问或修改被<code>private</code> 修饰的内容。</p><blockquote><p>public</p></blockquote><p>可以被用户直接访问。通常定义了一系列与私有内容实现交互的内容。</p><p>tips:C++中的this是指向当前对象的一个指针，不是引用。</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ol><li>default construction: the construction takes no parameters</li><li>copy construction: use an object to construct another construction as the copy</li></ol><pre class=" language-c++"><code class="language-c++">vector<int> vec&#123;&#125; // default constructionvector<int> vec&#123;1,2,3&#125; // regular construction</code></pre><p>做深拷贝时要注意，若拷贝对象中存储的是指针类型，则应深拷贝指针指向的对象而非指针本身。直接调用STL库中的拷贝构造只会深拷贝存储的对象。</p><p>copy assignment: <em>删除旧的对象</em>，将其变量名用于另一个变量的拷贝。首先确保<code>另一个变量</code>不是自己本身。</p><p>tips: </p><ul><li><p>拷贝构造器，拷贝赋值，析构函数要么全用默认，要么全部自定义。</p></li><li><p>应显示指明子类的构造函数，默认会使用基类的构造函数。</p><pre class=" language-c++"><code class="language-c++">class Drink &#123;    private:        std::string _flavor        public:        Drink() = default; // 显式指明默认构造器        Drink(std::string flavor) : _flavor(flavor) &#123;&#125;&#125;class Tea : public Drink &#123;    public:        Tea() = default;        Tea(string flavor) : Drink(flavor) &#123;&#125; // invoke base constructor&#125;</code></pre></li></ul><p>若构造器使用explicit修饰，则该构造器不能对参数作隐式的类型转换，也不能用拷贝初始化。</p><pre class=" language-c++"><code class="language-c++">explicit HashMap(size_t bucket_count, const H& hash = H());</code></pre><p>对于声明了noexcept的函数，编译器会对其进行优化，但此类函数一旦抛出异常，就会终止程序。</p><pre class=" language-c++"><code class="language-c++">void func() noexcept</code></pre><p>Initializer_list constructor</p><pre class=" language-c++"><code class="language-c++">myvector(const myvector<T>& other) : t_size(other.t_size), length(other.length) &#123;        datas = new T[length];        for (int i = 0; i < t_size; i++) &#123;            datas[i] = other.datas[i];        &#125;    &#125;</code></pre><h4 id="折构函数"><a href="#折构函数" class="headerlink" title="折构函数"></a>折构函数</h4><p>删除单个对象关键字：delete</p><p>删除数组关键字：delete []</p><p>折构函数声明：ClassName::~ClassName()</p><p>折构函数不必显示调用，在离开作用域时会被自动调用。</p><p><strong>若一个类要被继承，则必须将其析构函数设置为虚函数</strong></p><h4 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h4><p>允许类外的对象访问类内的私有对象</p><p>初始化列表</p><pre class=" language-c++"><code class="language-c++">private:    int logicalSize;StringVector::StringVector() : logicalSize(0) &#123;&#125;</code></pre><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>语法</p><pre class=" language-C++"><code class="language-C++">class A &#123;    public:        virtual void make() = 0; // The class implementing A must define this method&#125;;// 此处的public代表B中所有由A继承来的方法与属性的访问限制照旧class B : public A &#123; // B implement A    ...&#125;</code></pre><p>对于一个接口，其只能包含纯虚函数。</p><p>对于非虚成员，所有的在父类中与子类成员同名的成员都会被隐藏。</p><p>只有声明为虚函数的方法会被动态绑定到子类上，其余方法一概到编译类型中去寻找。</p><blockquote><p>concept (only C++20)</p></blockquote><p>concept是一个在编译期间进行判定的断言，属于接口的一类</p><p>对模板类的类型参数进行一定的约束。</p><pre class=" language-c++"><code class="language-c++">template <typename It, typename Type>requires Input_Iterator<It> && Iterator_of<It>     && Equality_comparable<Value_type<It>, Type>int count(It it, Type val)&#123;    ...&#125;template <typename It, typename Type>concept DerivedFrom = Input_Iterator<It> && Iterator_of<It>     && Equality_comparable<Value_type<It>, Type>template <class D, class B>int count(It it, Type val) requires DerivedFrom<D, B>&#123;    &#125;</code></pre><h2 id="Lambada"><a href="#Lambada" class="headerlink" title="Lambada"></a>Lambada</h2><p>语法：</p><p>[capture clause] (parameter) -&gt; returnType {function body}</p><p>capture clause:give access to outside variables</p><p>stable_partition()</p><pre class=" language-C++"><code class="language-C++">BidirectionalIterator stable_partition (BidirectionalIterator first,                                        BidirectionalIterator last,                                        UnaryPredicate pred);</code></pre><p>将集合中的元素分成两组，一组符合pred要求，一组不符合，并且不改变各元素相对位置。</p><p>tips：如果调用非STL内置的方法对容器进行操作，该方法只能操作容器内容，但容器大小不会动态变化。</p><h2 id="Const"><a href="#Const" class="headerlink" title="Const"></a>Const</h2><p> 被const修饰的变量不可被修改，包括该变量中的内容。同时若一个函数的参数为const，则在该函数调用的所有函数中都必须满足const，(即不能将一个const参数传递给非const参数)。</p><blockquote><p> const on objects</p></blockquote><p>只允许调用const function 并且将所有的public成员当作被const修饰</p><blockquote><p>const on functions</p></blockquote><p>保证这个函数不会调用除const functions之外的函数，并且不允许修改任何非静态，非可变的成员</p><pre class=" language-c++"><code class="language-c++">void fun() const;</code></pre><p>const pointer</p><pre class=" language-c++"><code class="language-c++">// read from right to left// const iterator 类似于常量指针int * const p; // constant pointer to a non-const intconst int * p; // non-const pointer to a const int// const_iterator 类似于指针常量</code></pre><p>tips：一个被const修饰的对象同样不能调用非const方法，因此建议在实现一个类的时候，同时实现const和非const两个版本。</p><h2 id="lvalue-and-rvalue"><a href="#lvalue-and-rvalue" class="headerlink" title="lvalue and rvalue"></a>lvalue and rvalue</h2><p>lvalue:被变量名(地址)标识的表达式，可以用<code>&amp;</code>取到地址</p><p>rvalue:临时变量，无法用&amp;取到地址， 无法被保存。</p><p>右值只出现在寄存器中，而在堆栈中没有空间。</p><p><code>&amp;</code>为左值引用，只能绑定左值</p><p><code>&amp;&amp;</code>为右值引用，只能绑定右值</p><p>tips:</p><ul><li>被const修饰的左值引用可以绑定右值。 re：非const修饰的左值引用可以修改指向对象的内容，但右值明显是不可以被修改的。</li><li>右值引用绑定右值，但右值引用本身是个左值。</li></ul><h2 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h2><p>使用new申请的存储空间位于堆中，若在指向它的指针消失前，其存储空间没有被释放，则其永远在堆中占有那部分空间，但无法被访问到，造成内存泄漏。</p><p>在程序中需要被手动释放的资源</p><table><thead><tr><th></th><th>Acquire</th><th>Release</th></tr></thead><tbody><tr><td>Heap memory</td><td>new</td><td>delete</td></tr><tr><td>Files</td><td>open</td><td>close</td></tr><tr><td>Locks</td><td>try_clock</td><td>unlock</td></tr><tr><td>Sockets</td><td>socket</td><td>close</td></tr></tbody></table><p>tips: 我们无法保证当异常抛出时，delete会被正常执行。因此需要妥善处理异常，避免内存泄漏。</p><blockquote><p>RAII</p></blockquote><p>在构造器中获取所有资源</p><p>在析构函数中释放所有资源</p><pre class=" language-c++"><code class="language-c++">// you don't need to invoke closeifstream input("xxx.txt");// you must invoke closeifstream input();input.open("xxx.txt");input.close();</code></pre><h2 id="SmartPointer"><a href="#SmartPointer" class="headerlink" title="SmartPointer"></a>SmartPointer</h2><blockquote><p>std::unique_pointer</p></blockquote><p>唯一指向某一块内存资源，并在指针超出作用域时删除对象。</p><p>因此该指针不允许拷贝。</p><blockquote><p>std::shared_pointer</p></blockquote><p>内存资源可以被多个指针指向，在最后一个指向的指针消失时，摧毁对象。</p><p>相关构造器 (用这个)</p><p>make_XXX<class>(args)</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>当要进行多线程时，使用原子数据类型</p><p>相关库</p><p><img src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/img/C%2B%2B20220630105430.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Remake | 数据库 (未完待续)</title>
      <link href="/2022/06/30/Database/"/>
      <url>/2022/06/30/Database/</url>
      
        <content type="html"><![CDATA[<p>菜狗的Remake之路 – 数据库篇</p><span id="more"></span><h1 id="Database"><a href="#Database" class="headerlink" title="Database"></a>Database</h1><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="Grammar"><a href="#Grammar" class="headerlink" title="Grammar"></a>Grammar</h3><p>sql描述的是我需要什么，而非怎么做。底层交给DBMS实现。</p><blockquote><p>limit</p></blockquote><p>limit [Integer]</p><p>查找表中前Integer条记录。通常与orderby一同使用。</p><blockquote><p>group by</p></blockquote><p>将表切分成多个组，并以表为单位进行相关操作。</p><p>group by不允许直接查询非group by参数的字段。</p><p>re: group by会将许多记录作为整体操作，但非group by参数字段在分类后其数量在同一组中也势必&gt;&#x3D;1 无法成为一个整体被反映到表中，因此不被允许。</p><p>所有的聚合函数都需要针对一个组来使用，如果不显式指明，则整张表作为一个组。</p><p>Having对查询出的组根据给定条件进行过滤。</p><blockquote><p>like</p></blockquote><pre class=" language-sql"><code class="language-sql"><span class="token keyword">WHERE</span> xxx <span class="token operator">LIKE</span> <span class="token string">'B_%'</span><span class="token comment" spellcheck="true">-- _ means any character. % means any number of that character</span><span class="token comment" spellcheck="true">-- Regular expression</span><span class="token comment" spellcheck="true">-- ~ means match</span><span class="token keyword">WHERE</span> xxx <span class="token operator">~</span> <span class="token string">'B.*'</span></code></pre><blockquote><p>集合运算</p></blockquote><p>UNION: 取并集</p><p>INTERSECT: 取交集</p><p>EXCEPT: 取差集</p><p>加上ALL代表显示重复值。</p><blockquote><p>view</p></blockquote><pre class=" language-sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">view</span> view_name<span class="token keyword">as</span> select_statement</code></pre><p>临时视图</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> bname<span class="token punctuation">,</span> scount<span class="token keyword">FROM</span> Boats2 B<span class="token punctuation">,</span><span class="token punctuation">(</span>    <span class="token keyword">SELECT</span> B<span class="token punctuation">.</span>bid<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>    <span class="token keyword">FROM</span> R<span class="token punctuation">.</span>bid <span class="token operator">=</span> B<span class="token punctuation">.</span>bid <span class="token operator">AND</span> B<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">'red'</span>    <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> <span class="token number">b</span><span class="token punctuation">.</span>bid<span class="token punctuation">)</span> <span class="token keyword">AS</span> Reds<span class="token punctuation">(</span>bid<span class="token punctuation">,</span> scount<span class="token punctuation">)</span><span class="token keyword">WHERE</span> Reds<span class="token punctuation">.</span>bid <span class="token operator">=</span> B<span class="token punctuation">.</span>bid <span class="token operator">AND</span> scount <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token keyword">WITH</span> tablename<span class="token punctuation">(</span><span class="token keyword">columns</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token punctuation">(</span>select_statement<span class="token punctuation">)</span></code></pre><h3 id="Concept"><a href="#Concept" class="headerlink" title="Concept"></a>Concept</h3><blockquote><p>SQL执行流程</p></blockquote><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> target<span class="token operator">-</span>list<span class="token keyword">FROM</span> single <span class="token keyword">table</span><span class="token keyword">WHERE</span> qualification<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> grouping list<span class="token keyword">HAVING</span> <span class="token keyword">group</span><span class="token operator">-</span>qualification</code></pre><ol><li>FROM  确认要查询的表</li><li>WHERE  筛选满足条件的记录</li><li>SELECT  保留所需要(出现在SELECT&#x2F;GROUP BY&#x2F; HAVING)的字段</li><li>GROUP BY  形成需要的组</li><li>HAVING  筛选满足条件的组</li><li>DISTINCT  去除冗余的记录</li></ol><blockquote><p>Division</p></blockquote><p> 查找拥有所有船只的船员 &#x3D;&#x3D;&gt;  查找没有哪艘船不持有的船员</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> s<span class="token punctuation">.</span>sname<span class="token keyword">from</span> Sailors s<span class="token keyword">where</span> <span class="token operator">not</span> <span class="token keyword">exists</span> <span class="token punctuation">(</span>    <span class="token keyword">select</span> B<span class="token punctuation">.</span>bid    <span class="token keyword">from</span> Boats <span class="token number">b</span>    <span class="token keyword">where</span> <span class="token operator">not</span> <span class="token keyword">exists</span> <span class="token punctuation">(</span>        <span class="token keyword">select</span> R<span class="token punctuation">.</span>id        <span class="token keyword">where</span> R<span class="token punctuation">.</span>bid <span class="token operator">=</span> B<span class="token punctuation">.</span>bid        <span class="token operator">And</span> R<span class="token punctuation">.</span>sid <span class="token operator">=</span> S<span class="token punctuation">.</span>sid    <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>NULL</p></blockquote><p>NULL代表<strong>不确定</strong></p><p>所有与NULL直接进行判定的操作都被判为False</p><p>聚合函数会忽略其所有操作的字段中的NULL值</p><h2 id="Hardware"><a href="#Hardware" class="headerlink" title="Hardware"></a>Hardware</h2><h3 id="Disk"><a href="#Disk" class="headerlink" title="Disk"></a>Disk</h3><p>访问的方式不是通过指针解除引用，而是借助API</p><p>READ：将一页数据从磁盘移到内存中，然后通过内存的地址对磁盘进行访问</p><p>WRITE：将一页数据从内存写入磁盘</p><p>注意API调用的速度都非常慢，需要良好的规划。</p><blockquote><p>访问一个页的时间消耗</p></blockquote><p>查找：磁盘臂将磁头定位到目标位置</p><p>旋转延迟：等待目标数据块旋转到磁头下</p><p>传输时间：将数据从磁盘读取到内存</p><p>主要的IO时间消耗在查找和旋转延迟上</p><blockquote><p>预测行为</p></blockquote><p>缓存访问次数多的数据块</p><p>提前将很有可能被访问的数据提取到内存中</p><p>若要写入的是连续的数据块，则可以先进行缓存，最后一并写入。</p><blockquote><p>磁盘中数据块的组织</p></blockquote><p>Next block concept：</p><ul><li>在同一磁道上连续的数据块</li><li>在同一磁盘上的数据块</li><li>在相邻磁盘上的数据块</li></ul><p>因此可以将文件的数据块在磁盘上连续存储，来介绍查询和旋转延迟</p><p>对于顺序的扫描，就可以做到提前提取，一次读取大量连续的数据块（一次性将文件的大部分提取到内存中）</p><h3 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h3><p>表会被存储为逻辑文件，由数据块构成，每个数据块中都存储一系列记录</p><blockquote><p> DB File Structures</p></blockquote><ol><li><p>Unordered Heap Files</p><p>记录在页中随意存放，适用于经常查询所有记录的情况</p></li><li><p>Clustered Heap Files</p><p>记录和页被分组存放</p></li><li><p>Sorted Files</p><p>记录和页按某一顺序存放</p></li><li><p>Index Files</p><p>可能会包含指向其他文件中记录的索引</p></li></ol><h3 id="Page"><a href="#Page" class="headerlink" title="Page"></a>Page</h3><p>Header会包含：</p><ol><li>记录数量</li><li>空余的空间</li><li>可能会有指向下一个元素的指针</li><li>可能会有Bitmaps</li></ol><blockquote><p>布局</p></blockquote><p>方向：</p><ul><li><p>记录数量（定长还是变长）</p></li><li><p>是否打包</p></li></ul><p>定长：</p><ol><li><p>打包</p><p>让记录稠密分布，类似链表的形式。</p><p>Record id &#x3D; (pageId, record number in page)</p><p>添加元素十分容易，但删除需要重组数据，让后面的数据填补被删数据的空白。</p></li></ol><p><img src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/img/image-20220528161445934.png" alt="稠密布局"></p><ol start="2"><li><p>不打包</p><p>在头部添加bitmaps，标记每个存储单元的存储情况</p><p>在插入时只要寻找首个还没被标记的存储单元即可</p><p>删除时只需要清除bitmaps中对应的位即可</p></li></ol><p><img src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/img/image-20220528161648072.png" alt="稀疏布局"></p><p>变长：</p><p>在page的底部维护一个slot directory，第一个元素（从右往左）为记录的个数，第二个为指向首个空地址的指针，其余位置放置各个记录的id。</p><p>插入元素时，只需要直接插入第二个指针指向的存储单元，并用一个闲置槽记录新纪录的id即可</p><p>删除元素时，回收对应的存储单元，并清除对应id所在的槽。</p><p>删除会导致page中出现不连续的空闲空间，此时可以对其进行再分配，也可以等剩余连续空间用完后再清理。</p><p>而当page大小需要变化时，例如page需要扩容，则直接在slot directory的最后添加记录id即可（从右往左看）</p><p><img src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/img/image-20220528163256111.png" alt="变长布局"></p><h3 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h3><p>关系模型</p><p>每条记录都有一些固定的类型</p><p>不将类型信息存储在记录中而是放在系统目录中，以此节省空间，</p><blockquote><p>定长</p></blockquote><p>在一个文件中，所有记录中字段的类型都是一致的</p><p>在内存和磁盘中字节的表现形式一致。</p><blockquote><p>变长</p></blockquote><p>将变长的字段放在尾部，添加一个记录头，其中存储指向变长字段的指针以及长度</p><p><img src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/img/image-20220530094616356.png" alt="变长字段结构"></p><h3 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h3><p>索引是一种数据结构，利用search key实现对data entry的快速查找和修改</p><p>查找操作需要支持许多类型的操作，例如比较时需要考虑一维还是二维比较</p><p>search key可以是表字段的任意子集，并且不一定要是unique键，也可以是某具有唯一性的复合属性</p><p>data entry:存储在索引中的条目</p><h4 id="ISAM"><a href="#ISAM" class="headerlink" title="ISAM"></a>ISAM</h4><p>最简单的做法：对存储键值的文件使用二分查找。但因为有跨页中断，因此效率一般</p><p>改进：再多加一层连接不同的page，将其作为查找树的根节点。节点本身的键值起到标识左右子树范围的作用。</p><p><img src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/img/image-20220530150809929.png" alt="ISAM原理图"></p><p>压缩：每个内部节点的最左边的值可以被省略。</p><p>插入：在指定位置插入对应节点，可能需要重新排序。如果插入后会超出原先能容纳的数据量，则会再开辟一块Overflow pages存储，被逻辑连接到最后一块页数据之后。随着超出数据量的增多，查找速度会逐步退化成线性。</p><h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+ Tree"></a>B+ Tree</h4><p>结构与ISAM类似, 节点存储&lt;Key, Page Ptr&gt;</p><p>但B+树可以实现动态索引，保持树永远是平衡的，并且支持更高效的插入和删除，因为增长都体现在根节点而非叶子节点。</p><p>约束条件：</p><ol><li>每一个<strong>内部结点</strong>至少被填满一半，d &lt;&#x3D; #entry &lt;&#x3D; 2d</li><li>d称为B树的阶数，结点最大扇出数为2d+1</li></ol><p>B+树的叶子结点之间必须做逻辑连接，因为他不像ISAM一样在物理层面就连在一起，但这也方便它进行动态分配。</p><p><img src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/img/image-20220531192910950.png" alt="B+树原理图"></p><p>插入操作：</p><p>查找到新数据应在的叶子结点</p><ol><li><p>若该结点未满：直接将其存入，并重新排序</p></li><li><p>若该结点已满：分裂当前结点，建立一个新的结点，将现有的2d+1个数据中较小的d个拷贝进一个结点1，另一部分拷贝进另一个结点2。然后将结点2中最小的数据拷贝一份传入父节点中。若父节点已满重复上述步骤。</p><p>如果要向新的索引结点传递数据，则直接推入，而非拷贝。</p><p>re：对于B+树来说，所有的数据都存在叶子结点，因此必须在叶子结点保留相关数据，而其对应的值则可以传到索引结点起到划分域的作用。</p></li></ol><p>大规模插入操作：</p><p>将要插入的数据按照键先进行排序，然后直接向叶子结点插入数据，超出可容纳个数时就进行分裂，确保每一个叶子结点中的数据量都达到插入因子。这样和反复的插入相比节省了大量IO时间，已经完成装载的部分不会被算法考虑，节省时间。</p><p>索引结构需要考虑的问题</p><ol><li>支持的查询</li><li>Search key的选择</li><li>数据的存储方式</li><li>变长键的处理</li><li>性能消耗</li></ol><h4 id="Search-Key-and-Ordering"><a href="#Search-Key-and-Ordering" class="headerlink" title="Search Key and Ordering"></a>Search Key and Ordering</h4><p>在一个有序的索引中，它的键都会按照字典序排列</p><p>字典序：先比较search key中的第一个字段，若相等，继续比较第二个字段，以此类推。</p><p>一个复合查询键的格式：整个查询由m个等值比较与一个大小比较(必须放在最后)构成。哦</p><h4 id="Data-Entry-Storage"><a href="#Data-Entry-Storage" class="headerlink" title="Data Entry Storage"></a>Data Entry Storage</h4><p>数据在索引中的存储方式：</p><ol><li>值</li><li>单一引用</li><li>引用链表（当数据量很大时，单一引用的存储方式会分裂出大量的索引记录）</li></ol><p>如果存储引用，则必须能支持多索引查询，否则就需要为每个索引都建立一个索引文件，导致数据冗余，加大修改数据的难度。</p><p>Clustered vs. Unclustered Index</p><p>聚合索引会根据search key确保索引<em>大致有序</em>(并不要求绝对顺序)</p><p>因此聚合索引往往能提供比较好的查询性能。同时顺序的磁盘访问也有助于进行类似prefetching之类的优化工作，并且也方便进行压缩操作。</p><p><img src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/img/image-20220602203353495.png" alt="聚合索引 vs. 非聚合索引"></p><p>对于聚合索引，它在查询时要涉及的页明显少于非聚合索引。</p><p>但聚合索引的维护成本相对较高，并且由于其在初始插入时会预留1&#x2F;3空间给之后的插入操作，会带来一定的空间浪费。</p><p>Variable Length Keys &amp; Records</p><p>当字段为变长时，顺序就失去了意义（难以比较），不同的结点会存储不同长度的条目。与此同时，不同索引存储的记录引用个数也会产生较大的差距，不利于高效查询。</p><p>因此针对变长的字段，我们在要求填充超过半数时，是从字节数的角度进行衡量。</p><p>键后缀压缩</p><p>提取记录中键的最小前缀放在头部，然后将剩余部分链接上去。</p><p><img src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/img/image-20220602205107634.png" alt="键后缀压缩"></p><p>适用于复合键，且首个属性个体差异不大，之后的属性差异较大。</p><h2 id="Buffer-Management"><a href="#Buffer-Management" class="headerlink" title="Buffer Management"></a>Buffer Management</h2><p><img src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/img/image-20220608222913582.png" alt="缓冲区结构"></p><p>当上层向缓存发起请求时，缓存会先在内部查找有没有需要的数据页，如果有，直接返回，如果没有，从磁盘读取到缓存，然后返回。</p><p>脏页：在缓存中有数据被修改，但还没有刷入内存的数据页</p><p>处理方式：用一个dirty bit标识当前页是否是脏页。</p><table><thead><tr><th>FrameId</th><th>PageId</th><th>Dirty?</th><th>Pin count</th></tr></thead><tbody><tr><td>1</td><td></td><td></td><td></td></tr><tr><td>2</td><td></td><td></td><td></td></tr><tr><td>3</td><td></td><td></td><td></td></tr></tbody></table><p>Pin count显示当前有多少任务在使用该缓存</p><h3 id="Replacement-Policy"><a href="#Replacement-Policy" class="headerlink" title="Replacement Policy"></a>Replacement Policy</h3><p>替换策略：</p><p>Least-recently-used(LRU), Clock</p><p>Most-recently-used(MRU)</p><p>根据访问的数据特征选择</p><h4 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h4><p>替换原则：挑选当前不被使用的，且在近期都没有被使用的数据页替换</p><p>方法：在缓存池的结构中添加一个记录上一次使用截止期的字段</p><table><thead><tr><th>FrameId</th><th>PageId</th><th>Dirty?</th><th>Pin count</th><th>Last used</th></tr></thead><tbody><tr><td>1</td><td></td><td></td><td></td><td></td></tr><tr><td>2</td><td></td><td></td><td></td><td></td></tr><tr><td>3</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>优势：对于部分数据需要被频繁访问的情况很友好</p><p>劣势：找到最不受待见的数据页需要线性时间（可以用堆优化到对数级）</p><h4 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h4><p>一种类LRU策略，用一个指针依次扫描缓存池中的Frame，在结构中添加一个字段表示是否为最近访问的字段。</p><p><img src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/img/image-20220608224724744.png" alt="Clock"></p><p>若指向的页正在被使用，直接跳过。若指向的页ref bits为1，且没有被使用，则将ref bits置为0。若某页既没有被使用，ref bits也为0，则将它替换下来。</p><p>Clock替换掉的仅仅是当前不热门的数据，而LRU会替换掉最不热门的数据，因此Clock相对来说开销会小一点。</p><p>但LRU类型的策略在面对大型数据时都存在致命缺陷:</p><p>当数据页的数量超过了缓存池的大小时，缓存命中率会直接降为0。考虑文件长度为7页，缓存池大小为6页，读取前6页时都在填充缓存池，当读取到第7页时，会将第1页踢掉。若下一步是再次读取第1页，则又需要讲第1页重新从磁盘读入缓存。LRU会将后续马上要用到的数据踢出缓存，大大降低了效率。</p><h4 id="MRU"><a href="#MRU" class="headerlink" title="MRU"></a>MRU</h4><p>当MRU处理大型文件时，第一轮与LRU无异。但在处理第7页数据时，它会踢掉最近使用的，也就是第6页。之后再次读取第1页时就会命中缓存，平均每次读取缓存命中次数为B - (N-B)。因此当文件过大时，命中次数也会下降。</p><p>综上：LRU在随机读取，涉及热门程度的数据的读取上占据优势。MRU在重复读取上占据优势。DBMS会根据查询数据特征选择相对优秀的策略。</p><h3 id="DBMS-vs-OS-Buffer-Cache"><a href="#DBMS-vs-OS-Buffer-Cache" class="headerlink" title="DBMS vs OS Buffer Cache"></a>DBMS vs OS Buffer Cache</h3><p>OS不会管理数据库的缓存</p><p>re：</p><ol><li>不同OS支持的操作不相同，但都会支持DBMS，因此放在DBMS上具备更好的适配性</li><li>OS只能识别物理层面上的连续的数据页，而DBMS可以根据其索引，例如B+树叶子结点的兄弟属性来识别逻辑上连续的数据页，能够更好的进行类似pre-fetching的操作。</li><li>OS无法强制让数据刷入磁盘。</li></ol><h2 id="Sorting-and-Hashing"><a href="#Sorting-and-Hashing" class="headerlink" title="Sorting and Hashing"></a>Sorting and Hashing</h2><h3 id="out-of-core-algorithm"><a href="#out-of-core-algorithm" class="headerlink" title="out-of-core algorithm"></a>out-of-core algorithm</h3><h4 id="Single-passing-Streaming"><a href="#Single-passing-Streaming" class="headerlink" title="Single passing Streaming"></a>Single passing Streaming</h4><p>利用函数f(x)将记录映射为另一个值。</p><p>尽可能地减少RAM的使用（映射函数需要让产出的结果占用空间小于其对应的记录），降低IO使用率。</p><p><img src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/img/image-20220611220459995.png" alt="单缓冲"></p><h4 id="Double-Buffer"><a href="#Double-Buffer" class="headerlink" title="Double Buffer"></a>Double Buffer</h4><p>主线程利用一对输入输出缓冲区进行常规的映射操作。</p><p>另加一个IO线程，向目前没有使用的输入输出缓冲区填充&#x2F;释放数据。</p><p>当主线程完成操作，等待缓冲区时，直接交换缓冲区。</p><p><img src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/img/image-20220611220755064.png" alt="双缓冲"></p><p><img src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/img/image-20220611220804636.png" alt="双缓冲(翻转后)"></p><h4 id="2-Way"><a href="#2-Way" class="headerlink" title="2-Way"></a>2-Way</h4><p>Pass 0：</p><p>读取一个数据页，排序并写入。</p><p>只使用一个缓冲区。</p><p>重复类似步骤，将整个文件包含的数据页写入，并保证每一页有序。</p><p>Pass 1，2，3 …:</p><p>至少需要3个缓冲区（假设每个缓冲区的大小为一个数据页）</p><p>将两个输入缓冲区的数据进行归并排序传给输出缓冲区。</p><blockquote><p>2-Way External sort</p></blockquote><p>拥有&gt;3个缓冲区</p><p>Pass 0:</p><p>使用B个缓冲区，每次导入B页数据，总共需要N&#x2F;B（上取）个runs，每一个runs里运行一个排序进程。</p><p>Pass 1：</p><p>每个runs的数据长度为B，本轮可以进行B-1个runs的归并</p><p><img src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/img/image-20220611224041793.png" alt="2路外部归并流程"></p><p>因此在Pass 1可以完成B(B-1) pages数据的排序。</p><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>将数据分批读取到内存中，在进行hash操作。</p><p>两步骤：</p><ol><li><p>Divide</p><p>使用哈希函数hp将记录流传递到指定的磁盘分区</p><p>满足匹配条件的都处在同一分区，确保具有同样特征的值不会在内存中被不同的哈希表计算（去除冗余）。</p><p><img src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/img/image-20220611230629236.png" alt="磁盘内分块"></p></li><li><p>Conquer</p><p>利用哈希函数hr，将分区读取到RAM的hash表中</p><p>然后读取桶中的数据，并将它们回写到磁盘中</p></li></ol><p><img src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/img/image-20220611230641780.png" alt="内存中哈希"></p><p>若划分之后的数据块还是很大，则进行递归划分操作，满足条件后再进行Conquer。</p><h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><h3 id="关系操作符和查询规划"><a href="#关系操作符和查询规划" class="headerlink" title="关系操作符和查询规划"></a>关系操作符和查询规划</h3><p>假设有一查询<br>$$<br>𝜋_{sname}(𝜋_{sid}(𝜋_{bid}(𝜎_{color}&#x3D;’red’(Boats)) ⋈ Res) ⋈ Sailors)<br>$$<br>则其对应的数据流图为</p><p><img src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/img/database20220630213659.png"></p><p>其中每一条边都代表数据的流向</p><p>结点代表关系运算符</p><p>源代表某个关系</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>对于每一个关系运算符要做的操作都会有一个对应的迭代器。筛选传入数据流中符合条件的元素，再传递到下一个操作的迭代器中。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">iterator</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Iterator<span class="token operator">></span> inputs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>    tuple <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>init和next操作可以采取流式或批量算法</p><p>流式：每次调用只有少量，有限的工作。</p><p>批量：每次执行一系列的工作，在完成之前不会产生输出。</p><h4 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h4><pre><code>init(predicate):     child.init()    pred = predicate;    current = NULL;next():     while (current != EOF &amp;&amp; !pred(current))        current = child.next();    return current; close():     child.close()</code></pre><p>首先初始化自己的子结点，并装配断言</p><p>next():不断循环直至到达文件末尾或是当前字段满足断言条件</p><h4 id="Heap-Scan"><a href="#Heap-Scan" class="headerlink" title="Heap Scan"></a>Heap Scan</h4><p>该迭代器不可能有孩子，因为其处于最底层，负责从磁盘中读取指定关系的数据。</p><pre><code>init(relation):     heap = open heap file for this relation;    cur_page = heap.first_page(); // first page    cur_slot = cur_page.first_slot(); // first slot on that page    next():     if (cur_page == NULL) return EOF;  // End Of Fun    current = [cur_page, cur_slot]; // we will return this recordId    // advance the slot    cur_slot = cur_slot.next();    if (cur_slot == NULL) &#123;      // advance to next page, first slot      cur_page = cur_page.next();      if (cur_page != NULL)         cur_slot = cur_page.first_slot();    &#125;    return current;     close():     heap.close()</code></pre><h4 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h4><pre><code>init(keys):                // all of pass 0 in init, a blocking call    child.init()    repeatedly call child.next() and generate the sorted runs on disk, until child gives EOF    // set up for pass 1, assumes enough buffers to merge    open each sorted run file and load into input buffer for pass 1    next():              // pass 1 (assumes enough buffers to merge)    output = min tuple across all buffers    if min tuple was last one in its buffer, fetch next page from that run into buffer    return output (or EOF -- “End of Fun” -- if no tuples remain)close():     deallocate the runs files    child.close()</code></pre><p>首先初始化所有的子节点，确保他们以及准备好了下一步操作。然后获取子节点的所有数据，并照上一章所讲的排序方法进行第0轮排序。完成后将所有的数据载入缓冲区进行归并。</p><h4 id="Group-By"><a href="#Group-By" class="headerlink" title="Group By"></a>Group By</h4><pre><code>init(group_keys, aggs):    child.init()    cur_group = NULL;next():    result = NULL    do &#123;        tup = child.next();        if (group(tup) != cur_group) &#123; // New group!            if (cur_group != NULL)     // Form a result for current group                result = [cur_group, final() of all aggs]            cur_group = group(tup);            call init() on all the aggs        &#125;         call merge(tup) on all the aggs     &#125; while (!result);    return result;close():    child.close()</code></pre><p>这种实现方式的前提是已经完成排序。初始化参数是要分组的键和聚合函数</p><p>next()操作：</p><p>不断获取下一个数据，直到遇见不同组的数据</p><p>当碰到新的某一组数据，且不是碰到的第一个组时，宣告本轮分组完成，结果包含当前组以及聚合函数的结果。若是碰到的第一个组，就获取对应分组并开始聚合函数的计算。</p><p><img src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/img/database20220630221951.png"></p><p>以上就是一个完整的查询流程。整个过程都不需要将输出的数据存储到磁盘。所有迭代器的操作结果都会作为上一层的参数继续参与运算，元组流只需要留存在栈中。</p><h2 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h2><h3 id="Simple-Nested-Loop-Join"><a href="#Simple-Nested-Loop-Join" class="headerlink" title="Simple Nested-Loop Join"></a>Simple Nested-Loop Join</h3><p>简单嵌套循环，每次循环从驱动表中读取一行数据，然后扫描一遍被驱动表，添加满足条件的数据。</p><p>假设驱动表R有1000张数据页，每一页有100条数据</p><p>被驱动表S有500张数据页，每一页有80条数据</p><p>则开销为：</p><p>扫描一遍驱动表要1000次IO(IO操作的单位为数据页而非记录)，而对于R中每一条记录，都要扫描一遍S表，IO次数为100000 * 500</p><p>PS：若S为驱动表，开销为500 + 40000 * 1000，相对减少500次IO</p><h3 id="Page-Nested-Loop-Join"><a href="#Page-Nested-Loop-Join" class="headerlink" title="Page Nested-Loop Join"></a>Page Nested-Loop Join</h3><p>和SNL相比，每次从驱动表中获取一页数据，然后从被驱动表获取一页数据。将获取的两页数据先进行一次Join操作。</p><p>此时开销降低为 1000 + 1000 * 500(R为驱动表)</p><p>演化：Chunk Nested-Loop Join</p><p>一次IO从驱动表中获取几页数据，其余操作同上。</p><p>开销可降低为 1000 + (1000 &#x2F; N) * 500 N为一次性获取的页数，一般为缓冲区数-2</p>]]></content>
      
      
      <categories>
          
          <category> Remake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字节青训 | Go语言基本特质</title>
      <link href="/2022/06/30/coroutine/"/>
      <url>/2022/06/30/coroutine/</url>
      
        <content type="html"><![CDATA[<p>啥都听不懂的青训营 摸鱼笔记之Go语言基本特质</p><span id="more"></span><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>协程：用户态，轻量级线程，栈MB级别</p><p>线程：内核态，线程中可以运行多个协程，栈KB级别</p><h3 id="协程主要通信方式"><a href="#协程主要通信方式" class="headerlink" title="协程主要通信方式"></a>协程主要通信方式</h3><p>通过通信共享内存，类似生产者消费者模型</p><p><img src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/img/coroutine2022-05-08%2019-45-09%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="协程通信"></p><blockquote><p>Channel 通道</p></blockquote><p>make(chan 元素类型, [缓冲大小])</p><p>无缓冲通道又称为同步通道</p><p>适当的缓冲大小可以弥补生产者消费者执行速度不均衡的问题 </p><blockquote><p>同步</p></blockquote><p>​可使用lock,WaitGroup实现同步。</p><h2 id="Go的依赖管理"><a href="#Go的依赖管理" class="headerlink" title="Go的依赖管理"></a>Go的依赖管理</h2><h3 id="1-GoPath"><a href="#1-GoPath" class="headerlink" title="1. GoPath"></a>1. GoPath</h3><blockquote><p>结构</p></blockquote><ul><li><p>bin: 项目编译的二进制文件</p></li><li><p>pkg: 项目编译的中间产物，加速编译</p></li><li><p>src: 项目源码</p><p>项目代码直接依赖于src下的源码</p><p>缺陷：无法处理项目代码依赖不同版本的情况</p></li></ul><h3 id="2-GoVendor"><a href="#2-GoVendor" class="headerlink" title="2. GoVendor"></a>2. GoVendor</h3><p>项目目录下新增vendor文件，所有依赖包副本形式放在$ProjectRoot&#x2F;vendor</p><p>依赖寻址：有先到vendor下，再到GoPath下</p><p>问题：</p><ul><li>无法控制依赖版本</li><li>更新项目又可能出现依赖冲突，导致编译出错。</li><li>本质：仍旧依赖的是源码，无法通过版本分辨</li></ul><h3 id="3-Go-Module"><a href="#3-Go-Module" class="headerlink" title="3. Go Module"></a>3. Go Module</h3><p>通过go.mod文件进行版本管理</p><blockquote><p>依赖管理三要素</p></blockquote><pre><code> 1. 配置文件，描述依赖   go.mod 1. 中心仓库管理依赖库       Proxy 1. 本地工具                         go get/mod</code></pre><p>对于所需要的不同版本的依赖，go会采取最低兼容版本算法。</p><blockquote><p>依赖分发-Proxy</p></blockquote><p>在源站与目标之间加一层代理，代理缓存源站中的依赖</p><p><img src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/img/coroutine2022-05-08%2020-34-11%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"></p><p><img src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/img/coroutine2022-05-08%2020-34-35%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"></p><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h3 id="1-规则"><a href="#1-规则" class="headerlink" title="1. 规则"></a>1. 规则</h3><p>所有测试文件以_test.go结尾</p><p>函数命名：func Testxx(*testing.T)</p><p>初始化逻辑放到TestMain中</p><h3 id="2-mock"><a href="#2-mock" class="headerlink" title="2. mock"></a>2. mock</h3><p>模仿真实对象行为的模拟对象</p><p>mock模拟的不是测试对象而是<strong>测试对象的依赖</strong></p><p>Why？</p><ul><li>(1)提高 A 的测试覆盖率。A 依赖 B，本质上依赖的是 B 的返回结果，也就是说 B 的返回结果会影响 A 的行为。通过 mock B 我们可以构造各种正常和异常的来自 B 的返回结果，从而更充分测试 A 的行为。</li><li>(2)避免 B 的因素从而对 A 产生影响。依赖真实的 B 去测试 A 可能有很多问题：B 的开发没有完成时无法测试 A;B 有阻塞性bug 时无法测试 A;B 的依赖 C 有阻塞性 bug 时无法测试 A;</li><li>(3)提高 A 的测试效率。B 的真实行为可能很慢，而 B 的模拟行为是非常快的，因此可以加快 A 的测试执行速度。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 青训摸鱼笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字节青训 | 架构</title>
      <link href="/2022/06/30/Architecture/"/>
      <url>/2022/06/30/Architecture/</url>
      
        <content type="html"><![CDATA[<p>啥都听不懂的青训营 摸鱼笔记之架构</p><span id="more"></span><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p>架构的定义</p><ul><li>是有关软件整体结构与组件的抽象描述</li><li>用于指导软件系统各个方面的设计</li></ul><h2 id="架构的演进"><a href="#架构的演进" class="headerlink" title="架构的演进"></a>架构的演进</h2><h3 id="单机"><a href="#单机" class="headerlink" title="单机"></a>单机</h3><p>把所有功能都实现在一个进程里，并部署在一台机器上</p><p>优点：简单</p><p>缺点：能提供的服务有限，运维需要停服。</p><h3 id="单体、垂直应用-垂直切分"><a href="#单体、垂直应用-垂直切分" class="headerlink" title="单体、垂直应用 | 垂直切分"></a>单体、垂直应用 | 垂直切分</h3><p>单体架构：分布式部署</p><p>垂直应用架构：按应用垂直切分的单体</p><p>优点：水平扩容，运维不需要停服</p><p>缺点：职责太多，开发效率不高。爆炸半径大（个体出现问题，容易导致整条链停摆）</p><p><img src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/img/architecture2022-05-22%2021-51-39%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="单体架构"></p><h3 id="SOA"><a href="#SOA" class="headerlink" title="SOA"></a>SOA</h3><p>service-oriented architecture</p><ol><li>将应用的不同功能单元抽象为服务</li><li>定义服务之间的通信标准（核心要点）</li></ol><p><img src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/img/architecture2022-05-22%2022-07-28%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="SOA"></p><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>SOA的去中心化演进方向</p><p><img src="https://raw.githubusercontent.com/FaustProMaxPX/pic_repository/main/img/architecture2022-05-22%2022-09-21%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="微服务"></p><p>问题：</p><ul><li>数据一致性</li><li>高可用，不同服务之间如何高效交互</li><li>治理，如何容灾</li><li>解耦 vs 运维  收益是否大于提高的运维成本</li></ul>]]></content>
      
      
      <categories>
          
          <category> 青训摸鱼笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java</title>
      <link href="/2022/06/29/Java/"/>
      <url>/2022/06/29/Java/</url>
      
        <content type="html"><![CDATA[<p>一份关于Java基本操作的笔记</p><span id="more"></span><h1 id="Java随记"><a href="#Java随记" class="headerlink" title="Java随记"></a>Java随记</h1><h2 id="面向过程编程"><a href="#面向过程编程" class="headerlink" title="面向过程编程"></a>面向过程编程</h2><p>同一个模块或不同模块的函数能够不受限制的访问全局性数据，全局数据和函数之间缺乏联系</p><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>在程序中包含各种独立而又互相调用的对象的思想。将数据与对数据的操作封装到一个数据类型之中，该数据类型又可以与其他数据类型进行交互。</p><h3 id="2-优势"><a href="#2-优势" class="headerlink" title="2.优势"></a>2.优势</h3><ul><li>加大封装力度  若在程序投入使用后，部分数据结构必须改变，那么受影响的也只是对象内部的逻辑。</li><li>提升复用性</li><li>提高设计效率</li></ul><h3 id="3-类与对象"><a href="#3-类与对象" class="headerlink" title="3.类与对象"></a>3.类与对象</h3><p>Classes：定义了一件事物的抽象特点。包含了数据以及对数据的操作</p><p>Objects：类的实例</p><h3 id="4-类与类之间的关系"><a href="#4-类与类之间的关系" class="headerlink" title="4.类与类之间的关系"></a>4.类与类之间的关系</h3><ul><li>依赖关系：一个类使用或知道另一个类。是一种瞬时关系，依赖类和目标类进行简单的交互</li><li>关联关系：一个类在很长一段时间内都会与另一个类有合作关系<ul><li>关联关系的三要素：关联的方向、关联的数量、关联的属性</li></ul></li><li>继承关系</li></ul><h3 id="5-对象的创建"><a href="#5-对象的创建" class="headerlink" title="5.对象的创建"></a>5.对象的创建</h3><p>对象变量的声明：在栈中为对象变量分配一个存储地址数据的内存空间</p><p>对象的创建：在堆中分配对象所占的空间，对象变量指向该地址</p><p>对象的销毁：当程序中不存在该对象的引用时，就会销毁</p><h2 id="Java包"><a href="#Java包" class="headerlink" title="Java包"></a>Java包</h2><p>包用于组织、管理类，并且解决类命名冲突问题</p><p>若一个源文件中不加package语句，则指定为缺省包，类文件位于当前工作目录下</p><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>三元运算符所在表达式会成为一个整体，其精度会由式中最高精度决定。</p><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>语法: ReturnType funName(TypeName…varName)<br><strong>本质是数组</strong><br>可变参数必须在参数列表的最后一个，并且只能有一个可变参数。</p><h2 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h2><p>1.访问父类的属性但不能访问父类的私有属性：super.属性名&#x2F;方法名<br>2.访问父类的的构造器：super(参数列表)</p><h2 id="动态绑定机制"><a href="#动态绑定机制" class="headerlink" title="动态绑定机制"></a>动态绑定机制</h2><p>当调用对象方法时，该方法会和该对象的<strong>内存地址&#x2F;运行类型</strong>绑定<br>当调用对象属性时，<strong>没有动态绑定</strong>.</p><p><strong>类的五大成员：属性，方法，代码块，构造器，内部类</strong></p><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>static代码块作用就是对类进行初始化，并且它随着<strong>类的加载</strong>而执行，并且只<strong>执行一次</strong>，而普通代码块每创建一个对象就会执行（可以理解为它和构造函数绑定）</p><p><strong>类什么时候被加载</strong><br>1.创建对象实例的时候(new)<br>2.子类被加载时，父类也会被加载。<br>3.使用静态成员时（静态属性和方法） PS:调用静态成员时不会执行普通代码块中的内容</p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>定义：一个类的内部又完整的嵌套了另一个类结构，被嵌套的类称为内部类。<br>特点：可以直接访问私有属性，并且可以体现类与类之间的包含关系。</p><p><strong>内部类的构造器的第一个参数会被显示指定为外部类实例（锚定）</strong></p><p>分类：<br>1.定义在外部类局部位置上（比如方法内）：<br>1)局部内部类（有类名）<br>2)<strong>匿名内部类（没有类名）</strong><br>2.定义在外部类的成员位置上：<br>1)成员内部类（没用static修饰）<br>2)静态内部类（用static修饰）</p><p><strong>局部内部类，匿名内部类的实质是一个对象，一个局部变量，因此不能被外部其他类访问。</strong></p><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>1.可以直接访问外部类的所有成员（包含所有的）<br>2.不能被修饰符所修饰，因为他本质是一个局部变量<br>3.作用域：仅在定义它的方法与代码块中。<br>4.外部其他类不能访问局部内部类。<br>5.若外部类和局部内部类的成员重名时，采取<strong>就近原则</strong>,若要调用外部类成员则要使用<br>外部类名.this.成员 （re：对应成员并非静态变量，需要用对象来调用，此时this相当于指向该外部类的当前对象）</p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>语法：new 类或接口(参数列表){具体实现} （若实现某个接口则不需要传入参数列表，参数列表会被传递给构造器。） PS:生成的匿名内部类的运行类型不是实现的类或接口。<br>使用环境：类或接口中的抽象方法需要被实现来使用或是要重载重写，但使用次数极少，此时使用匿名内部类可避免额外再创建一个类。</p><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>外部其他类访问内部类：<br>1.外部类.内部类 name &#x3D; 外部类<strong>对象</strong>.new 内部类构造函数<br>2.在外部类中写一个获取内部类的方法<br>3.作用域：整个类体</p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>1.可以访问任意静态外部类成员<br>2.外部其他类访问静态内部类：外部类.内部类 name &#x3D; new 外部类.内部类构造函数 (静态内部类不需要用外部类的对象来调用，因此其构造函数可用外部类名调用)</p><h2 id="接口-纯虚基类"><a href="#接口-纯虚基类" class="headerlink" title="接口(纯虚基类)"></a>接口(纯虚基类)</h2><p>1.接口不能被实例化<br>2.接口中所有的方法是public抽象方法, 其中abstract可以省略<br>3.一个普通类实现接口，就必须将该接口中的所有方法都实现，而抽象类可以不必全部实现<br>4.接口中的属性都是final的, 且具体来说是public static final类型的  eg:int a -&gt; public static final int a 即接口中的属性通过接口名来访问。<br>5.接口只能继承其他接口，而非实现其他接口</p><h3 id="接口与继承的区别"><a href="#接口与继承的区别" class="headerlink" title="接口与继承的区别"></a>接口与继承的区别</h3><p>继承的价值主要在于：解决代码的复用性和可维护性<br>接口的价值主要在于：设计，设计好各种规范（方法），让其他类去实现这些方法，更加灵活<br><strong>继承满足的是is-a的关系，而接口满足的是like-a的关系</strong><br>接口在一定程度上实现代码解耦。</p><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>关键字：enum<br>enum的代码块中包含：枚举类<strong>对象</strong>，枚举类的构造函数，方法，属性，代码块<br>其中枚举类的对象必须声明再最开始，且其中每一个对象默认被public static final修饰<br>方法compareTo()会比较两个枚举量的编号<br>方法ordinal()返回编号<br>构造器默认为私有，且只能为私有<br>会隐式继承Enum类，因此不能继承其他类。</p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>注解用于修饰解释 包、类、方法、属性、构造器、局部变量等数据信息。<br>注解不影响程序逻辑，但<strong>注解可以被编译或运行</strong>。</p><p>@Override注解：表明以下方法是被重写的，编译器编译时会去父类搜索是否有同名方法，若检测到没有该方法，则会报错。<br>作用域：方法</p><p>@Deprecated注解：表明以下内容已经过时，不推荐使用<br>作用域：方法、类、字段、包、参数等等</p><p>@SupressWarnings注解：抑制编译器警告<br>语法：@SupressWarnings({要抑制的警告})<br>作用域：方法、类、字段、包、参数等等</p><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>装箱：底层是valueOf()<br>拆箱：底层是XXXValue()</p><p>PS:valueOf()底层原理：程序会缓存一个-128-127的数组，因此在这个范围内的数不会重新创建一个对象，但对于超出该范围的数则会返回一个new的对象</p><h3 id="String类-不可修改，但复用率高"><a href="#String类-不可修改，但复用率高" class="headerlink" title="String类(不可修改，但复用率高)"></a>String类(不可修改，但复用率高)</h3><p>String类实现了Serializable(序列化), Comparable(可比较)接口。<br>字符串使用Unicode编码，每个字符占两个字节。<br><strong>String类用一个value数组存储字符序列，并且它被final修饰，即其地址不可修改</strong>。<br><strong>re:数组本身是一个地址，因此final其实修饰了一个地址，即String的value中的值可以改变，但其地址不可变。</strong></p><p>String的赋值方法:<br>String s1 &#x3D; “abc” <strong>底层原理：变量s1入栈，然后去常量池中寻找是否有”abc”，若没有，则在常量池中创建，然后s1指向常量池中目标的地址。</strong><br>String s2 &#x3D; new String(“abc”) <strong>底层原理：变量s2入栈，然后在堆中开辟一块空间用于维护对象，s2指向该空间，然后去寻找常量池中是否有”abc”,若有，则value直接指向它，若没有，则在常量池中先创建，然后value再指向。</strong></p><p>intern()方法：若池中已存在一个等于String对象value值（用equal比较）的对象，则返回常量池中的地址，若没有则在池中创建一个再返回。</p><p>String a &#x3D; “a” + “b” 会被编译器优化为：String a &#x3D; “ab”</p><p>String a &#x3D; “a”; String b &#x3D; “b”; String c &#x3D; a + b; 先创建一个StringBuilder类，然后调用两次append() [分别把字符串a和字符串b连入SB对象]，最后返回一个字符串对象。<br>最后 a-&gt;堆中对象-&gt;池中对象</p><p><strong>String每次重新赋值都会重新开辟空间</strong><br><strong>String本身不可像数组一样访问，要用charAt进行访问。</strong><br>substring的参数为(int beginindex, int lastindex)前闭后开<br>replace对调用对象没有影响，它会返回一个新的字符串。<br>compareTo：若两字符串长度不同且在较小长度范围内相等，则返回长度差值，否则会返回第一组不相同的字符的ASCII码差值。<br>format静态方法（和printf用法类似）</p><h3 id="StringBuffer类（可增删，效率较高，线程安全）"><a href="#StringBuffer类（可增删，效率较高，线程安全）" class="headerlink" title="StringBuffer类（可增删，效率较高，线程安全）"></a>StringBuffer类（可增删，效率较高，线程安全）</h3><p>StringBuffer的直接父类是AbstractStringBuilder<br>在父类中有属性char[] value,不是final修饰的，因此该value指向一个<strong>存放在堆中</strong>的字符串<br>StringBuffer是一个final类。</p><h4 id="String-gt-StringBuffer"><a href="#String-gt-StringBuffer" class="headerlink" title="String -&gt; StringBuffer"></a>String -&gt; StringBuffer</h4><p>1.StringBuffer strB &#x3D; new StringBuffer(str);<br>2.StringBuffer strB &#x3D; new StringBuffer();  strB &#x3D; strB.append(str)  append)()会返回当前对象的指向</p><h3 id="StringBuilder（可增删，效率最高，线程不安全）"><a href="#StringBuilder（可增删，效率最高，线程不安全）" class="headerlink" title="StringBuilder（可增删，效率最高，线程不安全）"></a>StringBuilder（可增删，效率最高，线程不安全）</h3><p>与StringBuffer地API兼容，是它的一个简易替换，但<strong>线程不安全</strong>，在单线程情况下建议使用。</p><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p>有SimpleDateFormat类可以与其配套使用<br>SimpleDateFormat用于初始化的参数为日期的格式（字符串）<a href="https://www.runoob.com/java/java-date-time.html">日期时间的格式化代码</a><br>SimpleDateFormat中有方法format可以使日期时间按要求输出<br>parse方法可以用来将字符串转为日期格式（要与其自身格式相符合）（有异常需要处理）</p><h3 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h3><p>Calendar是一个抽象类，且其构造器是私有的，需要用getInstance来获取实例</p><h3 id="LocalDateTime-LocalDate-LocalTime"><a href="#LocalDateTime-LocalDate-LocalTime" class="headerlink" title="LocalDateTime LocalDate LocalTime"></a>LocalDateTime LocalDate LocalTime</h3><p>LocalDateTime获取年月日时分秒 LocalDate获取年月日 LocalTime获取时分秒<br>DateTimeFormatter用于对它进行格式化<br>DateTimeFormatter dtf &#x3D; DateTimeFormatter.ofPattern(“格式”)</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>规则 :<br>所有泛型方法都有一个类型参数声明部分，声明在方法返回类型之前<br>类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数占位符<br>类型参数只能代表<strong>引用类型</strong><br>在指定类型参数后可以传入该类型或其子类型，默认情况下会给Object类型</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>泛型类： class 类名 &lt;&gt;</p><ul><li>普通成员可以使用泛型（属性、方法）</li><li>使用泛型的数组不能初始化（类型不确定，开辟的空间大小未知）</li><li>静态方法中不能使用类的泛型（静态方法会跟着类的加载进行加载，而当时类的泛型尚未确定），但可以使用方法的泛型</li><li>泛型类的类型，是在创建对象时确定的</li></ul><p>泛型接口：interface 接口名 &lt;&gt;</p><ul><li>静态成员不能使用泛型</li><li>泛型接口的类型参数，在<em>继承接口</em>或<em>实现接口</em>时确定</li></ul><p>泛型方法：&lt;&gt; 返回类型 函数名()</p><ul><li>可以定义在普通类或泛型类中</li><li>泛型被调用时类型会被确定，即对应的类型参数会被绑定到对应类型，但调用结束后会取消绑定。</li></ul><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>规则:在类名后声明类型参数</p><h3 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h3><p>一般使用？代替具体的类型参数<br>类型通配符上限:<br>&lt;? extends class&gt; 泛型参数只能是class子类.<br>类型通配符下限:<br>&lt;? super class&gt; 泛型参数只能是class父类.</p><h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><p>主要包含两种类型的容器：<br>1.Collection 存储一个元素集合 其下有两重要子集 List Set（Collection没有直接实现子类，而是通过子接口实现）<br>2.Map 存储键&#x2F;值对映射</p><p><strong>在集合中存储的均为对象的引用，因此若在插入集合后对元素进行修改可能会影响删除操作</strong><br>例如在HashSet中，若修改与计算hash值有关的对象属性，则可能会导致删除不成功，因为修改前与修改后生成的hash值不同</p><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><h4 id="Set和List"><a href="#Set和List" class="headerlink" title="Set和List"></a>Set和List</h4><p>Set接口的存储是无序的，不重复的数据。List接口实例存储的是有序的，可重复的元素<br>Set检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变<br>List和数组类似，可以动态增长，根据实际存储的数据的长度自动增长，查找效率高，插入删除效率低。</p><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>ArrayList底层是用<strong>数组</strong>来实现的<br>ArrayList与Vector之间的区别就是ArrayList是<strong>线程不安全</strong>的。<br>ArrayList中维护了一个Object类型的数组 transient Object[] elementData</p><h5 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h5><p>若使用无参构造器来创建，则初始化容量为0，第一个元素添加时，将容量扩展至10，此后如需再次扩容，则扩容为当前容量大小的1.5倍。<br>若使用指定容量的构造器，则之后扩容时，直接1.5倍。<br>扩容使用的是Arrays.copyOf()</p><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>Vector底层是 protected Object[] elementData<br>Vector<strong>线程安全</strong><br>扩容机制：<br>如果是无参，默认10，满后按2倍扩。若有参，直接按2倍扩。</p><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>底层实现了双向链表和双端队列<br>可以添加任意元素<br>线程不安全</p><h4 id="Java-Iterator"><a href="#Java-Iterator" class="headerlink" title="Java Iterator"></a>Java Iterator</h4><p>iterator本身不存储数据，只用于遍历集合<br>迭代器可以类比为有头结点的链表<br>迭代器it三个基本操作：next, hasNext, remove<br>it.next() 返回下一个元素（Object），并且更新迭代器的状态<br>it.hasNext()用于检测集合中是否还有元素<br>it.remove() 将迭代器返回的元素删除 remove掉的是当前指向的元素，而非next元素</p><p>获取迭代器：集合想获取一个迭代器可以使用iterator()方法</p><p><strong>增强for的底层就是迭代器。</strong></p><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>底层机制：<br>1.底层是HashMap <strong>用邻接表实现</strong>他的装载因子默认是0.75<br>2.添加一个元素时，先得到hash值，然后转成索引值<br>3.找到存储数据的表table，检查当前位置是否已经存放了元素<br>4.如果没有数据就直接插入，<br>   如果有数据，调用<strong>equals（调用的是当前对象的equals）</strong>比较，如果相同，则放弃添加，如果不相同就添加到最后。<br>5.若一条链表的元素个数超过TREEIFY_THRESHOLD(默认为8)，并且table的大小&gt;&#x3D;MIN_TREEIFY_CAPACITY(默认为64)，就会进行树化（红黑树），若链表个数超限，而表空间充足，则优先将表扩容(每次容量都*2)。</p><p>add详细过程：<br>首先检查是否为空表，若为空表，则将其大小初始化为16<br>接着用插入对象的hashCode计算hash值（hashCode和hash值不一样）<br>然后用hash值计算得到对应的数据表中的索引<br>如果对应索引为空，则new一个Node直接插入<br><strong>如果对应索引不为空：<br>(1)若插入位置已有对象的hash于插入对象的hash相同，且满足键值相同（即对象地址）或是调用当前对象的equals方法得到true则不插入<br>(2)若p为树节点，则调用红黑树的对应方法<br>(3)进入表中对应索引的链表，依次比较（方法同情况（1）相同）在插入完成后立即判断当前结点数是否达到8，若达到则进行树化（实际上在table表元素个数到64的情况下才会真的树化）</strong><br>当结点数&gt;0.75*容量时，扩容</p><h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><p>底层维护一个<strong>数组+双向链表</strong><br>双向链表结点 Entry 内含元素：before，after，数据<br>表中元素为：head, tail, table, entrySet<br>双向链表使得LinkedHashSet具备插入顺序与遍历顺序相同的特征，每一次插入，首先会找到对应hash值的索引的首个结点，然后从该节点开始沿着双向链表一个个比较，因此相比HashSet效率偏低。总结：双向链表将原本分布在table各索引中的结点串成了一串。</p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>table:HashMap$Node[]<br>Map中的key和value可以是任何<strong>引用类型</strong>的数据，会封装到HashMap$Node(实现Entry接口)<br>Map中的key不允许重复（具体去重操作同HashSet），若插入重复key，则后插入的value会覆盖之前的，且为null的key只能有一个，且会将被覆盖的value返回。<br>Map中的value可以重复<br>Map会维护一个entrySet用于方便遍历Map中的数据，其中的Entry是Node的父类，并且提供getKey和getValue方法，<strong>存储的是表中数据的地址</strong>。<br>HashMap线程不安全。</p><h4 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h4><p>key和value都<strong>不能为null</strong><br>线程安全<br>使用方法同HashMap一样<br>底层：维护一个数组HashTable$Entry[] table 初始化大小为11<br>每次扩容将当前大小*2 + 1</p><h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h4><p>继承了HashTable，且实现了Map接口</p><h4 id="TreeSet（带Tree的都可以排序）"><a href="#TreeSet（带Tree的都可以排序）" class="headerlink" title="TreeSet（带Tree的都可以排序）"></a>TreeSet（带Tree的都可以排序）</h4><p>本质是二叉搜索树，其迭代器使用中序遍历<br>若用无参构造器创建TreeSet则其依旧是无序的，若要排序，需要传入一个Comparator对象<br>对<strong>键值</strong>调用比较方法（键值不可为空）<br>TreeSet的去重机制，调用构造时传入的Comparator对象进行比较，<strong>若没有传入，则会调用插入对象实现的Comparator接口，若没有实现会报错，因为在底层会尝试将传入对象转变为Comparable对象</strong></p><h4 id="Collection工具类"><a href="#Collection工具类" class="headerlink" title="Collection工具类"></a>Collection工具类</h4><p>reverse(Collection):反转集合中元素<br>shuffle(Collection):将元素随机排列<br>sort(Collection, [Comparator]):排序 默认从小到大<br>max(Collection, [Comparator])<br>min(Collection, [Comparator])<br>swap(Collection, int, int) :交换元素<br>frequency(Collection, Object):返回某元素出现次数<br>copy(Collection dest, Collection src):将src中的数据拷贝到dest中，前提是dest的大小不小于src的大小<br>replaceAll(List, Object oldVal, Object newVal)</p><h2 id="绘图技术"><a href="#绘图技术" class="headerlink" title="绘图技术"></a>绘图技术</h2><p>1.先定义一个MyPanel类，继承JPanel类（MyPanel相当于画盘，其中paint方法的参数Graphics相当于画笔，带有很多画图方法）<br>2.让用于画图的类继承JFrame（一个框架，表示Graphics画图的界面）</p><h3 id="绘图原理"><a href="#绘图原理" class="headerlink" title="绘图原理"></a>绘图原理</h3><p>Component类提供了两个和绘图相关最重要的方法<br>1.paint(Graphics g)绘制组件外观<br>2.repaint()刷新组件外观</p><p>当组件<strong>第一次在屏幕显示的时候</strong>，程序会自动地调用paint()方法<br>在以下情况，paint()也会被调用：</p><ul><li>窗口最小化，再最大化</li><li>窗口的大小发生变化</li><li>repaint函数被调用</li></ul><p>获取图片资源<br>Image image &#x3D; Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(“图片所在路径（要放在项目的根目录下）”))</p><h2 id="Java事件处理机制"><a href="#Java事件处理机制" class="headerlink" title="Java事件处理机制"></a>Java事件处理机制</h2><p>java事件处理是采取“委派事件模型”。当事件发生时，<em>产生事件的对象，会把此“信息”传递给“事件的监听者”处理</em>，这里所说的“信息”实际上就是java.awt.event事件库里某个类所创建的对象。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是指运行中的程序，启动一个进程后，操作系统就会为该进程分配内存空间<br>进程是指程序的<strong>一次执行过程</strong>，或是正在运行的一个程序，是动态过程<br>只有进程中的所有线程全部死亡时，线程才会死亡</p><h3 id="线程-1"><a href="#线程-1" class="headerlink" title="线程"></a>线程</h3><p>线程是由进程创建的，是进程的一个实体。<br>一个进程可以拥有多个线程。</p><p>单线程：同一个时刻，只允许进行一个线程<br>多线程：同一个时刻，允许执行多个线程</p><p>并发：同一个时刻，多个任务<strong>交替进行</strong>， 单核CPU实现的多任务就是并发<br>并行：同一个时刻，多个任务同时执行，多核CPU可以实现并行</p><p>用户线程：当线程的任务执行完成或被通知结束时结束<br>守护线程：一般是为工作线程服务，当所有的用户线程结束时，守护线程自动结束<br>常见的守护线程：垃圾回收机制<br>将一个线程设置为守护线程：调用setDaemon() </p><p>JVM在所有非守护线程退出后退出</p><h4 id="线程的礼让与插队"><a href="#线程的礼让与插队" class="headerlink" title="线程的礼让与插队"></a>线程的礼让与插队</h4><p>yield:线程礼让，让出CPU，让其他线程执行，但礼让的事件不确定，所以也不一定礼让成功（当系统认为CPU资源充足时不会礼让）<br>join:线程插队，插队的线程一旦插队成功，则肯定先执行完插入的线程所有任务</p><h4 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h4><ul><li>新建状态：使用new关键字和Thread类或其子类建立一个线程对象后，该线程对象就处于新建状态，它保持这个状态直到程序start()这个线程</li><li>就绪状态：当线程对象调用了start()方法之后，该线程就进入就绪状态，此时线程处于就绪队列中，等待JVM里线程调度器的调度 <strong>实现多线程的核心</strong></li><li>运行状态：就绪状态的线程获取CPU资源，就可以执行run()，此时它就处于运行状态，<em>它可以变为阻塞状态，就绪状态和死亡状态</em> run()只是一个普通方法</li><li>阻塞状态:<br>如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：<ul><li>等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。</li><li>同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。</li><li>其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I&#x2F;O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I&#x2F;O 处理完毕，线程重新转入就绪状态。</li></ul></li><li>死亡状态</li></ul><h4 id="用Runnable接口创建线程"><a href="#用Runnable接口创建线程" class="headerlink" title="用Runnable接口创建线程"></a>用Runnable接口创建线程</h4><p>创建一个实现了Runnable接口的类，并实现run()，然后将其作为参数调用Thread的构造函数，用创建的thread类来调用start()<br>实现Runnable接口方式更加适合多个线程共享一个资源的情况，并且避免了单继承的限制。</p><h4 id="线程常用方法"><a href="#线程常用方法" class="headerlink" title="线程常用方法"></a>线程常用方法</h4><p>setName 设置线程名称<br>getName 返回线程名称<br>setPriority 更改线程优先级<br>getPriority 获取线程的优先级<br>interrupt 中断线程</p><h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><p>用synchronized修饰需要上锁的对象，使得该对象在任意时刻只能由一个线程访问<br>锁可以简单理解为一个标记对象，当该对象处于调用状态时代表别的线程此刻不能进行相关操作<br>同步方法&#x2F;代码块（非静态的）的锁可以是this，也可以是其他属性对象（要求各线程能接触到的锁是同一个对象）<br>同步方法&#x2F;代码块（静态的）的锁就是对象本身</p><h4 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h4><ul><li>当前线程的同步方法、同步代码块执行结束</li><li>当前线程在同步代码块中遇到break，return</li><li>当前线程在同步代码块，同步方法中出现了未处理的Error或Exception导致异常结束</li><li>当前线程在同步代码块，同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁</li></ul><p>注：当线程执行同步代码块或同步方法时，程序调用Thread.sleep()或yield()不会释放锁</p><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>文件在程序中是以<em>流的形式</em>来操作<br>流：数据在数据源（文件）和程序（内存）之间经历的路径<br>输入流：数据从数据源（文件）到程序（内存）的路径<br>输出流：数据从程序（内存）到数据源（文件）的路径</p><p>流的分类：<br>按操作数据单位：字节流（8bit）二进制文件，字符流（按字符）文本文件<br>按数据流的流向：输入流，输出流<br>按流的角色：节点流，处理流&#x2F;包装流</p><p>字节流: InputStream OutputStream<br>字符流:Reader Writer</p><p><strong>所有用到缓冲区的输出流每次写入完成后要刷新才能将数据写入</strong></p><p>PS:在不需要流之后要将其关闭，避免资源浪费。</p><h3 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h3><p>节点流：可以从一个<strong>特定</strong>的数据源读写数据<br>处理流：可以从<strong>任意</strong>数据源读写数据，并且自带缓冲  一般前缀为Buffered</p><p>处理流的构建：在构建时向其传入一个节点流，即可使其同时具备对应节点流与处理流带有的扩充功能。<br>关闭处理流：只需关闭外层流即可，内部的节点流会在close方法中被关闭<br><em>BufferedReader&#x2F;BufferedWriter不适合处理二进制文件</em></p><p>System.in 表示标准输入 键盘<br>编译类型：InputStream<br>运行类型：BufferedInputStream</p><p>System.out 表示标准输出 显示器<br>编译类型：PrintStream<br>运行类型：PrintStream</p><h4 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h4><p>可以将读取到的字节数据经过指定编码转换成字符 InputStreamReader<br>可以将读取到的字符数据经过指定编码转换成字节 OutputStreamWriter</p><p>应用场景:</p><ul><li>源或者目的对应的设备是字节流，但是操作的却是文本数据</li><li>操作文本涉及到具体的指定编码表</li></ul><p>打印流：PrintWriter, PrintStream(只有输出没有输入)</p><h2 id="Java序列化"><a href="#Java序列化" class="headerlink" title="Java序列化"></a>Java序列化</h2><p>机制:<br>一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型<br>将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化(读取顺序必须和存储顺序一致)<br>类ObjectInputStream和ObjectOutputStream是高层次的数据流，他们包含反序列化和序列化对象的方法。</p><p>一个类的对象要想序列化成功，必须满足两个条件:<br>1.该类必须实现java.io.Serializable接口<br>2.该类的所有属性必须是可序列化的，如果有一个属性不是可序列化的，则该属性必须注明是短暂的。</p><p>注意事项：</p><ul><li>存储与读取的顺序必须一致</li><li>static或transient修饰的属性不会被序列化</li><li>序列化对象时，要求内部的属性也实现序列化接口</li></ul><p><a href="https://www.runoob.com/java/java-serialization.html">序列化知识</a></p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><ul><li>定义：能够分析类能力的程序称为反射</li><li>作用：<br>1.在运行时分析类的能力<br>2.在运行时查看对象<br>3.实现通用的数组操作代码<br>4.利用Method对象</li><li>价值：在不修改源码的情况下，增加、修改功能</li><li>原理：JVM将类的字节码文件通过类加载器生成Class类对象存放在堆中（每个类只生成一个）</li></ul><h3 id="2-常用类"><a href="#2-常用类" class="headerlink" title="2.常用类"></a>2.常用类</h3><p>java.lang.reflect包中有三个类</p><ul><li><p>Field 用于描述类的域</p></li><li><p>Method 用于描述类的方法</p></li><li><p>Constructor 用于描述类的构造器</p><p>（具体内容详见java核心技术P194）</p></li></ul><p><em>私有属性，方法，构造器，不可通过对应的getXXX()获得</em></p><h4 id="2-1Class类"><a href="#2-1Class类" class="headerlink" title="2.1Class类"></a>2.1Class类</h4><p>在程序加载完类之后，会调用ClassLoader创建该类的一个Class对象，并将其存储在堆中，其中保存了该类的所有信息。<strong>（每一个类只会创建一个Class对象）</strong></p><p>同时会在方法区存储类的二进制数据</p><p><em>PS:一个Class对象实际上表示的是一个类型，而这个类型未必一定是一种类（也有可能是原始数据类型 ，eg:int.class就是一个Class类，但int不是一个类）</em></p><p>newInstance()可用于动态的创建一个类的实例,他调用<strong>默认的</strong>构造器初始化新创建的对象。</p><pre class=" language-Java"><code class="language-Java">`eg:` `String s = "java.util.Random";``Object m = Class.forName(s).newInstance();`</code></pre><p>调用有参构造器</p><pre><code>Class cls = Class.getForName(&quot;Cat&quot;);Constructor constructor = cls.getConstructor(String.class);//获取构造器，参数为获取的构造器需要的参数的Class类Object o1 = constructor.newInstance(&quot;Cat&quot;);</code></pre><p><em>注意：在反射中都是用方法调用对象,若有返回值，则只会返回Object</em></p><pre class=" language-java"><code class="language-java">method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span></code></pre><p>反射调用优化：Field, Method, Constructor均有setAccessible(boolean)方法，设置为true可以关闭安全检查。(但会使得私有成员可以被访问)</p><h4 id="2-2获取Class类"><a href="#2-2获取Class类" class="headerlink" title="2.2获取Class类"></a>2.2获取Class类</h4><ol><li><p>已知一个类的全类名，且该类在类路径下，可通过Class.forName()获取</p><p>应用场景：多用于配置文件，读取类全路径，加载类</p><pre><code>String ClassFullPath = &quot;com.test.Cat&quot;;Class cls = Class.forName(ClassFullPath);</code></pre></li><li><p>已知具体的类，通过类的class获取，最安全可靠，且程序性能最高</p><p>应用场景：参数传递</p><pre><code>class Test&#123;&#125;...Class class = Test.class</code></pre></li><li><p>已知实例，则可直接通过getClass()方法获得。</p></li><li><p>包装类可获取TYPE属性，它的哈希值与其对应的基本数据类型的Class的hash值相同.</p></li></ol><h3 id="3-类的加载"><a href="#3-类的加载" class="headerlink" title="3.类的加载"></a>3.类的加载</h3><h4 id="3-1静态，动态加载"><a href="#3-1静态，动态加载" class="headerlink" title="3.1静态，动态加载"></a>3.1静态，动态加载</h4><ul><li>静态加载：编译时就加载相关类，依赖性较强</li><li>动态记载：运行时加载需要的类</li></ul><h4 id="3-2类的加载时机"><a href="#3-2类的加载时机" class="headerlink" title="3.2类的加载时机"></a>3.2类的加载时机</h4><ul><li>创建对象时 &#x2F;&#x2F;静态加载</li><li>子类被加载时，父类也一并会被加载 &#x2F;&#x2F;静态加载</li><li>调用类中的静态成员时 &#x2F;&#x2F;静态加载</li><li>反射 &#x2F;&#x2F;动态加载</li></ul><h4 id="3-3类加载的过程"><a href="#3-3类加载的过程" class="headerlink" title="3.3类加载的过程"></a>3.3类加载的过程</h4><ol><li><p>加载：将类的class文件读入内存，并创建一个java.lang.Class对象</p></li><li><p>连接：将类的二进制数据合并到JRE中</p><ol><li><p>验证：安全校验</p><p>​目的：确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会威胁虚拟机自身安全</p><p>​包括：文件格式验证（是否以魔数oxcafebabe开头）、元数据验证、字节码验证和符号引用验证</p><p>​PS：可以使用-Xverify:none参数来关闭大部分的类验证措施</p></li><li><p>准备：在该阶段对<strong>静态变量</strong>分配内存，并进行<strong>默认初始化</strong>（将其初始化为一个默认值，而非程序指定的值）</p><p>​  而对于<strong>静态常量</strong>则会<strong>直接赋值</strong>。</p></li><li><p>解析：JVM将常量池内的符号引用替换为直接引用的过程（可以理解为从图纸到实物的过程）</p></li></ol></li><li><p>初始化：JVM负责对类进行初始化，主要是<strong>静态成员</strong></p><p>​真正开始执行类中定义的Java程序代码，此阶段是执行&lt;clinit&gt;()方法的过程</p><p>​该方法由编译器按语句在<strong>源文件中出现的顺序</strong>，依次收集类中的所有<strong>静态变量</strong>的赋值动作和<strong>静态代码块</strong>中的语句，并进行合并。（该方法有线程锁）</p></li></ol><p>类加载后内存布局：</p><p>在<u>方法区</u>中存储类的二进制数据，并根据它在<u>堆</u>中生成一个类的Class对象</p><h4 id="3-4通过反射创建对象"><a href="#3-4通过反射创建对象" class="headerlink" title="3.4通过反射创建对象"></a>3.4通过反射创建对象</h4><p>相关方法：</p><ul><li>Class:<ul><li>getConstructor(Class&lt;?&gt;) 获取对应参数列表的public构造器</li><li>getDeclaredConstructor(Class&lt;?&gt;)获取对应参数列表的任意构造器</li></ul></li><li>Constructor:<ul><li>newInstance()创建一个实例</li><li>setAccessible()暴破（暴破后可操作私有属性）</li></ul></li></ul><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><p>并发:同时完成多个任务，无需等待当前任务完成就可以执行其他的任务。解决了程序因为外部控制导致的阻塞，例如IO。因此并发问题常见于IO密集型任务。</p><p>并行：同时完成在多个位置，完成多个任务。即让多个CPU同时执行程序的不同部分来提升效率。</p><p>并发通过对共享资源的有效控制，提升程序效率。而并行则是通过使用更多的资源，来提升效率。</p><p>trick：抽象泄露，抽象可以通过屏蔽对任务不重要的部分，让人更加容易地理解并设计程序。但抽象如果有所遗漏，即使这些细节被隐藏，也难以掩盖它带来的影响。而支持并发的语言和库似乎多少都有这个问题。</p><p>并发的使用条件</p><p>并发操作需要CPU切换上下文，这会消耗CPU一定的性能。因此，如果程序是CPU密集的，即CPU一般都处于忙碌状态，此时使用并发是没有意义的，应当确保程序开启的线程数和CPU的核心数相等。</p><p>但如果CPU会因某些原因陷入阻塞状态，那么此时使用并发绝对是值得的。</p><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><p>JDBC:提供一套<strong>统一的数据库接口</strong>由数据库厂商实现</p><h3 id="1-JDBC编写流程："><a href="#1-JDBC编写流程：" class="headerlink" title="1.JDBC编写流程："></a>1.JDBC编写流程：</h3><h5 id="1-1注册驱动：获取Driver类"><a href="#1-1注册驱动：获取Driver类" class="headerlink" title="1.1注册驱动：获取Driver类"></a>1.1注册驱动：获取Driver类</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//com.mysql.cj.jdbc.Driver</span>Driver driver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Driver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="1-2连接：获取Connection类"><a href="#1-2连接：获取Connection类" class="headerlink" title="1.2连接：获取Connection类"></a>1.2连接：获取Connection类</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//url jdbc:mysql://ip地址:端口号/数据库名称?serverTimezone=UTC"</span>String url <span class="token operator">=</span> <span class="token string">"jdbc:mysql://localhost:3306/coursecrash?serverTimezone=UTC"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//登录信息</span>Properties properties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>properties<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">,</span> <span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>properties<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">,</span> <span class="token string">"Cxc020603"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Connection connect <span class="token operator">=</span> driver<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> properties<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="1-3CRUD：发送SQL语句"><a href="#1-3CRUD：发送SQL语句" class="headerlink" title="1.3CRUD：发送SQL语句"></a>1.3CRUD：发送SQL语句</h5><pre class=" language-java"><code class="language-java">String sql <span class="token operator">=</span> <span class="token string">"insert into ade values('lgd', 'shen')"</span><span class="token punctuation">;</span>Statement statement <span class="token operator">=</span> connect<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> row <span class="token operator">=</span> statement<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="1-4释放资源"><a href="#1-4释放资源" class="headerlink" title="1.4释放资源"></a>1.4释放资源</h5><h3 id="2-数据库连接方式"><a href="#2-数据库连接方式" class="headerlink" title="2.数据库连接方式"></a>2.数据库连接方式</h3><ul><li>注册进DriverManage，方便统一管理</li></ul><pre class=" language-java"><code class="language-java">String url<span class="token operator">=</span> <span class="token string">"jdbc:mysql://localhost:3306/coursecrash?serverTimezone=UTC"</span><span class="token punctuation">;</span>String user <span class="token operator">=</span> <span class="token string">"root"</span><span class="token punctuation">;</span>String passwd <span class="token operator">=</span> <span class="token string">"Cxc020603"</span><span class="token punctuation">;</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> aClass <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.mysql.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String sql <span class="token operator">=</span> <span class="token string">"insert into ade values('lgd', 'shen')"</span><span class="token punctuation">;</span>Constructor<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> constructor <span class="token operator">=</span> aClass<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Driver driver1 <span class="token operator">=</span> <span class="token punctuation">(</span>Driver<span class="token punctuation">)</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>DriverManager<span class="token punctuation">.</span><span class="token function">registerDriver</span><span class="token punctuation">(</span>driver1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//注册驱动</span>Connection connection <span class="token operator">=</span> DriverManager<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> user<span class="token punctuation">,</span> passwd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Statement用于执行静态的SQL语句，并返回结果</span>Statement statement <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>statement<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//返回值为影响的行数</span>statement<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li><p>在类加载的时候（Class.forName()）会自动注册数据库驱动,因此可以省略</p></li><li><p>mysql驱动5.1.6以上可以无需Class.forName(),从jdk1.5以后使用了jdbc4，不再需要显式调用class.forName()注册驱动而是自动调用驱动jar包下META-INF\services\java.sql.Driver文本中的类名称去注册</p></li><li><p>通过配置文件获取连接的相关信息（软编码，推荐）</p></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException<span class="token punctuation">,</span> SQLException<span class="token punctuation">,</span> IOException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    Properties properties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    properties<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"src\\load.properties"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String user <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String password <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String url <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"url"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String driver <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>driver<span class="token punctuation">)</span><span class="token punctuation">;</span>        Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>driver<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//加载驱动类</span>    Connection connection <span class="token operator">=</span> DriverManager<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> user<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>    Statement statement <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//String sql = "create table TestTable (name varchar(5), age int, id int AUTO_INCREMENT, primary key(id))";</span>    String sql <span class="token operator">=</span> <span class="token string">"insert into testtable values ('cxc', 18, null),"</span> <span class="token operator">+</span>            <span class="token string">"('pcx', 18, null), ('lgd', 20, null)"</span><span class="token punctuation">;</span>    String sql1 <span class="token operator">=</span> <span class="token string">"delete from testtable where id=3"</span><span class="token punctuation">;</span>    statement<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>    statement<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span>sql1<span class="token punctuation">)</span><span class="token punctuation">;</span>    statement<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">url</span><span class="token punctuation">=</span><span class="token attr-value">jdbc:mysql://localhost:3306/coursecrash?serverTimezone=UTC</span><span class="token attr-name">user</span><span class="token punctuation">=</span><span class="token attr-value">root</span><span class="token attr-name">password</span><span class="token punctuation">=</span><span class="token attr-value">Cxc020603</span><span class="token attr-name">driver</span><span class="token punctuation">=</span><span class="token attr-value">com.mysql.jdbc.Driver</span></code></pre><p>ps:properties以字符串键值对存储，不需要加双引号</p><h3 id="3-ResultSet"><a href="#3-ResultSet" class="headerlink" title="3.ResultSet"></a>3.ResultSet</h3><p>用exectueQuery(sql)处理传入的select语句后会返回一个结果集</p><pre class=" language-java"><code class="language-java">ResultSet resultSet <span class="token operator">=</span> statement<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span>sql2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//previous()向上移动一行</span><span class="token comment" spellcheck="true">//相当于向下移动一行，初始状态下处于无效位置</span><span class="token keyword">while</span><span class="token punctuation">(</span>resultSet<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//取出指定列的数据</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>resultSet<span class="token punctuation">.</span><span class="token function">getXXX</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//XXX指该列的数据类型，//传入的参数可以是列的索引，也可以是列名</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>ResultSet中有一个rows属性，其数据类型为ArrayList,其中存储对象类数组，用于表示每一个数据</p><p><em>ResultSet与对应的连接绑定，一旦连接关闭，将无法再使用结果集</em></p><h3 id="拓展：SQL注入"><a href="#拓展：SQL注入" class="headerlink" title="拓展：SQL注入"></a>拓展：SQL注入</h3><p>Statement存在SQL注入风险</p><p>SQL注入：利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的SQL语句段或命令，恶意攻击数据库</p><p>eg：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> ClassNotFoundException<span class="token punctuation">,</span> SQLException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    Scanner scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>    Properties properties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    properties<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"src\\load.properties"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String user <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String driver <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String password <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String url <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"url"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>driver<span class="token punctuation">)</span><span class="token punctuation">;</span>    Connection connection <span class="token operator">=</span> DriverManager<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> user<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>    Statement statement <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"输入用户名："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String user1 <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"输入密码"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String passwd <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String sql <span class="token operator">=</span> <span class="token string">"select * from admin where name = '"</span> <span class="token operator">+</span> user1 <span class="token operator">+</span> <span class="token string">"' and password = '"</span> <span class="token operator">+</span> passwd <span class="token operator">+</span> <span class="token string">"'"</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>    ResultSet resultSet <span class="token operator">=</span> statement<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>resultSet<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        String sucess <span class="token operator">=</span> <span class="token string">"登陆成功"</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sucess<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        String fail <span class="token operator">=</span> <span class="token string">"Fail"</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>fail<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>运行结果</p><pre><code>输入用户名：1&#39;输入密码or &#39;1&#39;=&#39;1select * from admin where name = &#39;1&#39;&#39; and password = &#39;or &#39;1&#39;=&#39;1&#39;登陆成功Process finished with exit code 0</code></pre><h3 id="4-PreparedStatement"><a href="#4-PreparedStatement" class="headerlink" title="4.PreparedStatement"></a>4.PreparedStatement</h3><p>预处理Statement</p><p>预编译：在调用prepareStatement()时会直接将SQL语句提交给数据库编译，得到的PreparedStatement句柄是一个预编译好的SQL语句，添加参数后可直接执行。</p><p>将自身与某一sql语句绑定，sql语句中的参数用“？”作为占位符(占位符两边会自动加上引号)</p><p>因此占位符只能占位SQL语句中的普通值，绝不能占位表名，SQL关键字</p><p>调用setXXX(占位符的索引，占位符的值)方法来填充参数（参数索引从1开始）</p><pre class=" language-java"><code class="language-java">String sql <span class="token operator">=</span> <span class="token string">"select * from admin where name = ? and password = ?;"</span><span class="token punctuation">;</span>Connection connection <span class="token operator">=</span> DriverManager<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> user<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//此处将上方的sql语句与PreparedStatement绑定</span>PreparedStatement preparedStatement <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"输入用户名："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String user1 <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"输入密码"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String passwd <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>preparedStatement<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>preparedStatement<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>passwd<span class="token punctuation">)</span><span class="token punctuation">;</span>ResultSet resultSet <span class="token operator">=</span> preparedStatement<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>resultSet<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"success"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">else</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"failure"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>优势：</p><ul><li>不通过字符串拼接写SQL语句</li><li>可以防止SQL注入（自动在占位符两边添加引号）</li></ul><h3 id="5-JDBC事务处理"><a href="#5-JDBC事务处理" class="headerlink" title="5.JDBC事务处理"></a>5.JDBC事务处理</h3><p>开启事务： 调用Connect对象的setCommit(false)方法</p><p><em>默认情况下自动提交</em></p><p>提交事务：调用Connect对象的commit()方法</p><p>回滚：调用Connect对象的rollback([savepoint])方法</p><h3 id="6-批处理"><a href="#6-批处理" class="headerlink" title="6.批处理"></a>6.批处理</h3><p>通常与PreparedStatement搭配使用</p><p>在连接MySQL的url中添加参数rewriteBatchedStatements&#x3D;true</p><p>addBatch()将当前的sql语句添加到批处理包中</p><p>executeBatch()将包中的sql语句全部执行一遍</p><p>clearBatch()清空包</p><pre class=" language-java"><code class="language-java">Connection connect <span class="token operator">=</span> JDBCUtil<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>PreparedStatement preparedStatement <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//String sql = "insert into ade values (?, ?)";</span>String sql <span class="token operator">=</span> <span class="token string">"delete from ade where name=?"</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    preparedStatement <span class="token operator">=</span> connect<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        preparedStatement<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"cxc"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//preparedStatement.setString(2, "ohh");</span>        preparedStatement<span class="token punctuation">.</span><span class="token function">addBatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    preparedStatement<span class="token punctuation">.</span><span class="token function">executeBatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    preparedStatement<span class="token punctuation">.</span><span class="token function">clearBatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> end <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>作用：批量处理数据，减少编译次数，以及发送sql语句的网络开销</p><h3 id="7-数据库连接池"><a href="#7-数据库连接池" class="headerlink" title="7.数据库连接池"></a>7.数据库连接池</h3><h4 id="7-1传统的获取连接的方式的问题分析"><a href="#7-1传统的获取连接的方式的问题分析" class="headerlink" title="7.1传统的获取连接的方式的问题分析"></a>7.1传统的获取连接的方式的问题分析</h4><ol><li>每次向数据库建立连接都需要将Connection加载到内存中，再验证IP地址，用户名和密码，需要数据库连接时就申请一个，频繁连接会占用大量资源，造成服务器崩溃</li><li>每次连接使用完都得断开，若程序出现异常未能关闭，会导致数据库内存泄漏</li><li>不能控制创建的连接数量，若连接过多，也有可能导致内存泄漏，MySQL崩溃（没有缓冲机制）</li></ol><h4 id="7-2连接池基本介绍"><a href="#7-2连接池基本介绍" class="headerlink" title="7.2连接池基本介绍"></a>7.2连接池基本介绍</h4><ol><li>预先向缓冲池中加入一定数量的连接<strong>（已经创建好的）</strong></li><li>数据库连接池负责分配，管理和释放数据库连接，他允许应用程序<strong>重复</strong>使用一个现有的数据库连接。每次程序使用完成之后，<strong>只是连接的引用消失，但连接本身依旧存在</strong></li><li>当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列</li></ol><h4 id="7-3-c3p0连接池"><a href="#7-3-c3p0连接池" class="headerlink" title="7.3 c3p0连接池"></a>7.3 c3p0连接池</h4><ol><li>导入jar包</li></ol><p>连接方式1：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> SQLException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    ComboPooledDataSource comboPooledDataSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ComboPooledDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Properties properties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    properties<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"src\\load.properties"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String user <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String password <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String driver <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String url <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"url"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        comboPooledDataSource<span class="token punctuation">.</span><span class="token function">setDriverClass</span><span class="token punctuation">(</span>driver<span class="token punctuation">)</span><span class="token punctuation">;</span>        comboPooledDataSource<span class="token punctuation">.</span><span class="token function">setJdbcUrl</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>        comboPooledDataSource<span class="token punctuation">.</span><span class="token function">setUser</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        comboPooledDataSource<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">PropertyVetoException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    comboPooledDataSource<span class="token punctuation">.</span><span class="token function">setInitialPoolSize</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    comboPooledDataSource<span class="token punctuation">.</span><span class="token function">setMaxPoolSize</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        Connection connection <span class="token operator">=</span> comboPooledDataSource<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        connection<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> end <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>连接方式2（配置文件）：</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 文件名 c3p0-config.xml 放置在src文件夹下 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>c3p0-config</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 数据源名称 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>named-config</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mySource<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 若为default-config 则在生成管理对象时不需要传入参数 --></span>        <span class="token comment" spellcheck="true">&lt;!-- 驱动类 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>driverClass<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>com.mysql.cj.jdbc.Driver<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- url --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbcUrl<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>jdbc:mysql://localhost:3306/coursecrash?serverTimezone=UTC<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- user --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>root<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- password --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Cxc020603<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 初始化连接池中的连接数量大小 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>initialPoolSize<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>10<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 最大连接时长 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>maxIdleTime<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>30<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 最大连接数 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>maxPoolSize<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>100<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 最小连接数 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>minPoolSize<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>10<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>named-config</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>c3p0-config</span><span class="token punctuation">></span></span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">connect2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> SQLException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    ComboPooledDataSource mySource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ComboPooledDataSource</span><span class="token punctuation">(</span><span class="token string">"mySource"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Connection connection <span class="token operator">=</span> mySource<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    connection<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h4 id="7-4德鲁伊连接池"><a href="#7-4德鲁伊连接池" class="headerlink" title="7.4德鲁伊连接池"></a>7.4德鲁伊连接池</h4><p>导入jar包</p><p>配置文件：</p><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># 数据库连接参数</span><span class="token attr-name">url</span><span class="token punctuation">=</span><span class="token attr-value">jdbc:mysql://localhost:3306/coursecrash?serverTimezone=UTC&amp;rewriteBatchedStatements=true</span><span class="token attr-name">username</span><span class="token punctuation">=</span><span class="token attr-value">root</span><span class="token attr-name">password</span><span class="token punctuation">=</span><span class="token attr-value">Cxc020603</span><span class="token comment" spellcheck="true"># 驱动</span><span class="token attr-name">driverClassName</span><span class="token punctuation">=</span><span class="token attr-value">com.mysql.cj.jdbc.Driver</span><span class="token comment" spellcheck="true"># 连接池的参数</span><span class="token comment" spellcheck="true"># 初始虎啊连接数</span><span class="token attr-name">initialSize</span><span class="token punctuation">=</span><span class="token attr-value">10</span><span class="token comment" spellcheck="true">#最大连接数</span><span class="token attr-name">maxActive</span><span class="token punctuation">=</span><span class="token attr-value">10</span><span class="token comment" spellcheck="true">#最大等待时长</span><span class="token attr-name">maxWait</span><span class="token punctuation">=</span><span class="token attr-value">200</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">druid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    Properties properties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    properties<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token string">"src\\druid.properties"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    DataSource dataSource <span class="token operator">=</span> DruidDataSourceFactory<span class="token punctuation">.</span><span class="token function">createDataSource</span><span class="token punctuation">(</span>properties<span class="token punctuation">)</span><span class="token punctuation">;</span>    Connection connection <span class="token operator">=</span> dataSource<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    connection<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="8-ApDBUtils"><a href="#8-ApDBUtils" class="headerlink" title="8. ApDBUtils"></a>8. ApDBUtils</h3><h4 id="8-1-POJO-简单java对象"><a href="#8-1-POJO-简单java对象" class="headerlink" title="8.1 POJO(简单java对象)"></a>8.1 POJO(简单java对象)</h4><p>创建一个java对象，用其中的属性，映射ResultSet中的各个字段</p><h4 id="8-2-DBUtils类"><a href="#8-2-DBUtils类" class="headerlink" title="8.2 DBUtils类"></a>8.2 DBUtils类</h4><ol><li>QueryRunner类：该类封装了SQL的执行方法，<em>线程安全</em>，可以实现增删改查</li><li>ResultSetHandler接口：该接口用于处理java.sql.ResultSet,将数据按要求转换为另一种形式（POJO）</li></ol><p>常用ResultSet接口实现类：</p><ul><li>ArrayHandler:把结果集中的每一行数据都转成一个数组，再存放到List中</li><li>BeanHandler:将结果集中的第一行数据封装到一个POJO中</li><li>BeanListHandler:将结果集中的每一行数据都封装到一个对应的POJO实例中</li><li>ScalarHandler:若结果中只有单个值，则用该实现类处理，若有多个值，则会返回第一列数据处理后结果。</li></ul><h4 id="8-3基本使用"><a href="#8-3基本使用" class="headerlink" title="8.3基本使用"></a>8.3基本使用</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> SQLException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//获取连接</span>    Connection connection <span class="token operator">=</span> DruidUtils<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//生成QueryRunner对象</span>    QueryRunner queryRunner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryRunner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//需要预编译处理的语句</span>    String sql <span class="token operator">=</span> <span class="token string">"select * from ade where name=?"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//query方法参数，连接，sql语句，ResultSetHandler接口，sql语句中的参数</span>    List<span class="token operator">&lt;</span>POJO<span class="token operator">></span> query <span class="token operator">=</span>            queryRunner<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span>connection<span class="token punctuation">,</span> sql<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">BeanListHandler</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>POJO<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"cxc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>POJO pojo <span class="token operator">:</span> query<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>pojo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    DruidUtils<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> null<span class="token punctuation">,</span> connection<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>query底层使用preparedStatement操作sql语句，并会自动关闭Statement与ResultSet，在转换ResultSet中的数据时，会通过反射获取POJO类的属性，构造器等，然后返回一个对应的数组形式的结果集合。</p><p><em>若要传入基础数据类型，则要使用对应的包装类， 基本数据类型不能为空</em></p><h3 id="9-BasicDao"><a href="#9-BasicDao" class="headerlink" title="9.BasicDao"></a>9.BasicDao</h3><p>DAO：data access object数据访问对象</p><p>此类对象专门用于对特定类的数据进行增删改查</p><p>具体关系：</p><p>XXPOJO映射XX表中的数据</p><p>XXDAO对XX表进行CRUD</p><h3 id="10-Dao-Service-Controller"><a href="#10-Dao-Service-Controller" class="headerlink" title="10.Dao, Service, Controller"></a>10.Dao, Service, Controller</h3><p>Dao：数据访问层，对数据进行增删改查</p><p>Service：业务逻辑层，通过Dao的组合实现具体的业务逻辑</p><p>Controller：控制层，转发Service的业务处理结果，但不暴露Service层的业务逻辑</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Remake | Makefile</title>
      <link href="/2022/06/29/make/"/>
      <url>/2022/06/29/make/</url>
      
        <content type="html"><![CDATA[<p>菜狗的Remake之路 – Makefile篇</p><span id="more"></span><h1 id="Make"><a href="#Make" class="headerlink" title="Make"></a>Make</h1><h2 id="1-程序的编译与链接"><a href="#1-程序的编译与链接" class="headerlink" title="1. 程序的编译与链接"></a>1. 程序的编译与链接</h2><p>编译： 将源文件编译成中间代码文件(.o文件)</p><p>​要求语法正确，函数与变量声明正确</p><p>链接： 将大量的Object File 合成可执行文件</p><p>​头文件所在位置，当中间文件很多时，需要给中间文件打包(生成 Archive File 即.a文件) </p><h2 id="2-Makefile概述"><a href="#2-Makefile概述" class="headerlink" title="2.  Makefile概述"></a>2.  Makefile概述</h2><h3 id="2-1-Makefile规则"><a href="#2-1-Makefile规则" class="headerlink" title="2.1 Makefile规则"></a>2.1 Makefile规则</h3><pre class=" language-makefile"><code class="language-makefile"><span class="token symbol">target ... </span><span class="token punctuation">:</span> prerequisites ...    command    ...</code></pre><ul><li>target : 要生成的目标文件&#x2F;可执行文件&#x2F;标签</li><li>prerequisites : 生成 target 需要的依赖文件</li><li>command : 该 target 要执行的Shell命令 (以tab开始)</li></ul><p>eg:</p><pre class=" language-bash"><code class="language-bash">tes <span class="token keyword">:</span> test.o    cc -o tes test.otest.o <span class="token keyword">:</span> test.c def.h    cc -c test.c.phony <span class="token keyword">:</span> cleanclean <span class="token keyword">:</span>     <span class="token function">rm</span> test.o tes</code></pre><h3 id="2-2-Makefile变量"><a href="#2-2-Makefile变量" class="headerlink" title="2.2 Makefile变量"></a>2.2 Makefile变量</h3><blockquote><p>变量定义</p></blockquote><pre><code>objects = main.o kbd.o command.o display.o \     insert.o search.o files.o utils.o     可理解为一个字符串</code></pre><blockquote><p>变量使用</p></blockquote><p>$(objects)</p><h3 id="2-3-Makefile自动推导"><a href="#2-3-Makefile自动推导" class="headerlink" title="2.3 Makefile自动推导"></a>2.3 Makefile自动推导</h3><p>可以自动推导文件以及文件依赖关系后面的命令</p><p>只要make看到一个 <code>.o</code> 文件，它就会自动的把 <code>.c</code> 文件加在依赖关系中，如果make找到一个 <code>whatever.o</code> ，那么 <code>whatever.c</code> 就会是 <code>whatever.o</code> 的依赖文件。并且 <code>cc -c whatever.c</code> 也会被推导出来</p><h3 id="2-4-Makefile-文件名"><a href="#2-4-Makefile-文件名" class="headerlink" title="2.4 Makefile 文件名"></a>2.4 Makefile 文件名</h3><p>make 会依次在当前目录下寻找 GNUmakefile , makefile , Makefile(建议使用)</p><p>指定make文件 : <code>make -f filename</code></p><h3 id="2-5-引用其他Makefile"><a href="#2-5-引用其他Makefile" class="headerlink" title="2.5 引用其他Makefile"></a>2.5 引用其他Makefile</h3><pre><code>include filename</code></pre><p>make命令开始时，会找寻 <code>include</code> 所指出的其它Makefile，并把其内容安置在当前的位置。就好像C&#x2F;C++的 <code>#include</code> 指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找：</p><ol><li>如果make执行时，有 <code>-I</code> 或 <code>--include-dir</code> 参数，那么make就会在这个参数所指定的目录下去寻找。</li><li>如果目录 <code>&lt;prefix&gt;/include</code> （一般是： <code>/usr/local/bin</code> 或 <code>/usr/include</code> ）存在的话，make也会去找。</li></ol><h2 id="3-书写规则"><a href="#3-书写规则" class="headerlink" title="3. 书写规则"></a>3. 书写规则</h2><h3 id="3-1-文件查找"><a href="#3-1-文件查找" class="headerlink" title="3.1 文件查找"></a>3.1 文件查找</h3><p>Makefile默认在当前目录下寻找目标文件和依赖文件</p><blockquote><p>VPATH 特殊变量</p></blockquote><p>当存在<code>VPath</code>变量时，若在当前目录找不到文件，会到VPath下的路径寻找。</p><pre class=" language-makefile"><code class="language-makefile">VPATH <span class="token operator">=</span> src<span class="token punctuation">:</span>../headers<span class="token comment" spellcheck="true"># 不同目录用 ':' 分割</span></code></pre><blockquote><p>vpath 关键字</p></blockquote><p>使用方法：</p><ul><li>vpath <pattern> <directories><br>为符合模式<pattern>的文件指定搜索目录<directories>。</li><li>vpath <pattern><br>清除符合模式<pattern>的文件的搜索目录。</li><li>vpath<br>清除所有已被设置好了的文件搜索目录。</li></ul><p>vapth使用方法中的<pattern>需要包含 <code>%</code> 字符。 <code>%</code> 的意思是匹配零或若干字符，（需引用 <code>%</code> ，使用 <code>\</code> ）例如， <code>%.h</code> 表示所有以 <code>.h</code> 结尾的文件。<pattern>指定了要搜索的文件集，而<directories>则指定了&lt; pattern&gt;的文件集的搜索的目录。例如：</p><pre><code>vpath %.h ../headers</code></pre><h3 id="3-2-伪目标"><a href="#3-2-伪目标" class="headerlink" title="3.2 伪目标"></a>3.2 伪目标</h3><p>伪目标是一个标签而不是文件，所以make无法生存它的依赖关系和决定是否要执行</p><blockquote><p>显示指明为目标</p></blockquote><pre class=" language-makefile"><code class="language-makefile"><span class="token builtin">.PHONY</span><span class="token symbol"> </span><span class="token punctuation">:</span> clean<span class="token symbol">clean </span><span class="token punctuation">:</span>     command</code></pre><h3 id="3-3-多目标"><a href="#3-3-多目标" class="headerlink" title="3.3 多目标"></a>3.3 多目标</h3><p>若多个目标同时依赖于某个文件，则可将其合并</p><pre class=" language-makefile"><code class="language-makefile"><span class="token symbol">bigoutput littleoutput </span><span class="token punctuation">:</span> text.g    generate text.g -<span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">subst</span> output,,<span class="token variable">$@</span><span class="token punctuation">)</span> > <span class="token variable">$@</span></code></pre><p>上述规则等价于</p><pre class=" language-makefile"><code class="language-makefile"><span class="token symbol">bigoutput </span><span class="token punctuation">:</span> text.g    generate text.g -big > bigoutput<span class="token symbol">littleoutput </span><span class="token punctuation">:</span> text.g    generate text.g -little > littleoutput</code></pre><h3 id="3-4-静态模式"><a href="#3-4-静态模式" class="headerlink" title="3.4 静态模式"></a>3.4 静态模式</h3><p>静态模式可以更加容易地定义多目标的规则</p><p>语法：</p><pre class=" language-makefile"><code class="language-makefile"><span class="token symbol">&lt;targets ...> </span><span class="token punctuation">:</span> &lt;target-pattern> <span class="token punctuation">:</span> &lt;prereq-patterns ...>    &lt;commands>    ...</code></pre><p>targets : 定义了一系列的目标文件，可以有通配符，是一个集合</p><p>target-pattern : 指明了targets的模式，也就是目标集的模式</p><p>prereq-patterns : 目标的依赖模式，它对target-pattern形成的模式再进行一次依赖目标的定义。</p><p>如果我们的<target-pattern>定义成 <code>%.o</code> ，意思是我们的<target>;集合中都是以 <code>.o</code> 结尾的，而如果我们的<prereq-patterns>定义成 <code>%.c</code> ，意思是对<target-pattern>所形成的目标集进行二次定义，其计算方法是，取<target-pattern>模式中的 <code>%</code> （也就是去掉了 <code>.o</code> 这个结尾），并为其加上 <code>.c</code> 这个结尾，形成的新集合。</p><p>eg : </p><pre class=" language-makefile"><code class="language-makefile">objects <span class="token operator">=</span> foo.o bar.o<span class="token symbol">all </span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span><span class="token symbol"><span class="token variable">$</span>(objects)</span><span class="token punctuation">:</span> %.o<span class="token punctuation">:</span> %.c    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -c <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token comment" spellcheck="true"># 展开后</span><span class="token comment" spellcheck="true">#foo.o : foo.c</span><span class="token comment" spellcheck="true">#    $(CC) -c $(CFLAGS) foo.c -o foo.o</span><span class="token comment" spellcheck="true">#bar.o : bar.c</span><span class="token comment" spellcheck="true">#    $(CC) -c $(CFLAGS) bar.c -o bar.o</span></code></pre><p>指明了我们的目标从$object中获取， <code>%.o</code> 表明要所有以 <code>.o</code> 结尾的目标，也就是 <code>foo.o bar.o</code> ，也就是变量 <code>$object</code> 集合的模式，而依赖模式 <code>%.c</code> 则取模式 <code>%.o</code> 的 <code>%</code> ，也就是 <code>foo bar</code> ，并为其加下 <code>.c</code> 的后缀，于是，我们的依赖目标就是 <code>foo.c bar.c</code> 。而命令中的 <code>$&lt;</code> 和 <code>$@</code> 则是自动化变量， <code>$&lt;</code> 表示第一个依赖文件， <code>$@</code> 表示目标集</p><h3 id="3-5自动生成依赖型"><a href="#3-5自动生成依赖型" class="headerlink" title="3.5自动生成依赖型"></a>3.5自动生成依赖型</h3><pre class=" language-shell"><code class="language-shell"># 查看指定文件的依赖性gcc -M main.cgcc -MM main.c</code></pre><p>为每一个.c文件生成一个.d文件，.d文件存放.c文件的依赖性</p><p>生成.d文件的规则</p><pre class=" language-makefile"><code class="language-makefile"><span class="token symbol">%.d</span><span class="token punctuation">:</span> %.c    <span class="token operator">@</span>set -e<span class="token punctuation">;</span> rm -f <span class="token variable">$@;</span> \    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -MM <span class="token variable">$</span><span class="token punctuation">(</span>CPPFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> > <span class="token variable">$@.$$$$;</span> \    sed <span class="token string">'s,\($*\)\.o[ :]*,\1.o $@ : ,g'</span> &lt; <span class="token variable">$@.$$$$</span> > <span class="token variable">$@;</span> \    rm -f <span class="token variable">$@.$$$$</span></code></pre><p>这个规则的意思是，所有的 <code>.d</code> 文件依赖于 <code>.c</code> 文件， <code>rm -f $@</code> 的意思是删除所有的目标，也就是 <code>.d</code> 文件，第二行的意思是，为每个依赖文件 <code>$&lt;</code> ，也就是 <code>.c</code> 文件生成依赖文件， <code>$@</code> 表示模式 <code>%.d</code> 文件，如果有一个C文件是name.c，那么 <code>%</code> 就是 <code>name</code> ， <code>$$$$</code> 意为一个随机编号，第二行生成的文件有可能是“name.d.12345”，第三行使用sed命令做了一个替换，关于sed命令的用法请参看相关的使用文档。第四行就是删除临时文件。</p><p>目的：</p><p>将</p><pre class=" language-makefile"><code class="language-makefile"><span class="token symbol">main.o </span><span class="token punctuation">:</span> main.c defs.h</code></pre><p>转成：</p><pre class=" language-makefile"><code class="language-makefile"><span class="token symbol">main.o main.d </span><span class="token punctuation">:</span> main.c defs.h</code></pre><p>使得.d文件可以自动更新</p><h2 id="4-书写命令"><a href="#4-书写命令" class="headerlink" title="4. 书写命令"></a>4. 书写命令</h2><h3 id="4-1显示命令"><a href="#4-1显示命令" class="headerlink" title="4.1显示命令"></a>4.1显示命令</h3><p>若在命令行前加<code>@</code>，则该命令不会被显示出来。</p><pre class=" language-makefile"><code class="language-makefile"><span class="token operator">@</span>echo <span class="token string">'Compiling'</span></code></pre><p>make -n 只显示命令，但不会执行，方便查看命令执行顺序</p><p>make -s 全面禁止命令的显示</p><h3 id="4-2命令执行"><a href="#4-2命令执行" class="headerlink" title="4.2命令执行"></a>4.2命令执行</h3><p>如果需要上一条命令的结果被应用于下一条命令，则应用<code>;</code>间隔两条命令，而不是换行</p><pre class=" language-makefile"><code class="language-makefile"><span class="token symbol">exec</span><span class="token punctuation">:</span>    cd ~<span class="token punctuation">;</span> pwd</code></pre><p>make -i 忽略所有错误</p><p>make -k 若某命令出错，则终止该命令，但其他命令照常执行</p><h3 id="4-3-嵌套执行make"><a href="#4-3-嵌套执行make" class="headerlink" title="4.3 嵌套执行make"></a>4.3 嵌套执行make</h3><blockquote><p>主控make</p></blockquote><pre class=" language-makefile"><code class="language-makefile"><span class="token symbol">subsystem</span><span class="token punctuation">:</span>    cd subdir &amp;&amp; <span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span></code></pre><blockquote><p>传递变量</p></blockquote><pre class=" language-makefile"><code class="language-makefile"><span class="token keyword">export</span> variable <span class="token comment" spellcheck="true">#传递变量</span><span class="token keyword">export</span> <span class="token comment" spellcheck="true">#传递所有变量</span><span class="token keyword">unexport</span> variable <span class="token comment" spellcheck="true">#不传递</span></code></pre><p>有两个变量，一个是 <code>SHELL</code> ，一个是 <code>MAKEFLAGS</code> ，这两个变量不管你是否export，其总是要传递到下层 Makefile中，特别是 <code>MAKEFLAGS</code> 变量，其中包含了make的参数信息，如果我们执行“总控Makefile”时有make参数或是在上层 Makefile中定义了这个变量，那么 <code>MAKEFLAGS</code> 变量将会是这些参数，并会传递到下层Makefile中，这是一个系统级的环境变量。</p><p>但是make命令中的有几个参数并不往下传递，它们是 <code>-C</code> , <code>-f</code> , <code>-h</code>, <code>-o</code> 和 <code>-W</code></p><h3 id="4-4定义命令包"><a href="#4-4定义命令包" class="headerlink" title="4.4定义命令包"></a>4.4定义命令包</h3><p>如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以 <code>define</code> 开始，以 <code>endef</code> 结束</p><pre class=" language-makefile"><code class="language-makefile"><span class="token keyword">define</span> run-yaccyacc <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">firstword</span> <span class="token variable">$^</span><span class="token punctuation">)</span>mv y.tab.c <span class="token variable">$@</span><span class="token keyword">endef</span></code></pre><h2 id="5-变量"><a href="#5-变量" class="headerlink" title="5. 变量"></a>5. 变量</h2><h3 id="5-1-变量的基础"><a href="#5-1-变量的基础" class="headerlink" title="5.1 变量的基础"></a>5.1 变量的基础</h3><p>变量在声明时要赋初值，在使用时，在变量名前加<code>$</code>，并将变量名用()包起来。</p><p>若要使用真实的<code>$</code>，输入<code>$$</code></p><blockquote><p>变量的定义</p></blockquote><p>使用<code>:=</code>运算符来定义变量</p><pre class=" language-makefile"><code class="language-makefile">x <span class="token operator">:=</span> fooy <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> barx <span class="token operator">:=</span> later</code></pre><p>如此，前面的变量便不能使用后面变量的值。</p><p>如果直接用<code>=</code>赋值，则前面的变量就不可以使用后面的变量（不推荐）</p><p><code>#注释符可以用来表示变量定义的终止</code></p><pre class=" language-makefile"><code class="language-makefile">nullstring <span class="token operator">:=</span>space <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>nullstring<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#end of line</span>dir <span class="token operator">:=</span> /foo/bar    <span class="token comment" spellcheck="true"># 4 space left</span></code></pre><p><code>?=</code>在变量未被赋值的情况下给他赋值，否则略过这条语句</p><pre class=" language-makefile"><code class="language-makefile">foo <span class="token operator">?=</span> bar</code></pre><h3 id="5-2-变量高级用法"><a href="#5-2-变量高级用法" class="headerlink" title="5.2 变量高级用法"></a>5.2 变量高级用法</h3><blockquote><p>变量值的替换</p></blockquote><p><code>$(var:a=b)</code>将变量var中所有以字串a<strong>结尾</strong>的‘a’替换为字串’b’。此处结尾指的是空格或结束符</p><p><code>$(var:%.c=%.d)</code>作用同上，此种通过静态模式定义。</p><blockquote><p>使用变量的变量</p></blockquote><p>Makefile中的变量类似于宏，可以用于拼接任意东西</p><pre class=" language-makefile"><code class="language-makefile">x <span class="token operator">=</span> variable1variable2 <span class="token operator">:=</span> Helloy <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">subst</span> 1,2,<span class="token variable">$</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>z <span class="token operator">=</span> ya <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><pre class=" language-makefile"><code class="language-makefile">first_second <span class="token operator">=</span> Helloa <span class="token operator">=</span> firstb <span class="token operator">=</span> secondall <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token variable">$a_$b</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># $a_$b 拼接成变量名</span></code></pre><pre class=" language-makefile"><code class="language-makefile"><span class="token keyword">ifdef</span> do_sort    func <span class="token operator">:=</span> sort<span class="token keyword">else</span>    func <span class="token operator">:=</span> strip<span class="token keyword">endif</span>bar <span class="token operator">:=</span> a d b g q cfoo <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># $(func) $(bar) 分别拼接成函数名及其参数</span></code></pre><blockquote><p>追加变量值</p></blockquote><p><code>+=</code></p><pre class=" language-makefile"><code class="language-makefile">variable <span class="token operator">:=</span> valuevariable <span class="token operator">+=</span> more<span class="token comment" spellcheck="true">#=== 等价于 ===#</span>variable <span class="token operator">:=</span> valuevariable <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>variable<span class="token punctuation">)</span> more</code></pre><blockquote><p>多行变量</p></blockquote><p>利用<code>define</code>关键字设置变量的值可以有换行，便于定义一系列命令。</p><p>变量的值可以包含函数、命令、文字，或是其它变量。因为命令需要以[Tab]键开头，所以如果你用define定义的命令变量中没有以 <code>Tab</code> 键开头，那么make 就不会把其认为是命令。</p><pre class=" language-makefile"><code class="language-makefile"><span class="token keyword">define</span> two-linesecho fooecho <span class="token variable">$</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token keyword">endef</span></code></pre><blockquote><p>override</p></blockquote><p>如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在Makefile中设置这类参数的值，那么，你可以使用“override”指示符。其语法是:</p><pre class=" language-makefile"><code class="language-makefile"><span class="token keyword">override</span> &lt;variable><span class="token punctuation">;</span> <span class="token operator">=</span> &lt;value><span class="token punctuation">;</span><span class="token keyword">override</span> &lt;variable><span class="token punctuation">;</span> <span class="token operator">:=</span> &lt;value><span class="token punctuation">;</span></code></pre><p>当然，你还可以追加:</p><pre><code>override &lt;variable&gt;; += &lt;more text&gt;;</code></pre><h3 id="5-3-特殊变量"><a href="#5-3-特殊变量" class="headerlink" title="5.3 特殊变量"></a>5.3 特殊变量</h3><blockquote><p>环境变量</p></blockquote><p>make运行时的系统环境变量可以在make开始运行时被载入到Makefile文件中，但是如果Makefile中已定义了这个变量，或是这个变量由make命令行带入，那么系统的环境变量的值将被覆盖。（如果make指定了“-e”参数，那么，系统环境变量将覆盖Makefile中定义的变量）</p><p>因此，如果我们在环境变量中设置了 <code>CFLAGS</code> 环境变量，那么我们就可以在所有的Makefile中使用这个变量了。这对于我们使用统一的编译参数有比较大的好处。如果Makefile中定义了CFLAGS，那么则会使用Makefile中的这个变量，如果没有定义则使用系统环境变量的值，一个共性和个性的统一，很像“全局变量”和“局部变量”的特性。</p><p>当make嵌套调用时（参见前面的“嵌套调用”章节），上层Makefile中定义的变量会以系统环境变量的方式传递到下层的Makefile 中。当然，默认情况下，只有通过命令行设置的变量会被传递。而定义在文件中的变量，如果要向下层Makefile传递，则需要使用exprot关键字来声明。（参见前面章节）</p><blockquote><p>目标变量</p></blockquote><p>为某个目标设置局部变量，其作用范围只在这条规则及其连带的规则中。</p><p>语法：</p><pre class=" language-makefile"><code class="language-makefile"><span class="token symbol">&lt;target ...> </span><span class="token punctuation">:</span> &lt;variable-assignment><span class="token comment" spellcheck="true"># 主要用于处理环境变量</span><span class="token symbol">&lt;target ...> </span><span class="token punctuation">:</span> <span class="token keyword">override</span> &lt;variable-assignment> </code></pre><pre class=" language-makefile"><code class="language-makefile"><span class="token symbol">prog </span><span class="token punctuation">:</span> CFLAGS <span class="token operator">=</span> -g<span class="token symbol">prog </span><span class="token punctuation">:</span> prog.o foo.o bar.o    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> prog.o foo.o bar.o<span class="token symbol">prog.o </span><span class="token punctuation">:</span> prog.c    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> prog.c<span class="token symbol">foo.o </span><span class="token punctuation">:</span> foo.c    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> foo.c<span class="token symbol">bar.o </span><span class="token punctuation">:</span> bar.c    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> bar.c</code></pre><blockquote><p>模式变量</p></blockquote><p>将变量定义在所有符合模式的目标上</p><pre class=" language-makefile"><code class="language-makefile"><span class="token symbol">%.o </span><span class="token punctuation">:</span> CFLAGS <span class="token operator">=</span> -o</code></pre><p>语法同目标变量</p><h2 id="6-条件判断"><a href="#6-条件判断" class="headerlink" title="6. 条件判断"></a>6. 条件判断</h2><blockquote><p>语法</p></blockquote><pre><code>&lt;conditional-directive&gt;&lt;text-if-true&gt;endif&lt;conditional-directive&gt;&lt;text-if-true&gt;else&lt;text-if-false&gt;endif</code></pre><blockquote><p>ifeq &#x2F; ifneq</p></blockquote><p>比较两个参数的值是否相等&#x2F;不相等</p><pre class=" language-makefile"><code class="language-makefile">libs_for_gcc <span class="token operator">=</span> -lgnunormal_libs <span class="token operator">=</span><span class="token symbol">foo</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span><span class="token keyword">ifeq</span> <span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span>, gcc<span class="token punctuation">)</span>    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -o foo <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>libs_for_gcc<span class="token punctuation">)</span><span class="token keyword">else</span>    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -o foo <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>normal_libs<span class="token punctuation">)</span><span class="token keyword">endif</span></code></pre><blockquote><p>ifdef &#x2F; ifndef</p></blockquote><pre class=" language-makefile"><code class="language-makefile"><span class="token keyword">ifdef</span> &lt;variable-name></code></pre><p>判断变量的值是否为空，非空为真，空为假</p><p>仅判断一个变量是否有值，而不会将其展开</p><pre class=" language-makefile"><code class="language-makefile">bar <span class="token operator">=</span>foo <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 此处判断为真 </span><span class="token keyword">ifdef</span> foo    frobozz <span class="token operator">=</span> yes<span class="token keyword">else</span>    frobozz <span class="token operator">=</span> no<span class="token keyword">endif</span></code></pre><p><strong>make在读取Makefile时就会计算条件表达式的值，因此不要在此处使用自动化变量</strong></p><h2 id="7-函数"><a href="#7-函数" class="headerlink" title="7. 函数"></a>7. 函数</h2><blockquote><p>调用语法</p></blockquote><pre class=" language-makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span>&lt;function-name> &lt;arguments><span class="token punctuation">)</span></code></pre><p>函数名与参数之间用空格分隔，参数之间用<code>,</code>分隔</p><h3 id="7-1-字符串处理函数"><a href="#7-1-字符串处理函数" class="headerlink" title="7.1 字符串处理函数"></a>7.1 字符串处理函数</h3><blockquote><p>subst</p></blockquote><pre class=" language-makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">subst</span> &lt;from>, &lt;to>, &lt;text><span class="token punctuation">)</span></code></pre><p>功能：将字串<code>&lt;text&gt;</code>中的<code>&lt;from&gt;</code>转换为<code>&lt;to&gt;</code></p><p>返回：替换后的字符串</p><blockquote><p>patsubst</p></blockquote><pre class=" language-makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">patsubst</span> &lt;pattern>,&lt;replacement><span class="token punctuation">)</span></code></pre><p>功能：查找 <code>&lt;text&gt;</code> 中的单词<strong>（单词以“空格”、“Tab”或“回车”“换行”分隔）</strong>是否符合模式 <code>&lt;pattern&gt;</code> ，如果匹配的话，则以 <code>&lt;replacement&gt;</code> 替换。这里， <code>&lt;pattern&gt;</code> 可以包括通配符 <code>%</code> ，表示任意长度的字串。如果 <code>&lt;replacement&gt;</code> 中也包含 <code>%</code> ，那么， <code>&lt;replacement&gt;</code> 中的这个 <code>%</code> 将是 <code>&lt;pattern&gt;</code> 中的那个 <code>%</code> 所代表的字串。（可以用 <code>\</code> 来转义，以 <code>\%</code> 来表示真实含义的 <code>%</code> 字符）</p><p>返回：替换后的字符串</p><blockquote><p>strip</p></blockquote><pre class=" language-makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">strip</span> &lt;string><span class="token punctuation">)</span></code></pre><p>功能：去掉<string>字串开头和结尾的空格</p><p>返回：被去掉空格的字符串</p><blockquote><p>findstring</p></blockquote><pre class=" language-makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">findstring</span> &lt;find>,&lt;in><span class="token punctuation">)</span></code></pre><p>功能：在字串<in>中查找<find>字串</p><p>返回：如果找到，返回<find>字串</p><blockquote><p>filter &#x2F; filterout</p></blockquote><pre class=" language-makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">filter</span> &lt;pattern...>, &lt;text><span class="token punctuation">)</span></code></pre><p>功能：以 <code>&lt;pattern&gt;</code> 模式过滤&#x2F;去除 <code>&lt;text&gt;</code> 字符串中的单词，保留符合模式 <code>&lt;pattern&gt;</code> 的单词。可以有多个模式。</p><p>返回：符合模式的字串</p><blockquote><p>sort</p></blockquote><pre class=" language-makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">sort</span> &lt;list><span class="token punctuation">)</span></code></pre><p>功能：给字符串 <code>&lt;list&gt;</code> 中的单词排序（升序）。</p><p>返回：返回排序后的字符串。</p><p>示例： <code>$(sort foo bar lose)</code> 返回 <code>bar foo lose</code> 。</p><p>备注： <code>sort</code> 函数会去掉 <code>&lt;list&gt;</code> 中相同的单词。</p><blockquote><p>word</p></blockquote><pre><code>$(word &lt;n&gt;,&lt;text&gt;)</code></pre><p>名称：取单词函数</p><p>功能：取字符串 <code>&lt;text&gt;</code> 中第 <code>&lt;n&gt;</code> 个单词。（从一开始）</p><p>返回：返回字符串 <code>&lt;text&gt;</code> 中第 <code>&lt;n&gt;</code> 个单词。如果 <code>&lt;n&gt;</code> 比 <code>&lt;text&gt;</code> 中的单词数要大，那么返回空字符串。</p><p>示例： <code>$(word 2, foo bar baz)</code> 返回值是 <code>bar</code> 。</p><blockquote><p>wordlist</p></blockquote><pre><code>$(wordlist &lt;ss&gt;,&lt;e&gt;,&lt;text&gt;)</code></pre><p>名称：取单词串函数</p><p>功能：从字符串 <code>&lt;text&gt;</code> 中取从 <code>&lt;ss&gt;</code> 开始到 <code>&lt;e&gt;</code> 的单词串。 <code>&lt;ss&gt;</code> 和 <code>&lt;e&gt;</code> 是一个数字。</p><p>返回：返回字符串 <code>&lt;text&gt;</code> 中从 <code>&lt;ss&gt;</code> 到 <code>&lt;e&gt;</code> 的单词字串。如果 <code>&lt;ss&gt;</code> 比 <code>&lt;text&gt;</code> 中的单词数要大，那么返回空字符串。如果 <code>&lt;e&gt;</code> 大于 <code>&lt;text&gt;</code> 的单词数，那么返回从 <code>&lt;ss&gt;</code> 开始，到 <code>&lt;text&gt;</code> 结束的单词串。</p><p>示例： <code>$(wordlist 2, 3, foo bar baz)</code> 返回值是 <code>bar baz</code> 。</p><blockquote><p>firstword</p></blockquote><pre><code>$(firstword &lt;text&gt;)</code></pre><p>名称：首单词函数——firstword。</p><p>功能：取字符串 <code>&lt;text&gt;</code> 中的第一个单词。</p><p>返回：返回字符串 <code>&lt;text&gt;</code> 的第一个单词。</p><p>示例： <code>$(firstword foo bar)</code> 返回值是 <code>foo</code>。</p><p>备注：这个函数可以用 <code>word</code> 函数来实现： <code>$(word 1,&lt;text&gt;)</code> 。</p><h3 id="7-2-文件名处理函数"><a href="#7-2-文件名处理函数" class="headerlink" title="7.2 文件名处理函数"></a>7.2 文件名处理函数</h3><blockquote><p>dir</p></blockquote><pre><code>$(dir &lt;names...&gt;)</code></pre><p>名称：取目录函数——dir。</p><p>功能：从文件名序列 <code>&lt;names&gt;</code> 中取出目录部分。目录部分是指最后一个反斜杠（ <code>/</code> ）之前的部分。如果没有反斜杠，那么返回 <code>./</code> 。</p><p>返回：返回文件名序列 <code>&lt;names&gt;</code> 的目录部分。</p><p>示例： <code>$(dir src/foo.c hacks)</code> 返回值是 <code>src/ ./</code> 。</p><blockquote><p>notdir</p></blockquote><pre><code>$(notdir &lt;names...&gt;)</code></pre><p>名称：取文件函数——notdir。</p><p>功能：从文件名序列 <code>&lt;names&gt;</code> 中取出非目录部分。非目录部分是指最後一个反斜杠（ <code>/</code> ）之后的部分。</p><p>返回：返回文件名序列 <code>&lt;names&gt;</code> 的非目录部分。</p><p>示例: <code>$(notdir src/foo.c hacks)</code> 返回值是 <code>foo.c hacks</code> 。</p><blockquote><p>suffix</p></blockquote><pre><code>$(suffix &lt;names...&gt;)</code></pre><p>名称：取後缀函数——suffix。</p><p>功能：从文件名序列 <code>&lt;names&gt;</code> 中取出各个文件名的后缀。</p><p>返回：返回文件名序列 <code>&lt;names&gt;</code> 的后缀序列，如果文件没有后缀，则返回空字串。</p><p>示例： <code>$(suffix src/foo.c src-1.0/bar.c hacks)</code> 返回值是 <code>.c .c</code>。</p><blockquote><p>basename</p></blockquote><pre><code>$(basename &lt;names...&gt;)</code></pre><p>名称：取前缀函数——basename。</p><p>功能：从文件名序列 <code>&lt;names&gt;</code> 中取出各个文件名的前缀部分。</p><p>返回：返回文件名序列 <code>&lt;names&gt;</code> 的前缀序列，如果文件没有前缀，则返回空字串。</p><p>示例： <code>$(basename src/foo.c src-1.0/bar.c hacks)</code> 返回值是 <code>src/foo src-1.0/bar hacks</code> 。</p><blockquote><p>addsuffix</p></blockquote><pre><code>$(addsuffix &lt;suffix&gt;,&lt;names...&gt;)</code></pre><p>名称：加后缀函数——addsuffix。</p><p>功能：把后缀 <code>&lt;suffix&gt;</code> 加到 <code>&lt;names&gt;</code> 中的每个单词后面。</p><p>返回：返回加过后缀的文件名序列。</p><p>示例： <code>$(addsuffix .c,foo bar)</code> 返回值是 <code>foo.c bar.c</code> 。</p><blockquote><p> addprefix</p></blockquote><pre><code>$(addprefix &lt;prefix&gt;,&lt;names...&gt;)</code></pre><p>名称：加前缀函数——addprefix。</p><p>功能：把前缀 <code>&lt;prefix&gt;</code> 加到 <code>&lt;names&gt;</code> 中的每个单词后面。</p><p>返回：返回加过前缀的文件名序列。</p><p>示例： <code>$(addprefix src/,foo bar)</code> 返回值是 <code>src/foo src/bar</code> 。</p><blockquote><p>join</p></blockquote><pre><code>$(join &lt;list1&gt;,&lt;list2&gt;)</code></pre><p>名称：连接函数——join。</p><p>功能：把 <code>&lt;list2&gt;</code> 中的单词对应地加到 <code>&lt;list1&gt;</code> 的单词后面。如果 <code>&lt;list1&gt;</code> 的单词个数要比 <code>&lt;list2&gt;</code> 的多，那么， <code>&lt;list1&gt;</code> 中的多出来的单词将保持原样。如果 <code>&lt;list2&gt;</code> 的单词个数要比 <code>&lt;list1&gt;</code> 多，那么， <code>&lt;list2&gt;</code> 多出来的单词将被复制到 <code>&lt;list1&gt;</code> 中。</p><p>返回：返回连接过后的字符串。</p><p>示例： <code>$(join aaa bbb , 111 222 333)</code> 返回值是 <code>aaa111 bbb222 333</code> 。</p><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><pre><code>$(foreach &lt;var&gt;,&lt;list&gt;,&lt;text&gt;)</code></pre><p>这个函数的意思是，把参数 <code>&lt;list&gt;</code> 中的单词逐一取出放到参数 <code>&lt;var&gt;</code> 所指定的变量中，然后再执行 <code>&lt;text&gt;</code> 所包含的表达式。每一次 <code>&lt;text&gt;</code> 会返回一个字符串，循环过程中， <code>&lt;text&gt;</code> 的所返回的每个字符串会以空格分隔，最后当整个循环结束时， <code>&lt;text&gt;</code> 所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。</p><p>所以， <code>&lt;var&gt;</code> 最好是一个变量名， <code>&lt;list&gt;</code> 可以是一个表达式，而 <code>&lt;text&gt;</code> 中一般会使用 <code>&lt;var&gt;</code> 这个参数来依次枚举 <code>&lt;list&gt;</code> 中的单词。举个例子：</p><pre><code>names := a b c dfiles := $(foreach n,$(names),$(n).o)</code></pre><p>上面的例子中， <code>$(name)</code> 中的单词会被挨个取出，并存到变量 <code>n</code> 中， <code>$(n).o</code> 每次根据 <code>$(n)</code> 计算出一个值，这些值以空格分隔，最后作为foreach函数的返回，所以， <code>$(files)</code> 的值是 <code>a.o b.o c.o d.o</code> 。</p><p>注意，foreach中的 <code>&lt;var&gt;</code> 参数是一个临时的局部变量，foreach函数执行完后，参数 <code>&lt;var&gt;</code> 的变量将不在作用，其作用域只在foreach函数当中。</p><h3 id="call函数"><a href="#call函数" class="headerlink" title="call函数"></a>call函数</h3><p>call函数是唯一一个可以用来创建新的参数化的函数。你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，然后你可以call函数来向这个表达式传递参数。其语法是：</p><pre><code>$(call &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,...,&lt;parmn&gt;)</code></pre><p>当make执行这个函数时， <code>&lt;expression&gt;</code> 参数中的变量，如 <code>$(1)</code> 、 <code>$(2)</code> 等，会被参数 <code>&lt;parm1&gt;</code> 、 <code>&lt;parm2&gt;</code> 、 <code>&lt;parm3&gt;</code> 依次取代。而 <code>&lt;expression&gt;</code> 的返回值就是 call 函数的返回值。例如：</p><pre><code>reverse =  $(1) $(2)foo = $(call reverse,a,b)</code></pre><p>那么， <code>foo</code> 的值就是 <code>a b</code> 。当然，参数的次序是可以自定义的，不一定是顺序的，如：</p><pre><code>reverse =  $(2) $(1)foo = $(call reverse,a,b)</code></pre><p>此时的 <code>foo</code> 的值就是 <code>b a</code> 。</p><p>需要注意：在向 call 函数传递参数时要尤其注意空格的使用。call 函数在处理参数时，第2个及其之后的参数中的空格会被保留，因而可能造成一些奇怪的效果。因而在向call函数提供参数时，最安全的做法是去除所有多余的空格。</p><h3 id="origin函数"><a href="#origin函数" class="headerlink" title="origin函数"></a>origin函数</h3><p>origin函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是哪里来的？其语法是：</p><pre><code>$(origin &lt;variable&gt;)</code></pre><ul><li><p>注意， <code>&lt;variable&gt;</code> 是变量的名字，不应该是引用。所以你最好不要在 <code>&lt;variable&gt;</code> 中使用</p><p><code>$</code> 字符。Origin函数会以其返回值来告诉你这个变量的“出生情况”，下面，是origin函数的返回值:</p></li><li><p><code>undefined</code></p><p>如果 <code>&lt;variable&gt;</code> 从来没有定义过，origin函数返回这个值 <code>undefined</code></p></li><li><p><code>default</code></p><p>如果 <code>&lt;variable&gt;</code> 是一个默认的定义，比如“CC”这个变量，这种变量我们将在后面讲述。</p></li><li><p><code>environment</code></p><p>如果 <code>&lt;variable&gt;</code> 是一个环境变量，并且当Makefile被执行时， <code>-e</code> 参数没有被打开。</p></li><li><p><code>file</code></p><p>如果 <code>&lt;variable&gt;</code> 这个变量被定义在Makefile中。</p></li><li><p><code>command line</code></p><p>如果 <code>&lt;variable&gt;</code> 这个变量是被命令行定义的。</p></li><li><p><code>override</code></p><p>如果 <code>&lt;variable&gt;</code> 是被override指示符重新定义的。</p></li><li><p><code>automatic</code></p><p>如果 <code>&lt;variable&gt;</code> 是一个命令运行中的自动化变量。关于自动化变量将在后面讲述。</p></li></ul><p>这些信息对于我们编写Makefile是非常有用的，例如，假设我们有一个Makefile其包了一个定义文件 Make.def，在 Make.def中定义了一个变量“bletch”，而我们的环境中也有一个环境变量“bletch”，此时，我们想判断一下，如果变量来源于环境，那么我们就把之重定义了，如果来源于Make.def或是命令行等非环境的，那么我们就不重新定义它。于是，在我们的Makefile中，我们可以这样写：</p><pre><code>ifdef bletch    ifeq &quot;$(origin bletch)&quot; &quot;environment&quot;        bletch = barf, gag, etc.    endifendif</code></pre><p>当然，你也许会说，使用 <code>override</code> 关键字不就可以重新定义环境中的变量了吗？为什么需要使用这样的步骤？是的，我们用 <code>override</code> 是可以达到这样的效果，可是 <code>override</code> 过于粗暴，它同时会把从命令行定义的变量也覆盖了，而我们只想重新定义环境传来的，而不想重新定义命令行传来的。</p><h3 id="shell函数"><a href="#shell函数" class="headerlink" title="shell函数"></a>shell函数</h3><p>shell函数也不像其它的函数。顾名思义，它的参数应该就是操作系统Shell的命令。它和反引号“&#96;”是相同的功能。这就是说，shell函数把执行操作系统命令后的输出作为函数返回。于是，我们可以用操作系统命令以及字符串处理命令awk，sed等等命令来生成一个变量，如：</p><pre><code>contents := $(shell cat foo)files := $(shell echo *.c)</code></pre><p>注意，这个函数会新生成一个Shell程序来执行命令，所以你要注意其运行性能，如果你的Makefile中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是Makefile的隐晦的规则可能会让你的shell函数执行的次数比你想像的多得多。</p>]]></content>
      
      
      <categories>
          
          <category> Remake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Remake | 数据结构</title>
      <link href="/2022/06/29/DataStructure/"/>
      <url>/2022/06/29/DataStructure/</url>
      
        <content type="html"><![CDATA[<p>菜狗的Remake之路 – 数据结构篇</p><span id="more"></span><p>使用语言：Java</p><blockquote><p>实例化对象的过程</p></blockquote><p>首先根据构造函数传入的参数初始化对象中的属性，然后该对象的属性的首个bit所在的位置返回，作为该对象的地址被存入到对应的变量中。</p><p>所有地址长度位64位，null的地址为全0。</p><p>tips：所有的赋值操作都是将该变量存储的字节全部拷贝到另一个变量中。</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>尽量避免特判可有效提高代码健壮性。</p><p>表头添加哨兵结点的思想：让链表在任何情况下的状态都遵循同一套操作逻辑。</p><p>在单链表中添加头部哑节点的原因是，在某些情况下无法访问链表中结点的next属性，因此我们通过添加哑节点来使next属性在任何时刻都可以被访问。</p><p>而对于双向链表，又出现了某些结点的prev属性不能被访问或是说不应该被访问。例如，按照原先单链表的设计，我们将需要在前插时对是否是头部哑节点进行特判。</p><p>此时有两种解决方法：</p><ol><li>在尾部也添加一个哑节点。</li><li>将链表设计成循环链表。</li></ol><h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><blockquote><p>resize</p></blockquote><p>当顺序表需要进行resize操作时，将数组大小进行指数级更改，而非简单的加减。因为加减无法根据当前数据量的大小动态进行调整，导致在数据量过大时频繁地调用resize操作拖慢速度且占用大量空间。</p><p>若顺序表中数组存储的不是基本数据类型，则不推荐懒惰删除，因为被删除对象的引用仍然保存着，不会被gc回收，占用内存。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承会从父类继承所有的成员变量，静态变量，所有的方法和内部类。</p><p>但被private修饰的不可直接访问。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 调用父类方法</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">xxx</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>tips:构造器都不会被继承，但Java会默认在子类构造器中首先调用基类默认<em>无参</em>构造器。</p><blockquote><p>继承会破坏封装</p></blockquote><p>Java根据动态数据类型调用方法，若子类中覆写了一个方法，其中调用了从基类继承来的方法，但此方法调用了基类中被覆写的方法，则此时不会调用父类中被覆写的方法，而是子类的方法，最终陷入无限循环。</p><p>封装被破坏的直接体现：模组中的方法不再以整体的形式被调用</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="合并排序-选择排序"><a href="#合并排序-选择排序" class="headerlink" title="合并排序 (+ 选择排序)"></a>合并排序 (+ 选择排序)</h3><p>合并排序在处理有序数组时仅有O(N)的复杂度，因此可以选择将无序数组切分成若干部分，对其分别调用选择排序，再进行合并，实现排序加速。</p><p>但若将数组切分到只剩单个元素的小块，则可直接用合并排序实现一切，复杂度为O(NlogN)，代价是内存占用较大。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Sort</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * merge two sorted array to a sorted array     * @param &lt;T> type of data     * @param datas1 a sorted array and all of its elements are not null     * @param datas2 a sorted array and all of its elements are not null     * @param c The comparator of type T     * @return a sorted array containing all elements in datas1 and datas2     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> List<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">merge</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>T<span class="token operator">></span> datas1<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>T<span class="token operator">></span> datas2<span class="token punctuation">,</span> Comparator<span class="token operator">&lt;</span>T<span class="token operator">></span> cc<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>        i <span class="token operator">=</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// ret = (T[])(new Object[datas1.length + datas2.length]);</span>        List<span class="token operator">&lt;</span>T<span class="token operator">></span> ret <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> datas1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> datas2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> cmp <span class="token operator">=</span> cc<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>datas1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> datas2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                ret<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>datas1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">++</span>i<span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                ret<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>datas2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">++</span>j<span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            idx<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> datas1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            ret<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>datas1<span class="token punctuation">.</span><span class="token function">subList</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> datas1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">!=</span> datas2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            ret<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>datas2<span class="token punctuation">.</span><span class="token function">subList</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> datas2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">insertSort</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>T<span class="token operator">></span> datas<span class="token punctuation">,</span> Comparator<span class="token operator">&lt;</span>T<span class="token operator">></span> cc<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> datas<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            T elem <span class="token operator">=</span> datas<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> j<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> cc<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>datas<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> elem<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                datas<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> datas<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            datas<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> elem<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> List<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>T<span class="token operator">></span> datas<span class="token punctuation">,</span> Comparator<span class="token operator">&lt;</span>T<span class="token operator">></span> cc<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>datas<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token function">insertSort</span><span class="token punctuation">(</span>datas<span class="token punctuation">,</span> cc<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> datas<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> datas<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            List<span class="token operator">&lt;</span>T<span class="token operator">></span> sort1 <span class="token operator">=</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>datas<span class="token punctuation">.</span><span class="token function">subList</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">,</span> cc<span class="token punctuation">)</span><span class="token punctuation">;</span>            List<span class="token operator">&lt;</span>T<span class="token operator">></span> sort2 <span class="token operator">=</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>datas<span class="token punctuation">.</span><span class="token function">subList</span><span class="token punctuation">(</span>mid<span class="token punctuation">,</span> datas<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cc<span class="token punctuation">)</span><span class="token punctuation">;</span>            List<span class="token operator">&lt;</span>T<span class="token operator">></span> ret <span class="token operator">=</span> <span class="token function">merge</span><span class="token punctuation">(</span>sort1<span class="token punctuation">,</span> sort2<span class="token punctuation">,</span> cc<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> ret<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>划分域：在数组中选取一个元素，在对元素重新组织后，使得在该元素的左边均为</p><p>小于他的元素，右边均为大于他的元素。</p><p>划分域 -&gt; 被选取的元素已经就位</p><p>因此快排的思路就是，在数组中选取一个枢纽点，以他为中心重新组织数组，使其满足划分域的要求。然后对划分的左右两边继续调用快排直至数组中没有元素或只剩1个元素。</p><p>快排的本质仍旧是一棵以枢纽点为节点的二叉树，树的平均高度为logN，而在树的每一层中进行的重组织的时间复杂度为O(N)，因此快排的时间复杂度为O(NlogN)</p><p>但要注意的是，若枢纽点选取不当，会导致树退化成单链表，例如当数组基本有序或有大量重复元时，每次划分都只会划分出1个元素。</p><blockquote><p>优化方法</p></blockquote><ol><li>使用随机算法进行枢纽元选取，有大概率会选到在中间大小的元素</li><li>当数组元素数量不大时，切换为稳定的排序算法（插排&#x2F;归并），避免树的深度在最后大幅增加</li></ol><blockquote><p>Hora partition</p></blockquote><p>使一个指针i指向数组起点，一个指针j指向数组终点，当i所指的元素小于pivot时，右移i，当j所指元素大于pivot时，左移j。i和j都停下时，交换所指元素。重复上述步骤，直至i与j交叉，然后将pivot与j交换。（此时j必定处于最后一个小于pivot的位置，因此需要如此交换）</p><h3 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h3><p>若要选取数组中第k小的元素，则将数组中的最后一个元素作为pivot，初始化pivotloc于数组起点，然后遍历数组，若当前元素小于pivot，则将其与pivotloc交换，并移动pivotloc，最后交换pivotloc所指元素与pivot。这样就将数组切分成两块，然后检查获得的pivotloc是否与k相等，若大于，则对左半部分继续切分，若小于，则对右半部分继续切分。（此时，左半部分均小于pivotloc的元素，右半部分反之）</p><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>不实质性将两个结点连接，而是将其存储在同一个集合中，表明他们之间有链接。</p><p>这样在查询两个结点之间是否连接时只需要看他们是否在同一集合中。</p><p>re:我们不需要像图那样直到具体的连接情况，因此可以用逻辑上的连接代替。</p><blockquote><p>implement</p></blockquote><p>实现方式1：哈希表（通用）</p><p>对于整形</p><p>实现方式2：创建一个大小为N的数组，数组中存储的是其对应下标数组所属的集合的代表数字。</p><p>快速连接的方法：直接修改集合的代表元素指向的父级结点的值。但此时父级结点的计算仍可能是一个昂贵的操作。最坏情况会退化到O(N)。</p><p>因此我们选择将一个结合中所有的元素都指向结合代表元素，这样查询当前集合的父节点的时间就被大大压缩。</p><p>此时需要考虑在合并时应将小的集合并到大的集合来减少树的深度。</p><p>-&gt; 使用一个数组来追踪集合大小，确保每一次都是小的往大的合，这样树的深度永远被控制在logN。</p><p>路径压缩：在执行isConnect时，将单个集合中的所有结点指向其最高父结点。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Union</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> parent<span class="token punctuation">;</span>    Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> size<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*        AF(n) : a union containing n elements,         their parent nodes are stored in &amp;#123;parent&amp;#125;        every set's size is stored in size        Rep invarient:        parent != null, elements in parent are greater than or equal to 0, less than n        size != null, elements in size are not less than 1    */</span>    <span class="token keyword">public</span> <span class="token function">Union</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        parent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        size <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            parent<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            size<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * check if p and q are belong to the same set     * compress the path at the same time     * @param p node p     * @param q node q     * @return if they are belong to the same set     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isConnect</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> q<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> i <span class="token operator">==</span> j<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * find parent of p     * @param p node p     * @return its parent     */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> p<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * connect set containing p and set containing q together     * @param p node p     * @param q node q     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> q<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> parent<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> j<span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>size<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> size<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            parent<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            size<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> size<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            parent<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>            size<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> size<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><blockquote><p>前&#x2F;中&#x2F;后序遍历时间复杂度</p></blockquote><p>因为该遍历算法针对每一个结点作处理，其时间复杂度增长与结点个数有关。一次遍历要考虑N个节点，因此时间复杂度为O(N)</p><blockquote><p>层序遍历</p></blockquote><p>层序遍历的区别在于，该算法时间复杂度的增长与层数有关，假设层数为H，操作次数为1 + 2^1 + 2^2 + …</p><p>因此其时间复杂度为O(2^H)，而H&#x3D;logN，所以时间复杂度为O(N)</p><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>对于一张有序的顺序表，可以通过不断的将其二分来进行压缩，BST就是二分查找的显式表现。</p><p>根节点的左子树这种的元素均小于根节点的元素，右子树的均大于根节点元素。</p><blockquote><p>删除操作</p></blockquote><p>对于叶子节点，直接将其删除即可。</p><p>对于有单个孩子的结点，用其孩子结点顶替当前结点。</p><p>对于有两个孩子的结点，找到其左子树中最大的结点或右子树中最小的结点(必然是叶子结点或只有一个孩子的结点)来顶替它，然后删除用于顶替的结点。</p><p>tip：但是删除操作做的越多，树的高度就会不断增高，因为每次删除都相当于让树的某一端的结点数量减少，最后失去平衡。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BinSearchTree</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Node root<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>        <span class="token keyword">public</span> Integer <span class="token function">get</span><span class="token punctuation">(</span>Integer key<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">getHelper</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Integer <span class="token function">getHelper</span><span class="token punctuation">(</span>Integer key<span class="token punctuation">,</span> Node troot<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>troot <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>troot<span class="token punctuation">.</span>elem<span class="token punctuation">.</span>key <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> troot<span class="token punctuation">.</span>elem<span class="token punctuation">.</span>value<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>troot<span class="token punctuation">.</span>elem<span class="token punctuation">.</span>key <span class="token operator">&lt;</span> key<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token function">getHelper</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> troot<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">getHelper</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> troot<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> Node <span class="token function">insert</span><span class="token punctuation">(</span>Integer key<span class="token punctuation">,</span> Integer value<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        root <span class="token operator">=</span> <span class="token function">insertHelper</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Node <span class="token function">insertHelper</span><span class="token punctuation">(</span>Integer key<span class="token punctuation">,</span> Integer value<span class="token punctuation">,</span> Node troot<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>troot <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            size<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">,</span> null<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>troot<span class="token punctuation">.</span>elem<span class="token punctuation">.</span>key <span class="token operator">></span> key<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                troot<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">insertHelper</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> troot<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>troot<span class="token punctuation">.</span>elem<span class="token punctuation">.</span>key <span class="token operator">&lt;</span> key<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                troot<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">insertHelper</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> troot<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> troot<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">containsKey</span><span class="token punctuation">(</span>Integer key<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">getHelper</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> root<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span>Integer key<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token function">deleteHelper</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Node <span class="token function">deleteHelper</span><span class="token punctuation">(</span>Integer key<span class="token punctuation">,</span> Node troot<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>troot <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>troot<span class="token punctuation">.</span>elem<span class="token punctuation">.</span>key <span class="token operator">&lt;</span> key<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            troot<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">deleteHelper</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> troot<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>troot<span class="token punctuation">.</span>elem<span class="token punctuation">.</span>key <span class="token operator">></span> key<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            troot<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">deleteHelper</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> troot<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>troot<span class="token punctuation">.</span>left <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> troot<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                Node tmp <span class="token operator">=</span> <span class="token function">findMax</span><span class="token punctuation">(</span>troot<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                troot<span class="token punctuation">.</span>elem <span class="token operator">=</span> tmp<span class="token punctuation">.</span>elem<span class="token punctuation">;</span>                troot<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">deleteHelper</span><span class="token punctuation">(</span>troot<span class="token punctuation">.</span>elem<span class="token punctuation">.</span>key<span class="token punctuation">,</span> troot<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>troot<span class="token punctuation">.</span>left <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    troot <span class="token operator">=</span> troot<span class="token punctuation">.</span>right<span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>troot<span class="token punctuation">.</span>right <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    troot <span class="token operator">=</span> troot<span class="token punctuation">.</span>left<span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            size<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> troot<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Node <span class="token function">findMax</span><span class="token punctuation">(</span>Node troot<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>troot <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>troot<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            troot <span class="token operator">=</span> troot<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> troot<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">private</span> Pair elem<span class="token punctuation">;</span>        <span class="token keyword">private</span> Node left<span class="token punctuation">;</span>        <span class="token keyword">private</span> Node right<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">Node</span><span class="token punctuation">(</span>Pair elem<span class="token punctuation">,</span> BinSearchTree<span class="token punctuation">.</span>Node left<span class="token punctuation">,</span> BinSearchTree<span class="token punctuation">.</span>Node right<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>elem <span class="token operator">=</span> elem<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> left<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> right<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>           <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Pair</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">private</span> Integer key<span class="token punctuation">;</span>        <span class="token keyword">private</span> Integer value<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">Pair</span><span class="token punctuation">(</span>Integer key<span class="token punctuation">,</span> Integer value<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h3><p>在已知一组数据的情况下，若将其按随机顺序插入，则复杂度大概率是O(logN)，但若不提前知道数据，那么有可能会让树退化成单链表，因为先前并没有考虑该往哪里插入数据，基本都是插在底部，因此很有可能只往一端插入数据，让树的高度大幅增加。</p><p>因此我们需要在每一次插入与删除之后检查树的平衡，若失衡则进行调整。</p><blockquote><p>左旋</p></blockquote><p>右端大量的数据破坏了树的平衡，则将原来的根节点作为新根节点的左子树，新根节点原来的左子树接到原根结点的右端。右旋同理。</p><blockquote><p>B tree</p></blockquote><p>使一个结点能够存储多个数据，例如每个结点允许存储3个数据，当数据量大于3时，将当前结点拆分，将第2大的数据放到父节点中存储。这样之后每个结点都有4棵子树，分别存储 &lt; val1, &gt;val1 &amp;&amp; &lt; val2，…的数据。只有当根节点中的数据也超过上限时，树的高度才会增加，将第2大的数据作为新的根节点，然后重新分配子树。</p><blockquote><p>红黑树</p></blockquote><p>红黑树即是B树(2-3树)和二叉树的结合，对于含有两个数据的结点，<strong>逻辑上</strong>添加一个哑结点作为这两个数据的父节点，这样就将他们拆分成二叉树，这个哑结点即为红黑树中的红。</p><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>将数据本身当作索引，仅仅把数据看作是位，而在数组对应的位置存储布尔值。</p><p>但该方法会占用大量空间，且对于非数字类型不友好（但可以进行映射，确保任何值都会被分配到唯一的一个空间）。</p><p>将元素转换为下标的过程即为hash，注意不要让hash生成负数，或对其进行特殊处理。</p><p>对于超过2亿的数据量，必然会有多个元素共享空间的情况，因此我们不在数组中存储true&#x2F;false,而是对应的元素</p><p>哈希的速度取决于它存储的数据量（越多的数据量代表越多的冲突），N个数据分布在M个桶里时，其平均访问速度为O(N&#x2F;M), L&#x3D;N&#x2F;M即为装在因子。当装载因子超过阈值时，就要进行rehash操作，通过使用更多的桶来减少冲突。</p><p>但装载因子不是唯一需要考虑的东西，当一系列数据共享同一个空间时，其装载因子也可能非常小，因此哈希函数的涉及应确保哈希表中的数据分散存放。</p><h2 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h2><p>可以追踪或移除最大&#x2F;最小元素</p><p>堆用树的形式体现具有如下特质：</p><ol><li>所有的结点都要小于等于它的子节点</li><li>完全</li></ol><blockquote><p>add</p></blockquote><p>先将要插入的结点放在最后一个位置，若其父节点的值大于其值，则将父节点沉降，直到父节点的值小于该节点的值，此时空槽到达满足要求的位置。</p><blockquote><p>remove</p></blockquote><p>先将最后一个结点提升为root结点，然后沉降直到它的值小于它的孩子节点。</p><blockquote><p>用数组表示树</p></blockquote><ol><li><p>将键存储在一个数组中，将对应的父节点id存在另一个数组中</p></li><li><p>只存储数据，不存储结构，假设是一个完整二叉树。</p><p>父节点与子节点的下标关系：</p><p>从1开始存储</p><ul><li>parent &#x3D; k&#x2F;2</li><li>left child &#x3D; 2 * k</li><li>right child &#x3D; 2 *</li></ul></li></ol><h2 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h2><h3 id="图的实现方式"><a href="#图的实现方式" class="headerlink" title="图的实现方式"></a>图的实现方式</h3><blockquote><p>临接矩阵</p></blockquote><p>用二维数组存储图，其矩阵的行列分别表示起点与终点，矩阵中存储的内容表示两点是否连接，或者是两点间边的权重。</p><p>遍历的时间复杂度为O(V^2)</p><p>首先要将所有点当作起点展开一层循环，该层循环会持续执行V次，接着要检查当前起点所连接到的点，要遍历数组matrix[v][]，该层循环每轮要执行V次，由此可得时间复杂度为V^2次</p><blockquote><p>临接表</p></blockquote><p>维护一组链表，用数组下标表示起点，链表内容表示它连通的结点</p><p>遍历的时间复杂度为O(V + E)</p><p>首先仍要将所有结点都搜索一遍，但针对相邻点的处理有所不同，临接矩阵需要访问所有的点来确定是否连接，而临接矩阵只要访问对应下标上的链表长度的数据。对于没有相邻点的结点，其访问连接点只需要进行1次操作，即在图中没有边时，临接表只需进行V次操作，而当临接矩阵中出现边时，就需要再加上E次操作，因此总时间复杂度为O(V + E)</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><blockquote><p>深度优先搜索</p></blockquote><p>遍历完某一结点的所有子节点后再转向另一结点。需要一个数组来保存访问情况，避免重复访问导致无限递归。</p><blockquote><p>图论算法的设计模式</p></blockquote><p>将图的信息传递给专门进行处理的客户类，让客户直接从对应的类中获取需要的处理后的信息。</p><blockquote><p>Topological Sort</p></blockquote><p>拓扑排序是一个<strong>有向无环图</strong>的所有顶点的线性序列，且具有如下特质：</p><ol><li>每一个顶点出现且只出现一次</li><li>若存在一条从A到B的路径，则在序列中A出现在B之前。</li></ol><p>实现：</p><ol><li>维护一个存储入度为0的节点的数组</li><li>每次从该数组中取出一个节点并删除该顶点及所有相关的有向边。</li><li>更新图中其余节点的入度。</li><li>重复2，3直到图为空。</li></ol><p>应用：拓扑排序常用来排序具有依赖关系的任务。</p><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><blockquote><p>Shortest Path</p></blockquote><p>广度优先搜索不适合做最短路检索的原因：没有考虑边的权值。</p><p>最短路径最后的生成结果是一棵树</p><p>树的特性：</p><ol><li>没有环路(最短路径问题本身需要满足的条件)</li><li>每一个节点都最多只有一个父节点(对于图中的每一个节点来说，到达它的最短路径数永远&lt;&#x3D;1)</li></ol><p>Dijkstra算法</p><p>按照当前已知最短路的顺序访问各个节点，然后对该节点拥有的边进行松弛操作。</p><p>A*算法</p><p>基本和Dijkstra算法一致，但他访问节点的顺序是按照已知最短路再加上到达下一个节点的估计。和Dijkstra算法相比，该算法的速度会更快，因为D算法的执行顺序是根据到起点的距离，而A*算法加入了对终点距离的估计。</p><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><blockquote><p>Spanning tree</p></blockquote><p>最小生成树与最短路径树的区别：</p><p>最短路径树的生成与起点有关，而最小生成树与选取的起点无关。</p><blockquote><p> cut property</p></blockquote><p>对于两棵树来说，要生成他们融合后的最小生成树，那么连接他们的边中权重最小的那一条必然在最小生成树中。</p><p>利用该性质我们可以得出，先将一棵树分割成两部分，一部分有一个节点，另一部分有剩余的所有结点，找出权重最小的连接着两棵树的边加入到MST中，重复上述步骤知道没有节点在第二部分，MST就生成了。</p><p>和最短路径算法相比，最小生成树在增加节点时，更多的考虑该节点与树的距离，而非该节点与某一特定起点的距离。</p><blockquote><p>Kruskal</p></blockquote><p>每次都从图中抽取出权重最小的那条边，若没有构成环路，则将其加入MST中。</p><blockquote><p>判断图中有无环路的方法</p></blockquote><p>使用并查集存储已经连接起来的节点，若在检查某条边时，其对应的节点已经处于同一个集合中，则代表有环路。</p><h2 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h2><blockquote><p>Topological sort + Dijkstra</p></blockquote><p>拓扑排序会按照节点之间的依赖关系进行排序，也就是说，当某个节点被访问时，代表能到达它的边已经都被访问过了，因此，到达他的最短路径已经找到，可以在此基础上继续寻找最短路径。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>当一个问题的规模不断增大时，若其与对应的子问题有联系时，可以通过分割成子问题，然后通过子问题的答案推断出当前问题的答案。</p>]]></content>
      
      
      <categories>
          
          <category> Remake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/06/12/hello-world/"/>
      <url>/2022/06/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
