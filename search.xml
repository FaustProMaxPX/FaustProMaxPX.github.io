<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java</title>
      <link href="/2022/06/29/Java/"/>
      <url>/2022/06/29/Java/</url>
      
        <content type="html"><![CDATA[<p>一份关于Java基本操作的笔记</p><span id="more"></span><h1 id="Java随记"><a href="#Java随记" class="headerlink" title="Java随记"></a>Java随记</h1><h2 id="面向过程编程"><a href="#面向过程编程" class="headerlink" title="面向过程编程"></a>面向过程编程</h2><p>同一个模块或不同模块的函数能够不受限制的访问全局性数据，全局数据和函数之间缺乏联系</p><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>在程序中包含各种独立而又互相调用的对象的思想。将数据与对数据的操作封装到一个数据类型之中，该数据类型又可以与其他数据类型进行交互。</p><h3 id="2-优势"><a href="#2-优势" class="headerlink" title="2.优势"></a>2.优势</h3><ul><li>加大封装力度  若在程序投入使用后，部分数据结构必须改变，那么受影响的也只是对象内部的逻辑。</li><li>提升复用性</li><li>提高设计效率</li></ul><h3 id="3-类与对象"><a href="#3-类与对象" class="headerlink" title="3.类与对象"></a>3.类与对象</h3><p>Classes：定义了一件事物的抽象特点。包含了数据以及对数据的操作</p><p>Objects：类的实例</p><h3 id="4-类与类之间的关系"><a href="#4-类与类之间的关系" class="headerlink" title="4.类与类之间的关系"></a>4.类与类之间的关系</h3><ul><li>依赖关系：一个类使用或知道另一个类。是一种瞬时关系，依赖类和目标类进行简单的交互</li><li>关联关系：一个类在很长一段时间内都会与另一个类有合作关系<ul><li>关联关系的三要素：关联的方向、关联的数量、关联的属性</li></ul></li><li>继承关系</li></ul><h3 id="5-对象的创建"><a href="#5-对象的创建" class="headerlink" title="5.对象的创建"></a>5.对象的创建</h3><p>对象变量的声明：在栈中为对象变量分配一个存储地址数据的内存空间</p><p>对象的创建：在堆中分配对象所占的空间，对象变量指向该地址</p><p>对象的销毁：当程序中不存在该对象的引用时，就会销毁</p><h2 id="Java包"><a href="#Java包" class="headerlink" title="Java包"></a>Java包</h2><p>包用于组织、管理类，并且解决类命名冲突问题</p><p>若一个源文件中不加package语句，则指定为缺省包，类文件位于当前工作目录下</p><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>三元运算符所在表达式会成为一个整体，其精度会由式中最高精度决定。</p><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>语法: ReturnType funName(TypeName…varName)<br><strong>本质是数组</strong><br>可变参数必须在参数列表的最后一个，并且只能有一个可变参数。</p><h2 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h2><p>1.访问父类的属性但不能访问父类的私有属性：super.属性名&#x2F;方法名<br>2.访问父类的的构造器：super(参数列表)</p><h2 id="动态绑定机制"><a href="#动态绑定机制" class="headerlink" title="动态绑定机制"></a>动态绑定机制</h2><p>当调用对象方法时，该方法会和该对象的<strong>内存地址&#x2F;运行类型</strong>绑定<br>当调用对象属性时，<strong>没有动态绑定</strong>.</p><p><strong>类的五大成员：属性，方法，代码块，构造器，内部类</strong></p><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>static代码块作用就是对类进行初始化，并且它随着<strong>类的加载</strong>而执行，并且只<strong>执行一次</strong>，而普通代码块每创建一个对象就会执行（可以理解为它和构造函数绑定）</p><p><strong>类什么时候被加载</strong><br>1.创建对象实例的时候(new)<br>2.子类被加载时，父类也会被加载。<br>3.使用静态成员时（静态属性和方法） PS:调用静态成员时不会执行普通代码块中的内容</p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>定义：一个类的内部又完整的嵌套了另一个类结构，被嵌套的类称为内部类。<br>特点：可以直接访问私有属性，并且可以体现类与类之间的包含关系。</p><p><strong>内部类的构造器的第一个参数会被显示指定为外部类实例（锚定）</strong></p><p>分类：<br>1.定义在外部类局部位置上（比如方法内）：<br>1)局部内部类（有类名）<br>2)<strong>匿名内部类（没有类名）</strong><br>2.定义在外部类的成员位置上：<br>1)成员内部类（没用static修饰）<br>2)静态内部类（用static修饰）</p><p><strong>局部内部类，匿名内部类的实质是一个对象，一个局部变量，因此不能被外部其他类访问。</strong></p><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>1.可以直接访问外部类的所有成员（包含所有的）<br>2.不能被修饰符所修饰，因为他本质是一个局部变量<br>3.作用域：仅在定义它的方法与代码块中。<br>4.外部其他类不能访问局部内部类。<br>5.若外部类和局部内部类的成员重名时，采取<strong>就近原则</strong>,若要调用外部类成员则要使用<br>外部类名.this.成员 （re：对应成员并非静态变量，需要用对象来调用，此时this相当于指向该外部类的当前对象）</p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>语法：new 类或接口(参数列表){具体实现} （若实现某个接口则不需要传入参数列表，参数列表会被传递给构造器。） PS:生成的匿名内部类的运行类型不是实现的类或接口。<br>使用环境：类或接口中的抽象方法需要被实现来使用或是要重载重写，但使用次数极少，此时使用匿名内部类可避免额外再创建一个类。</p><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>外部其他类访问内部类：<br>1.外部类.内部类 name &#x3D; 外部类<strong>对象</strong>.new 内部类构造函数<br>2.在外部类中写一个获取内部类的方法<br>3.作用域：整个类体</p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>1.可以访问任意静态外部类成员<br>2.外部其他类访问静态内部类：外部类.内部类 name &#x3D; new 外部类.内部类构造函数 (静态内部类不需要用外部类的对象来调用，因此其构造函数可用外部类名调用)</p><h2 id="接口-纯虚基类"><a href="#接口-纯虚基类" class="headerlink" title="接口(纯虚基类)"></a>接口(纯虚基类)</h2><p>1.接口不能被实例化<br>2.接口中所有的方法是public抽象方法, 其中abstract可以省略<br>3.一个普通类实现接口，就必须将该接口中的所有方法都实现，而抽象类可以不必全部实现<br>4.接口中的属性都是final的, 且具体来说是public static final类型的  eg:int a -&gt; public static final int a 即接口中的属性通过接口名来访问。<br>5.接口只能继承其他接口，而非实现其他接口</p><h3 id="接口与继承的区别"><a href="#接口与继承的区别" class="headerlink" title="接口与继承的区别"></a>接口与继承的区别</h3><p>继承的价值主要在于：解决代码的复用性和可维护性<br>接口的价值主要在于：设计，设计好各种规范（方法），让其他类去实现这些方法，更加灵活<br><strong>继承满足的是is-a的关系，而接口满足的是like-a的关系</strong><br>接口在一定程度上实现代码解耦。</p><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>关键字：enum<br>enum的代码块中包含：枚举类<strong>对象</strong>，枚举类的构造函数，方法，属性，代码块<br>其中枚举类的对象必须声明再最开始，且其中每一个对象默认被public static final修饰<br>方法compareTo()会比较两个枚举量的编号<br>方法ordinal()返回编号<br>构造器默认为私有，且只能为私有<br>会隐式继承Enum类，因此不能继承其他类。</p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>注解用于修饰解释 包、类、方法、属性、构造器、局部变量等数据信息。<br>注解不影响程序逻辑，但<strong>注解可以被编译或运行</strong>。</p><p>@Override注解：表明以下方法是被重写的，编译器编译时会去父类搜索是否有同名方法，若检测到没有该方法，则会报错。<br>作用域：方法</p><p>@Deprecated注解：表明以下内容已经过时，不推荐使用<br>作用域：方法、类、字段、包、参数等等</p><p>@SupressWarnings注解：抑制编译器警告<br>语法：@SupressWarnings({要抑制的警告})<br>作用域：方法、类、字段、包、参数等等</p><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>装箱：底层是valueOf()<br>拆箱：底层是XXXValue()</p><p>PS:valueOf()底层原理：程序会缓存一个-128-127的数组，因此在这个范围内的数不会重新创建一个对象，但对于超出该范围的数则会返回一个new的对象</p><h3 id="String类-不可修改，但复用率高"><a href="#String类-不可修改，但复用率高" class="headerlink" title="String类(不可修改，但复用率高)"></a>String类(不可修改，但复用率高)</h3><p>String类实现了Serializable(序列化), Comparable(可比较)接口。<br>字符串使用Unicode编码，每个字符占两个字节。<br><strong>String类用一个value数组存储字符序列，并且它被final修饰，即其地址不可修改</strong>。<br><strong>re:数组本身是一个地址，因此final其实修饰了一个地址，即String的value中的值可以改变，但其地址不可变。</strong></p><p>String的赋值方法:<br>String s1 &#x3D; “abc” <strong>底层原理：变量s1入栈，然后去常量池中寻找是否有”abc”，若没有，则在常量池中创建，然后s1指向常量池中目标的地址。</strong><br>String s2 &#x3D; new String(“abc”) <strong>底层原理：变量s2入栈，然后在堆中开辟一块空间用于维护对象，s2指向该空间，然后去寻找常量池中是否有”abc”,若有，则value直接指向它，若没有，则在常量池中先创建，然后value再指向。</strong></p><p>intern()方法：若池中已存在一个等于String对象value值（用equal比较）的对象，则返回常量池中的地址，若没有则在池中创建一个再返回。</p><p>String a &#x3D; “a” + “b” 会被编译器优化为：String a &#x3D; “ab”</p><p>String a &#x3D; “a”; String b &#x3D; “b”; String c &#x3D; a + b; 先创建一个StringBuilder类，然后调用两次append() [分别把字符串a和字符串b连入SB对象]，最后返回一个字符串对象。<br>最后 a-&gt;堆中对象-&gt;池中对象</p><p><strong>String每次重新赋值都会重新开辟空间</strong><br><strong>String本身不可像数组一样访问，要用charAt进行访问。</strong><br>substring的参数为(int beginindex, int lastindex)前闭后开<br>replace对调用对象没有影响，它会返回一个新的字符串。<br>compareTo：若两字符串长度不同且在较小长度范围内相等，则返回长度差值，否则会返回第一组不相同的字符的ASCII码差值。<br>format静态方法（和printf用法类似）</p><h3 id="StringBuffer类（可增删，效率较高，线程安全）"><a href="#StringBuffer类（可增删，效率较高，线程安全）" class="headerlink" title="StringBuffer类（可增删，效率较高，线程安全）"></a>StringBuffer类（可增删，效率较高，线程安全）</h3><p>StringBuffer的直接父类是AbstractStringBuilder<br>在父类中有属性char[] value,不是final修饰的，因此该value指向一个<strong>存放在堆中</strong>的字符串<br>StringBuffer是一个final类。</p><h4 id="String-gt-StringBuffer"><a href="#String-gt-StringBuffer" class="headerlink" title="String -&gt; StringBuffer"></a>String -&gt; StringBuffer</h4><p>1.StringBuffer strB &#x3D; new StringBuffer(str);<br>2.StringBuffer strB &#x3D; new StringBuffer();  strB &#x3D; strB.append(str)  append)()会返回当前对象的指向</p><h3 id="StringBuilder（可增删，效率最高，线程不安全）"><a href="#StringBuilder（可增删，效率最高，线程不安全）" class="headerlink" title="StringBuilder（可增删，效率最高，线程不安全）"></a>StringBuilder（可增删，效率最高，线程不安全）</h3><p>与StringBuffer地API兼容，是它的一个简易替换，但<strong>线程不安全</strong>，在单线程情况下建议使用。</p><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p>有SimpleDateFormat类可以与其配套使用<br>SimpleDateFormat用于初始化的参数为日期的格式（字符串）<a href="https://www.runoob.com/java/java-date-time.html">日期时间的格式化代码</a><br>SimpleDateFormat中有方法format可以使日期时间按要求输出<br>parse方法可以用来将字符串转为日期格式（要与其自身格式相符合）（有异常需要处理）</p><h3 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h3><p>Calendar是一个抽象类，且其构造器是私有的，需要用getInstance来获取实例</p><h3 id="LocalDateTime-LocalDate-LocalTime"><a href="#LocalDateTime-LocalDate-LocalTime" class="headerlink" title="LocalDateTime LocalDate LocalTime"></a>LocalDateTime LocalDate LocalTime</h3><p>LocalDateTime获取年月日时分秒 LocalDate获取年月日 LocalTime获取时分秒<br>DateTimeFormatter用于对它进行格式化<br>DateTimeFormatter dtf &#x3D; DateTimeFormatter.ofPattern(“格式”)</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>规则 :<br>所有泛型方法都有一个类型参数声明部分，声明在方法返回类型之前<br>类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数占位符<br>类型参数只能代表<strong>引用类型</strong><br>在指定类型参数后可以传入该类型或其子类型，默认情况下会给Object类型</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>泛型类： class 类名 &lt;&gt;</p><ul><li>普通成员可以使用泛型（属性、方法）</li><li>使用泛型的数组不能初始化（类型不确定，开辟的空间大小未知）</li><li>静态方法中不能使用类的泛型（静态方法会跟着类的加载进行加载，而当时类的泛型尚未确定），但可以使用方法的泛型</li><li>泛型类的类型，是在创建对象时确定的</li></ul><p>泛型接口：interface 接口名 &lt;&gt;</p><ul><li>静态成员不能使用泛型</li><li>泛型接口的类型参数，在<em>继承接口</em>或<em>实现接口</em>时确定</li></ul><p>泛型方法：&lt;&gt; 返回类型 函数名()</p><ul><li>可以定义在普通类或泛型类中</li><li>泛型被调用时类型会被确定，即对应的类型参数会被绑定到对应类型，但调用结束后会取消绑定。</li></ul><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>规则:在类名后声明类型参数</p><h3 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h3><p>一般使用？代替具体的类型参数<br>类型通配符上限:<br>&lt;? extends class&gt; 泛型参数只能是class子类.<br>类型通配符下限:<br>&lt;? super class&gt; 泛型参数只能是class父类.</p><h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><p>主要包含两种类型的容器：<br>1.Collection 存储一个元素集合 其下有两重要子集 List Set（Collection没有直接实现子类，而是通过子接口实现）<br>2.Map 存储键&#x2F;值对映射</p><p><strong>在集合中存储的均为对象的引用，因此若在插入集合后对元素进行修改可能会影响删除操作</strong><br>例如在HashSet中，若修改与计算hash值有关的对象属性，则可能会导致删除不成功，因为修改前与修改后生成的hash值不同</p><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><h4 id="Set和List"><a href="#Set和List" class="headerlink" title="Set和List"></a>Set和List</h4><p>Set接口的存储是无序的，不重复的数据。List接口实例存储的是有序的，可重复的元素<br>Set检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变<br>List和数组类似，可以动态增长，根据实际存储的数据的长度自动增长，查找效率高，插入删除效率低。</p><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>ArrayList底层是用<strong>数组</strong>来实现的<br>ArrayList与Vector之间的区别就是ArrayList是<strong>线程不安全</strong>的。<br>ArrayList中维护了一个Object类型的数组 transient Object[] elementData</p><h5 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h5><p>若使用无参构造器来创建，则初始化容量为0，第一个元素添加时，将容量扩展至10，此后如需再次扩容，则扩容为当前容量大小的1.5倍。<br>若使用指定容量的构造器，则之后扩容时，直接1.5倍。<br>扩容使用的是Arrays.copyOf()</p><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>Vector底层是 protected Object[] elementData<br>Vector<strong>线程安全</strong><br>扩容机制：<br>如果是无参，默认10，满后按2倍扩。若有参，直接按2倍扩。</p><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>底层实现了双向链表和双端队列<br>可以添加任意元素<br>线程不安全</p><h4 id="Java-Iterator"><a href="#Java-Iterator" class="headerlink" title="Java Iterator"></a>Java Iterator</h4><p>iterator本身不存储数据，只用于遍历集合<br>迭代器可以类比为有头结点的链表<br>迭代器it三个基本操作：next, hasNext, remove<br>it.next() 返回下一个元素（Object），并且更新迭代器的状态<br>it.hasNext()用于检测集合中是否还有元素<br>it.remove() 将迭代器返回的元素删除 remove掉的是当前指向的元素，而非next元素</p><p>获取迭代器：集合想获取一个迭代器可以使用iterator()方法</p><p><strong>增强for的底层就是迭代器。</strong></p><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>底层机制：<br>1.底层是HashMap <strong>用邻接表实现</strong>他的装载因子默认是0.75<br>2.添加一个元素时，先得到hash值，然后转成索引值<br>3.找到存储数据的表table，检查当前位置是否已经存放了元素<br>4.如果没有数据就直接插入，<br>   如果有数据，调用<strong>equals（调用的是当前对象的equals）</strong>比较，如果相同，则放弃添加，如果不相同就添加到最后。<br>5.若一条链表的元素个数超过TREEIFY_THRESHOLD(默认为8)，并且table的大小&gt;&#x3D;MIN_TREEIFY_CAPACITY(默认为64)，就会进行树化（红黑树），若链表个数超限，而表空间充足，则优先将表扩容(每次容量都*2)。</p><p>add详细过程：<br>首先检查是否为空表，若为空表，则将其大小初始化为16<br>接着用插入对象的hashCode计算hash值（hashCode和hash值不一样）<br>然后用hash值计算得到对应的数据表中的索引<br>如果对应索引为空，则new一个Node直接插入<br><strong>如果对应索引不为空：<br>(1)若插入位置已有对象的hash于插入对象的hash相同，且满足键值相同（即对象地址）或是调用当前对象的equals方法得到true则不插入<br>(2)若p为树节点，则调用红黑树的对应方法<br>(3)进入表中对应索引的链表，依次比较（方法同情况（1）相同）在插入完成后立即判断当前结点数是否达到8，若达到则进行树化（实际上在table表元素个数到64的情况下才会真的树化）</strong><br>当结点数&gt;0.75*容量时，扩容</p><h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><p>底层维护一个<strong>数组+双向链表</strong><br>双向链表结点 Entry 内含元素：before，after，数据<br>表中元素为：head, tail, table, entrySet<br>双向链表使得LinkedHashSet具备插入顺序与遍历顺序相同的特征，每一次插入，首先会找到对应hash值的索引的首个结点，然后从该节点开始沿着双向链表一个个比较，因此相比HashSet效率偏低。总结：双向链表将原本分布在table各索引中的结点串成了一串。</p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>table:HashMap$Node[]<br>Map中的key和value可以是任何<strong>引用类型</strong>的数据，会封装到HashMap$Node(实现Entry接口)<br>Map中的key不允许重复（具体去重操作同HashSet），若插入重复key，则后插入的value会覆盖之前的，且为null的key只能有一个，且会将被覆盖的value返回。<br>Map中的value可以重复<br>Map会维护一个entrySet用于方便遍历Map中的数据，其中的Entry是Node的父类，并且提供getKey和getValue方法，<strong>存储的是表中数据的地址</strong>。<br>HashMap线程不安全。</p><h4 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h4><p>key和value都<strong>不能为null</strong><br>线程安全<br>使用方法同HashMap一样<br>底层：维护一个数组HashTable$Entry[] table 初始化大小为11<br>每次扩容将当前大小*2 + 1</p><h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h4><p>继承了HashTable，且实现了Map接口</p><h4 id="TreeSet（带Tree的都可以排序）"><a href="#TreeSet（带Tree的都可以排序）" class="headerlink" title="TreeSet（带Tree的都可以排序）"></a>TreeSet（带Tree的都可以排序）</h4><p>本质是二叉搜索树，其迭代器使用中序遍历<br>若用无参构造器创建TreeSet则其依旧是无序的，若要排序，需要传入一个Comparator对象<br>对<strong>键值</strong>调用比较方法（键值不可为空）<br>TreeSet的去重机制，调用构造时传入的Comparator对象进行比较，<strong>若没有传入，则会调用插入对象实现的Comparator接口，若没有实现会报错，因为在底层会尝试将传入对象转变为Comparable对象</strong></p><h4 id="Collection工具类"><a href="#Collection工具类" class="headerlink" title="Collection工具类"></a>Collection工具类</h4><p>reverse(Collection):反转集合中元素<br>shuffle(Collection):将元素随机排列<br>sort(Collection, [Comparator]):排序 默认从小到大<br>max(Collection, [Comparator])<br>min(Collection, [Comparator])<br>swap(Collection, int, int) :交换元素<br>frequency(Collection, Object):返回某元素出现次数<br>copy(Collection dest, Collection src):将src中的数据拷贝到dest中，前提是dest的大小不小于src的大小<br>replaceAll(List, Object oldVal, Object newVal)</p><h2 id="绘图技术"><a href="#绘图技术" class="headerlink" title="绘图技术"></a>绘图技术</h2><p>1.先定义一个MyPanel类，继承JPanel类（MyPanel相当于画盘，其中paint方法的参数Graphics相当于画笔，带有很多画图方法）<br>2.让用于画图的类继承JFrame（一个框架，表示Graphics画图的界面）</p><h3 id="绘图原理"><a href="#绘图原理" class="headerlink" title="绘图原理"></a>绘图原理</h3><p>Component类提供了两个和绘图相关最重要的方法<br>1.paint(Graphics g)绘制组件外观<br>2.repaint()刷新组件外观</p><p>当组件<strong>第一次在屏幕显示的时候</strong>，程序会自动地调用paint()方法<br>在以下情况，paint()也会被调用：</p><ul><li>窗口最小化，再最大化</li><li>窗口的大小发生变化</li><li>repaint函数被调用</li></ul><p>获取图片资源<br>Image image &#x3D; Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(“图片所在路径（要放在项目的根目录下）”))</p><h2 id="Java事件处理机制"><a href="#Java事件处理机制" class="headerlink" title="Java事件处理机制"></a>Java事件处理机制</h2><p>java事件处理是采取“委派事件模型”。当事件发生时，<em>产生事件的对象，会把此“信息”传递给“事件的监听者”处理</em>，这里所说的“信息”实际上就是java.awt.event事件库里某个类所创建的对象。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是指运行中的程序，启动一个进程后，操作系统就会为该进程分配内存空间<br>进程是指程序的<strong>一次执行过程</strong>，或是正在运行的一个程序，是动态过程<br>只有进程中的所有线程全部死亡时，线程才会死亡</p><h3 id="线程-1"><a href="#线程-1" class="headerlink" title="线程"></a>线程</h3><p>线程是由进程创建的，是进程的一个实体。<br>一个进程可以拥有多个线程。</p><p>单线程：同一个时刻，只允许进行一个线程<br>多线程：同一个时刻，允许执行多个线程</p><p>并发：同一个时刻，多个任务<strong>交替进行</strong>， 单核CPU实现的多任务就是并发<br>并行：同一个时刻，多个任务同时执行，多核CPU可以实现并行</p><p>用户线程：当线程的任务执行完成或被通知结束时结束<br>守护线程：一般是为工作线程服务，当所有的用户线程结束时，守护线程自动结束<br>常见的守护线程：垃圾回收机制<br>将一个线程设置为守护线程：调用setDaemon() </p><p>JVM在所有非守护线程退出后退出</p><h4 id="线程的礼让与插队"><a href="#线程的礼让与插队" class="headerlink" title="线程的礼让与插队"></a>线程的礼让与插队</h4><p>yield:线程礼让，让出CPU，让其他线程执行，但礼让的事件不确定，所以也不一定礼让成功（当系统认为CPU资源充足时不会礼让）<br>join:线程插队，插队的线程一旦插队成功，则肯定先执行完插入的线程所有任务</p><h4 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h4><ul><li>新建状态：使用new关键字和Thread类或其子类建立一个线程对象后，该线程对象就处于新建状态，它保持这个状态直到程序start()这个线程</li><li>就绪状态：当线程对象调用了start()方法之后，该线程就进入就绪状态，此时线程处于就绪队列中，等待JVM里线程调度器的调度 <strong>实现多线程的核心</strong></li><li>运行状态：就绪状态的线程获取CPU资源，就可以执行run()，此时它就处于运行状态，<em>它可以变为阻塞状态，就绪状态和死亡状态</em> run()只是一个普通方法</li><li>阻塞状态:<br>如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：<ul><li>等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。</li><li>同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。</li><li>其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I&#x2F;O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I&#x2F;O 处理完毕，线程重新转入就绪状态。</li></ul></li><li>死亡状态</li></ul><h4 id="用Runnable接口创建线程"><a href="#用Runnable接口创建线程" class="headerlink" title="用Runnable接口创建线程"></a>用Runnable接口创建线程</h4><p>创建一个实现了Runnable接口的类，并实现run()，然后将其作为参数调用Thread的构造函数，用创建的thread类来调用start()<br>实现Runnable接口方式更加适合多个线程共享一个资源的情况，并且避免了单继承的限制。</p><h4 id="线程常用方法"><a href="#线程常用方法" class="headerlink" title="线程常用方法"></a>线程常用方法</h4><p>setName 设置线程名称<br>getName 返回线程名称<br>setPriority 更改线程优先级<br>getPriority 获取线程的优先级<br>interrupt 中断线程</p><h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><p>用synchronized修饰需要上锁的对象，使得该对象在任意时刻只能由一个线程访问<br>锁可以简单理解为一个标记对象，当该对象处于调用状态时代表别的线程此刻不能进行相关操作<br>同步方法&#x2F;代码块（非静态的）的锁可以是this，也可以是其他属性对象（要求各线程能接触到的锁是同一个对象）<br>同步方法&#x2F;代码块（静态的）的锁就是对象本身</p><h4 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h4><ul><li>当前线程的同步方法、同步代码块执行结束</li><li>当前线程在同步代码块中遇到break，return</li><li>当前线程在同步代码块，同步方法中出现了未处理的Error或Exception导致异常结束</li><li>当前线程在同步代码块，同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁</li></ul><p>注：当线程执行同步代码块或同步方法时，程序调用Thread.sleep()或yield()不会释放锁</p><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>文件在程序中是以<em>流的形式</em>来操作<br>流：数据在数据源（文件）和程序（内存）之间经历的路径<br>输入流：数据从数据源（文件）到程序（内存）的路径<br>输出流：数据从程序（内存）到数据源（文件）的路径</p><p>流的分类：<br>按操作数据单位：字节流（8bit）二进制文件，字符流（按字符）文本文件<br>按数据流的流向：输入流，输出流<br>按流的角色：节点流，处理流&#x2F;包装流</p><p>字节流: InputStream OutputStream<br>字符流:Reader Writer</p><p><strong>所有用到缓冲区的输出流每次写入完成后要刷新才能将数据写入</strong></p><p>PS:在不需要流之后要将其关闭，避免资源浪费。</p><h3 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h3><p>节点流：可以从一个<strong>特定</strong>的数据源读写数据<br>处理流：可以从<strong>任意</strong>数据源读写数据，并且自带缓冲  一般前缀为Buffered</p><p>处理流的构建：在构建时向其传入一个节点流，即可使其同时具备对应节点流与处理流带有的扩充功能。<br>关闭处理流：只需关闭外层流即可，内部的节点流会在close方法中被关闭<br><em>BufferedReader&#x2F;BufferedWriter不适合处理二进制文件</em></p><p>System.in 表示标准输入 键盘<br>编译类型：InputStream<br>运行类型：BufferedInputStream</p><p>System.out 表示标准输出 显示器<br>编译类型：PrintStream<br>运行类型：PrintStream</p><h4 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h4><p>可以将读取到的字节数据经过指定编码转换成字符 InputStreamReader<br>可以将读取到的字符数据经过指定编码转换成字节 OutputStreamWriter</p><p>应用场景:</p><ul><li>源或者目的对应的设备是字节流，但是操作的却是文本数据</li><li>操作文本涉及到具体的指定编码表</li></ul><p>打印流：PrintWriter, PrintStream(只有输出没有输入)</p><h2 id="Java序列化"><a href="#Java序列化" class="headerlink" title="Java序列化"></a>Java序列化</h2><p>机制:<br>一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型<br>将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化(读取顺序必须和存储顺序一致)<br>类ObjectInputStream和ObjectOutputStream是高层次的数据流，他们包含反序列化和序列化对象的方法。</p><p>一个类的对象要想序列化成功，必须满足两个条件:<br>1.该类必须实现java.io.Serializable接口<br>2.该类的所有属性必须是可序列化的，如果有一个属性不是可序列化的，则该属性必须注明是短暂的。</p><p>注意事项：</p><ul><li>存储与读取的顺序必须一致</li><li>static或transient修饰的属性不会被序列化</li><li>序列化对象时，要求内部的属性也实现序列化接口</li></ul><p><a href="https://www.runoob.com/java/java-serialization.html">序列化知识</a></p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><ul><li>定义：能够分析类能力的程序称为反射</li><li>作用：<br>1.在运行时分析类的能力<br>2.在运行时查看对象<br>3.实现通用的数组操作代码<br>4.利用Method对象</li><li>价值：在不修改源码的情况下，增加、修改功能</li><li>原理：JVM将类的字节码文件通过类加载器生成Class类对象存放在堆中（每个类只生成一个）</li></ul><h3 id="2-常用类"><a href="#2-常用类" class="headerlink" title="2.常用类"></a>2.常用类</h3><p>java.lang.reflect包中有三个类</p><ul><li><p>Field 用于描述类的域</p></li><li><p>Method 用于描述类的方法</p></li><li><p>Constructor 用于描述类的构造器</p><p>（具体内容详见java核心技术P194）</p></li></ul><p><em>私有属性，方法，构造器，不可通过对应的getXXX()获得</em></p><h4 id="2-1Class类"><a href="#2-1Class类" class="headerlink" title="2.1Class类"></a>2.1Class类</h4><p>在程序加载完类之后，会调用ClassLoader创建该类的一个Class对象，并将其存储在堆中，其中保存了该类的所有信息。<strong>（每一个类只会创建一个Class对象）</strong></p><p>同时会在方法区存储类的二进制数据</p><p><em>PS:一个Class对象实际上表示的是一个类型，而这个类型未必一定是一种类（也有可能是原始数据类型 ，eg:int.class就是一个Class类，但int不是一个类）</em></p><p>newInstance()可用于动态的创建一个类的实例,他调用<strong>默认的</strong>构造器初始化新创建的对象。</p><pre class=" language-Java"><code class="language-Java">`eg:` `String s = "java.util.Random";``Object m = Class.forName(s).newInstance();`</code></pre><p>调用有参构造器</p><pre><code>Class cls = Class.getForName(&quot;Cat&quot;);Constructor constructor = cls.getConstructor(String.class);//获取构造器，参数为获取的构造器需要的参数的Class类Object o1 = constructor.newInstance(&quot;Cat&quot;);</code></pre><p><em>注意：在反射中都是用方法调用对象,若有返回值，则只会返回Object</em></p><pre class=" language-java"><code class="language-java">method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span></code></pre><p>反射调用优化：Field, Method, Constructor均有setAccessible(boolean)方法，设置为true可以关闭安全检查。(但会使得私有成员可以被访问)</p><h4 id="2-2获取Class类"><a href="#2-2获取Class类" class="headerlink" title="2.2获取Class类"></a>2.2获取Class类</h4><ol><li><p>已知一个类的全类名，且该类在类路径下，可通过Class.forName()获取</p><p>应用场景：多用于配置文件，读取类全路径，加载类</p><pre><code>String ClassFullPath = &quot;com.test.Cat&quot;;Class cls = Class.forName(ClassFullPath);</code></pre></li><li><p>已知具体的类，通过类的class获取，最安全可靠，且程序性能最高</p><p>应用场景：参数传递</p><pre><code>class Test&#123;&#125;...Class class = Test.class</code></pre></li><li><p>已知实例，则可直接通过getClass()方法获得。</p></li><li><p>包装类可获取TYPE属性，它的哈希值与其对应的基本数据类型的Class的hash值相同.</p></li></ol><h3 id="3-类的加载"><a href="#3-类的加载" class="headerlink" title="3.类的加载"></a>3.类的加载</h3><h4 id="3-1静态，动态加载"><a href="#3-1静态，动态加载" class="headerlink" title="3.1静态，动态加载"></a>3.1静态，动态加载</h4><ul><li>静态加载：编译时就加载相关类，依赖性较强</li><li>动态记载：运行时加载需要的类</li></ul><h4 id="3-2类的加载时机"><a href="#3-2类的加载时机" class="headerlink" title="3.2类的加载时机"></a>3.2类的加载时机</h4><ul><li>创建对象时 &#x2F;&#x2F;静态加载</li><li>子类被加载时，父类也一并会被加载 &#x2F;&#x2F;静态加载</li><li>调用类中的静态成员时 &#x2F;&#x2F;静态加载</li><li>反射 &#x2F;&#x2F;动态加载</li></ul><h4 id="3-3类加载的过程"><a href="#3-3类加载的过程" class="headerlink" title="3.3类加载的过程"></a>3.3类加载的过程</h4><ol><li><p>加载：将类的class文件读入内存，并创建一个java.lang.Class对象</p></li><li><p>连接：将类的二进制数据合并到JRE中</p><ol><li><p>验证：安全校验</p><p>​目的：确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会威胁虚拟机自身安全</p><p>​包括：文件格式验证（是否以魔数oxcafebabe开头）、元数据验证、字节码验证和符号引用验证</p><p>​PS：可以使用-Xverify:none参数来关闭大部分的类验证措施</p></li><li><p>准备：在该阶段对<strong>静态变量</strong>分配内存，并进行<strong>默认初始化</strong>（将其初始化为一个默认值，而非程序指定的值）</p><p>​  而对于<strong>静态常量</strong>则会<strong>直接赋值</strong>。</p></li><li><p>解析：JVM将常量池内的符号引用替换为直接引用的过程（可以理解为从图纸到实物的过程）</p></li></ol></li><li><p>初始化：JVM负责对类进行初始化，主要是<strong>静态成员</strong></p><p>​真正开始执行类中定义的Java程序代码，此阶段是执行&lt;clinit&gt;()方法的过程</p><p>​该方法由编译器按语句在<strong>源文件中出现的顺序</strong>，依次收集类中的所有<strong>静态变量</strong>的赋值动作和<strong>静态代码块</strong>中的语句，并进行合并。（该方法有线程锁）</p></li></ol><p>类加载后内存布局：</p><p>在<u>方法区</u>中存储类的二进制数据，并根据它在<u>堆</u>中生成一个类的Class对象</p><h4 id="3-4通过反射创建对象"><a href="#3-4通过反射创建对象" class="headerlink" title="3.4通过反射创建对象"></a>3.4通过反射创建对象</h4><p>相关方法：</p><ul><li>Class:<ul><li>getConstructor(Class&lt;?&gt;) 获取对应参数列表的public构造器</li><li>getDeclaredConstructor(Class&lt;?&gt;)获取对应参数列表的任意构造器</li></ul></li><li>Constructor:<ul><li>newInstance()创建一个实例</li><li>setAccessible()暴破（暴破后可操作私有属性）</li></ul></li></ul><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><p>JDBC:提供一套<strong>统一的数据库接口</strong>由数据库厂商实现</p><h3 id="1-JDBC编写流程："><a href="#1-JDBC编写流程：" class="headerlink" title="1.JDBC编写流程："></a>1.JDBC编写流程：</h3><h5 id="1-1注册驱动：获取Driver类"><a href="#1-1注册驱动：获取Driver类" class="headerlink" title="1.1注册驱动：获取Driver类"></a>1.1注册驱动：获取Driver类</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//com.mysql.cj.jdbc.Driver</span>Driver driver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Driver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="1-2连接：获取Connection类"><a href="#1-2连接：获取Connection类" class="headerlink" title="1.2连接：获取Connection类"></a>1.2连接：获取Connection类</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//url jdbc:mysql://ip地址:端口号/数据库名称?serverTimezone=UTC"</span>String url <span class="token operator">=</span> <span class="token string">"jdbc:mysql://localhost:3306/coursecrash?serverTimezone=UTC"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//登录信息</span>Properties properties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>properties<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">,</span> <span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>properties<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">,</span> <span class="token string">"Cxc020603"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Connection connect <span class="token operator">=</span> driver<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> properties<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="1-3CRUD：发送SQL语句"><a href="#1-3CRUD：发送SQL语句" class="headerlink" title="1.3CRUD：发送SQL语句"></a>1.3CRUD：发送SQL语句</h5><pre class=" language-java"><code class="language-java">String sql <span class="token operator">=</span> <span class="token string">"insert into ade values('lgd', 'shen')"</span><span class="token punctuation">;</span>Statement statement <span class="token operator">=</span> connect<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> row <span class="token operator">=</span> statement<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="1-4释放资源"><a href="#1-4释放资源" class="headerlink" title="1.4释放资源"></a>1.4释放资源</h5><h3 id="2-数据库连接方式"><a href="#2-数据库连接方式" class="headerlink" title="2.数据库连接方式"></a>2.数据库连接方式</h3><ul><li>注册进DriverManage，方便统一管理</li></ul><pre class=" language-java"><code class="language-java">String url<span class="token operator">=</span> <span class="token string">"jdbc:mysql://localhost:3306/coursecrash?serverTimezone=UTC"</span><span class="token punctuation">;</span>String user <span class="token operator">=</span> <span class="token string">"root"</span><span class="token punctuation">;</span>String passwd <span class="token operator">=</span> <span class="token string">"Cxc020603"</span><span class="token punctuation">;</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> aClass <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.mysql.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String sql <span class="token operator">=</span> <span class="token string">"insert into ade values('lgd', 'shen')"</span><span class="token punctuation">;</span>Constructor<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> constructor <span class="token operator">=</span> aClass<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Driver driver1 <span class="token operator">=</span> <span class="token punctuation">(</span>Driver<span class="token punctuation">)</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>DriverManager<span class="token punctuation">.</span><span class="token function">registerDriver</span><span class="token punctuation">(</span>driver1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//注册驱动</span>Connection connection <span class="token operator">=</span> DriverManager<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> user<span class="token punctuation">,</span> passwd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Statement用于执行静态的SQL语句，并返回结果</span>Statement statement <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>statement<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//返回值为影响的行数</span>statement<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li><p>在类加载的时候（Class.forName()）会自动注册数据库驱动,因此可以省略</p></li><li><p>mysql驱动5.1.6以上可以无需Class.forName(),从jdk1.5以后使用了jdbc4，不再需要显式调用class.forName()注册驱动而是自动调用驱动jar包下META-INF\services\java.sql.Driver文本中的类名称去注册</p></li><li><p>通过配置文件获取连接的相关信息（软编码，推荐）</p></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException<span class="token punctuation">,</span> SQLException<span class="token punctuation">,</span> IOException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    Properties properties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    properties<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"src\\load.properties"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String user <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String password <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String url <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"url"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String driver <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>driver<span class="token punctuation">)</span><span class="token punctuation">;</span>        Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>driver<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//加载驱动类</span>    Connection connection <span class="token operator">=</span> DriverManager<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> user<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>    Statement statement <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//String sql = "create table TestTable (name varchar(5), age int, id int AUTO_INCREMENT, primary key(id))";</span>    String sql <span class="token operator">=</span> <span class="token string">"insert into testtable values ('cxc', 18, null),"</span> <span class="token operator">+</span>            <span class="token string">"('pcx', 18, null), ('lgd', 20, null)"</span><span class="token punctuation">;</span>    String sql1 <span class="token operator">=</span> <span class="token string">"delete from testtable where id=3"</span><span class="token punctuation">;</span>    statement<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>    statement<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span>sql1<span class="token punctuation">)</span><span class="token punctuation">;</span>    statement<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">url</span><span class="token punctuation">=</span><span class="token attr-value">jdbc:mysql://localhost:3306/coursecrash?serverTimezone=UTC</span><span class="token attr-name">user</span><span class="token punctuation">=</span><span class="token attr-value">root</span><span class="token attr-name">password</span><span class="token punctuation">=</span><span class="token attr-value">Cxc020603</span><span class="token attr-name">driver</span><span class="token punctuation">=</span><span class="token attr-value">com.mysql.jdbc.Driver</span></code></pre><p>ps:properties以字符串键值对存储，不需要加双引号</p><h3 id="3-ResultSet"><a href="#3-ResultSet" class="headerlink" title="3.ResultSet"></a>3.ResultSet</h3><p>用exectueQuery(sql)处理传入的select语句后会返回一个结果集</p><pre class=" language-java"><code class="language-java">ResultSet resultSet <span class="token operator">=</span> statement<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span>sql2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//previous()向上移动一行</span><span class="token comment" spellcheck="true">//相当于向下移动一行，初始状态下处于无效位置</span><span class="token keyword">while</span><span class="token punctuation">(</span>resultSet<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//取出指定列的数据</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>resultSet<span class="token punctuation">.</span><span class="token function">getXXX</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//XXX指该列的数据类型，//传入的参数可以是列的索引，也可以是列名</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>ResultSet中有一个rows属性，其数据类型为ArrayList,其中存储对象类数组，用于表示每一个数据</p><p><em>ResultSet与对应的连接绑定，一旦连接关闭，将无法再使用结果集</em></p><h3 id="拓展：SQL注入"><a href="#拓展：SQL注入" class="headerlink" title="拓展：SQL注入"></a>拓展：SQL注入</h3><p>Statement存在SQL注入风险</p><p>SQL注入：利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的SQL语句段或命令，恶意攻击数据库</p><p>eg：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> ClassNotFoundException<span class="token punctuation">,</span> SQLException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    Scanner scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>    Properties properties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    properties<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"src\\load.properties"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String user <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String driver <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String password <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String url <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"url"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>driver<span class="token punctuation">)</span><span class="token punctuation">;</span>    Connection connection <span class="token operator">=</span> DriverManager<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> user<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>    Statement statement <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"输入用户名："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String user1 <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"输入密码"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String passwd <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String sql <span class="token operator">=</span> <span class="token string">"select * from admin where name = '"</span> <span class="token operator">+</span> user1 <span class="token operator">+</span> <span class="token string">"' and password = '"</span> <span class="token operator">+</span> passwd <span class="token operator">+</span> <span class="token string">"'"</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>    ResultSet resultSet <span class="token operator">=</span> statement<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>resultSet<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        String sucess <span class="token operator">=</span> <span class="token string">"登陆成功"</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sucess<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        String fail <span class="token operator">=</span> <span class="token string">"Fail"</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>fail<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>运行结果</p><pre><code>输入用户名：1&#39;输入密码or &#39;1&#39;=&#39;1select * from admin where name = &#39;1&#39;&#39; and password = &#39;or &#39;1&#39;=&#39;1&#39;登陆成功Process finished with exit code 0</code></pre><h3 id="4-PreparedStatement"><a href="#4-PreparedStatement" class="headerlink" title="4.PreparedStatement"></a>4.PreparedStatement</h3><p>预处理Statement</p><p>预编译：在调用prepareStatement()时会直接将SQL语句提交给数据库编译，得到的PreparedStatement句柄是一个预编译好的SQL语句，添加参数后可直接执行。</p><p>将自身与某一sql语句绑定，sql语句中的参数用“？”作为占位符(占位符两边会自动加上引号)</p><p>因此占位符只能占位SQL语句中的普通值，绝不能占位表名，SQL关键字</p><p>调用setXXX(占位符的索引，占位符的值)方法来填充参数（参数索引从1开始）</p><pre class=" language-java"><code class="language-java">String sql <span class="token operator">=</span> <span class="token string">"select * from admin where name = ? and password = ?;"</span><span class="token punctuation">;</span>Connection connection <span class="token operator">=</span> DriverManager<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> user<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//此处将上方的sql语句与PreparedStatement绑定</span>PreparedStatement preparedStatement <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"输入用户名："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String user1 <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"输入密码"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String passwd <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>preparedStatement<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>preparedStatement<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>passwd<span class="token punctuation">)</span><span class="token punctuation">;</span>ResultSet resultSet <span class="token operator">=</span> preparedStatement<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>resultSet<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"success"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">else</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"failure"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>优势：</p><ul><li>不通过字符串拼接写SQL语句</li><li>可以防止SQL注入（自动在占位符两边添加引号）</li></ul><h3 id="5-JDBC事务处理"><a href="#5-JDBC事务处理" class="headerlink" title="5.JDBC事务处理"></a>5.JDBC事务处理</h3><p>开启事务： 调用Connect对象的setCommit(false)方法</p><p><em>默认情况下自动提交</em></p><p>提交事务：调用Connect对象的commit()方法</p><p>回滚：调用Connect对象的rollback([savepoint])方法</p><h3 id="6-批处理"><a href="#6-批处理" class="headerlink" title="6.批处理"></a>6.批处理</h3><p>通常与PreparedStatement搭配使用</p><p>在连接MySQL的url中添加参数rewriteBatchedStatements&#x3D;true</p><p>addBatch()将当前的sql语句添加到批处理包中</p><p>executeBatch()将包中的sql语句全部执行一遍</p><p>clearBatch()清空包</p><pre class=" language-java"><code class="language-java">Connection connect <span class="token operator">=</span> JDBCUtil<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>PreparedStatement preparedStatement <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//String sql = "insert into ade values (?, ?)";</span>String sql <span class="token operator">=</span> <span class="token string">"delete from ade where name=?"</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    preparedStatement <span class="token operator">=</span> connect<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        preparedStatement<span class="token punctuation">.</span><span class="token function">setString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"cxc"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//preparedStatement.setString(2, "ohh");</span>        preparedStatement<span class="token punctuation">.</span><span class="token function">addBatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    preparedStatement<span class="token punctuation">.</span><span class="token function">executeBatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    preparedStatement<span class="token punctuation">.</span><span class="token function">clearBatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> end <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>作用：批量处理数据，减少编译次数，以及发送sql语句的网络开销</p><h3 id="7-数据库连接池"><a href="#7-数据库连接池" class="headerlink" title="7.数据库连接池"></a>7.数据库连接池</h3><h4 id="7-1传统的获取连接的方式的问题分析"><a href="#7-1传统的获取连接的方式的问题分析" class="headerlink" title="7.1传统的获取连接的方式的问题分析"></a>7.1传统的获取连接的方式的问题分析</h4><ol><li>每次向数据库建立连接都需要将Connection加载到内存中，再验证IP地址，用户名和密码，需要数据库连接时就申请一个，频繁连接会占用大量资源，造成服务器崩溃</li><li>每次连接使用完都得断开，若程序出现异常未能关闭，会导致数据库内存泄漏</li><li>不能控制创建的连接数量，若连接过多，也有可能导致内存泄漏，MySQL崩溃（没有缓冲机制）</li></ol><h4 id="7-2连接池基本介绍"><a href="#7-2连接池基本介绍" class="headerlink" title="7.2连接池基本介绍"></a>7.2连接池基本介绍</h4><ol><li>预先向缓冲池中加入一定数量的连接<strong>（已经创建好的）</strong></li><li>数据库连接池负责分配，管理和释放数据库连接，他允许应用程序<strong>重复</strong>使用一个现有的数据库连接。每次程序使用完成之后，<strong>只是连接的引用消失，但连接本身依旧存在</strong></li><li>当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列</li></ol><h4 id="7-3-c3p0连接池"><a href="#7-3-c3p0连接池" class="headerlink" title="7.3 c3p0连接池"></a>7.3 c3p0连接池</h4><ol><li>导入jar包</li></ol><p>连接方式1：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> SQLException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    ComboPooledDataSource comboPooledDataSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ComboPooledDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Properties properties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    properties<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"src\\load.properties"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String user <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String password <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String driver <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String url <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"url"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        comboPooledDataSource<span class="token punctuation">.</span><span class="token function">setDriverClass</span><span class="token punctuation">(</span>driver<span class="token punctuation">)</span><span class="token punctuation">;</span>        comboPooledDataSource<span class="token punctuation">.</span><span class="token function">setJdbcUrl</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>        comboPooledDataSource<span class="token punctuation">.</span><span class="token function">setUser</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        comboPooledDataSource<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">PropertyVetoException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    comboPooledDataSource<span class="token punctuation">.</span><span class="token function">setInitialPoolSize</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    comboPooledDataSource<span class="token punctuation">.</span><span class="token function">setMaxPoolSize</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        Connection connection <span class="token operator">=</span> comboPooledDataSource<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        connection<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> end <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>连接方式2（配置文件）：</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 文件名 c3p0-config.xml 放置在src文件夹下 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>c3p0-config</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 数据源名称 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>named-config</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mySource<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 若为default-config 则在生成管理对象时不需要传入参数 --></span>        <span class="token comment" spellcheck="true">&lt;!-- 驱动类 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>driverClass<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>com.mysql.cj.jdbc.Driver<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- url --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbcUrl<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>jdbc:mysql://localhost:3306/coursecrash?serverTimezone=UTC<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- user --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>root<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- password --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Cxc020603<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 初始化连接池中的连接数量大小 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>initialPoolSize<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>10<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 最大连接时长 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>maxIdleTime<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>30<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 最大连接数 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>maxPoolSize<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>100<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 最小连接数 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>minPoolSize<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>10<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>named-config</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>c3p0-config</span><span class="token punctuation">></span></span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">connect2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> SQLException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    ComboPooledDataSource mySource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ComboPooledDataSource</span><span class="token punctuation">(</span><span class="token string">"mySource"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Connection connection <span class="token operator">=</span> mySource<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    connection<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h4 id="7-4德鲁伊连接池"><a href="#7-4德鲁伊连接池" class="headerlink" title="7.4德鲁伊连接池"></a>7.4德鲁伊连接池</h4><p>导入jar包</p><p>配置文件：</p><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># 数据库连接参数</span><span class="token attr-name">url</span><span class="token punctuation">=</span><span class="token attr-value">jdbc:mysql://localhost:3306/coursecrash?serverTimezone=UTC&amp;rewriteBatchedStatements=true</span><span class="token attr-name">username</span><span class="token punctuation">=</span><span class="token attr-value">root</span><span class="token attr-name">password</span><span class="token punctuation">=</span><span class="token attr-value">Cxc020603</span><span class="token comment" spellcheck="true"># 驱动</span><span class="token attr-name">driverClassName</span><span class="token punctuation">=</span><span class="token attr-value">com.mysql.cj.jdbc.Driver</span><span class="token comment" spellcheck="true"># 连接池的参数</span><span class="token comment" spellcheck="true"># 初始虎啊连接数</span><span class="token attr-name">initialSize</span><span class="token punctuation">=</span><span class="token attr-value">10</span><span class="token comment" spellcheck="true">#最大连接数</span><span class="token attr-name">maxActive</span><span class="token punctuation">=</span><span class="token attr-value">10</span><span class="token comment" spellcheck="true">#最大等待时长</span><span class="token attr-name">maxWait</span><span class="token punctuation">=</span><span class="token attr-value">200</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">druid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    Properties properties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    properties<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token string">"src\\druid.properties"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    DataSource dataSource <span class="token operator">=</span> DruidDataSourceFactory<span class="token punctuation">.</span><span class="token function">createDataSource</span><span class="token punctuation">(</span>properties<span class="token punctuation">)</span><span class="token punctuation">;</span>    Connection connection <span class="token operator">=</span> dataSource<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    connection<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="8-ApDBUtils"><a href="#8-ApDBUtils" class="headerlink" title="8. ApDBUtils"></a>8. ApDBUtils</h3><h4 id="8-1-POJO-简单java对象"><a href="#8-1-POJO-简单java对象" class="headerlink" title="8.1 POJO(简单java对象)"></a>8.1 POJO(简单java对象)</h4><p>创建一个java对象，用其中的属性，映射ResultSet中的各个字段</p><h4 id="8-2-DBUtils类"><a href="#8-2-DBUtils类" class="headerlink" title="8.2 DBUtils类"></a>8.2 DBUtils类</h4><ol><li>QueryRunner类：该类封装了SQL的执行方法，<em>线程安全</em>，可以实现增删改查</li><li>ResultSetHandler接口：该接口用于处理java.sql.ResultSet,将数据按要求转换为另一种形式（POJO）</li></ol><p>常用ResultSet接口实现类：</p><ul><li>ArrayHandler:把结果集中的每一行数据都转成一个数组，再存放到List中</li><li>BeanHandler:将结果集中的第一行数据封装到一个POJO中</li><li>BeanListHandler:将结果集中的每一行数据都封装到一个对应的POJO实例中</li><li>ScalarHandler:若结果中只有单个值，则用该实现类处理，若有多个值，则会返回第一列数据处理后结果。</li></ul><h4 id="8-3基本使用"><a href="#8-3基本使用" class="headerlink" title="8.3基本使用"></a>8.3基本使用</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> SQLException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//获取连接</span>    Connection connection <span class="token operator">=</span> DruidUtils<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//生成QueryRunner对象</span>    QueryRunner queryRunner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryRunner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//需要预编译处理的语句</span>    String sql <span class="token operator">=</span> <span class="token string">"select * from ade where name=?"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//query方法参数，连接，sql语句，ResultSetHandler接口，sql语句中的参数</span>    List<span class="token operator">&lt;</span>POJO<span class="token operator">></span> query <span class="token operator">=</span>            queryRunner<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span>connection<span class="token punctuation">,</span> sql<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">BeanListHandler</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>POJO<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"cxc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>POJO pojo <span class="token operator">:</span> query<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>pojo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    DruidUtils<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> null<span class="token punctuation">,</span> connection<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>query底层使用preparedStatement操作sql语句，并会自动关闭Statement与ResultSet，在转换ResultSet中的数据时，会通过反射获取POJO类的属性，构造器等，然后返回一个对应的数组形式的结果集合。</p><p><em>若要传入基础数据类型，则要使用对应的包装类， 基本数据类型不能为空</em></p><h3 id="9-BasicDao"><a href="#9-BasicDao" class="headerlink" title="9.BasicDao"></a>9.BasicDao</h3><p>DAO：data access object数据访问对象</p><p>此类对象专门用于对特定类的数据进行增删改查</p><p>具体关系：</p><p>XXPOJO映射XX表中的数据</p><p>XXDAO对XX表进行CRUD</p><h3 id="10-Dao-Service-Controller"><a href="#10-Dao-Service-Controller" class="headerlink" title="10.Dao, Service, Controller"></a>10.Dao, Service, Controller</h3><p>Dao：数据访问层，对数据进行增删改查</p><p>Service：业务逻辑层，通过Dao的组合实现具体的业务逻辑</p><p>Controller：控制层，转发Service的业务处理结果，但不暴露Service层的业务逻辑</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Remake | Makefile</title>
      <link href="/2022/06/29/make/"/>
      <url>/2022/06/29/make/</url>
      
        <content type="html"><![CDATA[<p>菜狗的Remake之路 – Makefile篇</p><span id="more"></span><h1 id="Make"><a href="#Make" class="headerlink" title="Make"></a>Make</h1><h2 id="1-程序的编译与链接"><a href="#1-程序的编译与链接" class="headerlink" title="1. 程序的编译与链接"></a>1. 程序的编译与链接</h2><p>编译： 将源文件编译成中间代码文件(.o文件)</p><p>​要求语法正确，函数与变量声明正确</p><p>链接： 将大量的Object File 合成可执行文件</p><p>​头文件所在位置，当中间文件很多时，需要给中间文件打包(生成 Archive File 即.a文件) </p><h2 id="2-Makefile概述"><a href="#2-Makefile概述" class="headerlink" title="2.  Makefile概述"></a>2.  Makefile概述</h2><h3 id="2-1-Makefile规则"><a href="#2-1-Makefile规则" class="headerlink" title="2.1 Makefile规则"></a>2.1 Makefile规则</h3><pre class=" language-makefile"><code class="language-makefile"><span class="token symbol">target ... </span><span class="token punctuation">:</span> prerequisites ...    command    ...</code></pre><ul><li>target : 要生成的目标文件&#x2F;可执行文件&#x2F;标签</li><li>prerequisites : 生成 target 需要的依赖文件</li><li>command : 该 target 要执行的Shell命令 (以tab开始)</li></ul><p>eg:</p><pre class=" language-bash"><code class="language-bash">tes <span class="token keyword">:</span> test.o    cc -o tes test.otest.o <span class="token keyword">:</span> test.c def.h    cc -c test.c.phony <span class="token keyword">:</span> cleanclean <span class="token keyword">:</span>     <span class="token function">rm</span> test.o tes</code></pre><h3 id="2-2-Makefile变量"><a href="#2-2-Makefile变量" class="headerlink" title="2.2 Makefile变量"></a>2.2 Makefile变量</h3><blockquote><p>变量定义</p></blockquote><pre><code>objects = main.o kbd.o command.o display.o \     insert.o search.o files.o utils.o     可理解为一个字符串</code></pre><blockquote><p>变量使用</p></blockquote><p>$(objects)</p><h3 id="2-3-Makefile自动推导"><a href="#2-3-Makefile自动推导" class="headerlink" title="2.3 Makefile自动推导"></a>2.3 Makefile自动推导</h3><p>可以自动推导文件以及文件依赖关系后面的命令</p><p>只要make看到一个 <code>.o</code> 文件，它就会自动的把 <code>.c</code> 文件加在依赖关系中，如果make找到一个 <code>whatever.o</code> ，那么 <code>whatever.c</code> 就会是 <code>whatever.o</code> 的依赖文件。并且 <code>cc -c whatever.c</code> 也会被推导出来</p><h3 id="2-4-Makefile-文件名"><a href="#2-4-Makefile-文件名" class="headerlink" title="2.4 Makefile 文件名"></a>2.4 Makefile 文件名</h3><p>make 会依次在当前目录下寻找 GNUmakefile , makefile , Makefile(建议使用)</p><p>指定make文件 : <code>make -f filename</code></p><h3 id="2-5-引用其他Makefile"><a href="#2-5-引用其他Makefile" class="headerlink" title="2.5 引用其他Makefile"></a>2.5 引用其他Makefile</h3><pre><code>include filename</code></pre><p>make命令开始时，会找寻 <code>include</code> 所指出的其它Makefile，并把其内容安置在当前的位置。就好像C&#x2F;C++的 <code>#include</code> 指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找：</p><ol><li>如果make执行时，有 <code>-I</code> 或 <code>--include-dir</code> 参数，那么make就会在这个参数所指定的目录下去寻找。</li><li>如果目录 <code>&lt;prefix&gt;/include</code> （一般是： <code>/usr/local/bin</code> 或 <code>/usr/include</code> ）存在的话，make也会去找。</li></ol><h2 id="3-书写规则"><a href="#3-书写规则" class="headerlink" title="3. 书写规则"></a>3. 书写规则</h2><h3 id="3-1-文件查找"><a href="#3-1-文件查找" class="headerlink" title="3.1 文件查找"></a>3.1 文件查找</h3><p>Makefile默认在当前目录下寻找目标文件和依赖文件</p><blockquote><p>VPATH 特殊变量</p></blockquote><p>当存在<code>VPath</code>变量时，若在当前目录找不到文件，会到VPath下的路径寻找。</p><pre class=" language-makefile"><code class="language-makefile">VPATH <span class="token operator">=</span> src<span class="token punctuation">:</span>../headers<span class="token comment" spellcheck="true"># 不同目录用 ':' 分割</span></code></pre><blockquote><p>vpath 关键字</p></blockquote><p>使用方法：</p><ul><li>vpath <pattern> <directories><br>为符合模式<pattern>的文件指定搜索目录<directories>。</li><li>vpath <pattern><br>清除符合模式<pattern>的文件的搜索目录。</li><li>vpath<br>清除所有已被设置好了的文件搜索目录。</li></ul><p>vapth使用方法中的<pattern>需要包含 <code>%</code> 字符。 <code>%</code> 的意思是匹配零或若干字符，（需引用 <code>%</code> ，使用 <code>\</code> ）例如， <code>%.h</code> 表示所有以 <code>.h</code> 结尾的文件。<pattern>指定了要搜索的文件集，而<directories>则指定了&lt; pattern&gt;的文件集的搜索的目录。例如：</p><pre><code>vpath %.h ../headers</code></pre><h3 id="3-2-伪目标"><a href="#3-2-伪目标" class="headerlink" title="3.2 伪目标"></a>3.2 伪目标</h3><p>伪目标是一个标签而不是文件，所以make无法生存它的依赖关系和决定是否要执行</p><blockquote><p>显示指明为目标</p></blockquote><pre class=" language-makefile"><code class="language-makefile"><span class="token builtin">.PHONY</span><span class="token symbol"> </span><span class="token punctuation">:</span> clean<span class="token symbol">clean </span><span class="token punctuation">:</span>     command</code></pre><h3 id="3-3-多目标"><a href="#3-3-多目标" class="headerlink" title="3.3 多目标"></a>3.3 多目标</h3><p>若多个目标同时依赖于某个文件，则可将其合并</p><pre class=" language-makefile"><code class="language-makefile"><span class="token symbol">bigoutput littleoutput </span><span class="token punctuation">:</span> text.g    generate text.g -<span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">subst</span> output,,<span class="token variable">$@</span><span class="token punctuation">)</span> > <span class="token variable">$@</span></code></pre><p>上述规则等价于</p><pre class=" language-makefile"><code class="language-makefile"><span class="token symbol">bigoutput </span><span class="token punctuation">:</span> text.g    generate text.g -big > bigoutput<span class="token symbol">littleoutput </span><span class="token punctuation">:</span> text.g    generate text.g -little > littleoutput</code></pre><h3 id="3-4-静态模式"><a href="#3-4-静态模式" class="headerlink" title="3.4 静态模式"></a>3.4 静态模式</h3><p>静态模式可以更加容易地定义多目标的规则</p><p>语法：</p><pre class=" language-makefile"><code class="language-makefile"><span class="token symbol">&lt;targets ...> </span><span class="token punctuation">:</span> &lt;target-pattern> <span class="token punctuation">:</span> &lt;prereq-patterns ...>    &lt;commands>    ...</code></pre><p>targets : 定义了一系列的目标文件，可以有通配符，是一个集合</p><p>target-pattern : 指明了targets的模式，也就是目标集的模式</p><p>prereq-patterns : 目标的依赖模式，它对target-pattern形成的模式再进行一次依赖目标的定义。</p><p>如果我们的<target-pattern>定义成 <code>%.o</code> ，意思是我们的<target>;集合中都是以 <code>.o</code> 结尾的，而如果我们的<prereq-patterns>定义成 <code>%.c</code> ，意思是对<target-pattern>所形成的目标集进行二次定义，其计算方法是，取<target-pattern>模式中的 <code>%</code> （也就是去掉了 <code>.o</code> 这个结尾），并为其加上 <code>.c</code> 这个结尾，形成的新集合。</p><p>eg : </p><pre class=" language-makefile"><code class="language-makefile">objects <span class="token operator">=</span> foo.o bar.o<span class="token symbol">all </span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span><span class="token symbol"><span class="token variable">$</span>(objects)</span><span class="token punctuation">:</span> %.o<span class="token punctuation">:</span> %.c    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -c <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token comment" spellcheck="true"># 展开后</span><span class="token comment" spellcheck="true">#foo.o : foo.c</span><span class="token comment" spellcheck="true">#    $(CC) -c $(CFLAGS) foo.c -o foo.o</span><span class="token comment" spellcheck="true">#bar.o : bar.c</span><span class="token comment" spellcheck="true">#    $(CC) -c $(CFLAGS) bar.c -o bar.o</span></code></pre><p>指明了我们的目标从$object中获取， <code>%.o</code> 表明要所有以 <code>.o</code> 结尾的目标，也就是 <code>foo.o bar.o</code> ，也就是变量 <code>$object</code> 集合的模式，而依赖模式 <code>%.c</code> 则取模式 <code>%.o</code> 的 <code>%</code> ，也就是 <code>foo bar</code> ，并为其加下 <code>.c</code> 的后缀，于是，我们的依赖目标就是 <code>foo.c bar.c</code> 。而命令中的 <code>$&lt;</code> 和 <code>$@</code> 则是自动化变量， <code>$&lt;</code> 表示第一个依赖文件， <code>$@</code> 表示目标集</p><h3 id="3-5自动生成依赖型"><a href="#3-5自动生成依赖型" class="headerlink" title="3.5自动生成依赖型"></a>3.5自动生成依赖型</h3><pre class=" language-shell"><code class="language-shell"># 查看指定文件的依赖性gcc -M main.cgcc -MM main.c</code></pre><p>为每一个.c文件生成一个.d文件，.d文件存放.c文件的依赖性</p><p>生成.d文件的规则</p><pre class=" language-makefile"><code class="language-makefile"><span class="token symbol">%.d</span><span class="token punctuation">:</span> %.c    <span class="token operator">@</span>set -e<span class="token punctuation">;</span> rm -f <span class="token variable">$@;</span> \    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -MM <span class="token variable">$</span><span class="token punctuation">(</span>CPPFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> > <span class="token variable">$@.$$$$;</span> \    sed <span class="token string">'s,\($*\)\.o[ :]*,\1.o $@ : ,g'</span> &lt; <span class="token variable">$@.$$$$</span> > <span class="token variable">$@;</span> \    rm -f <span class="token variable">$@.$$$$</span></code></pre><p>这个规则的意思是，所有的 <code>.d</code> 文件依赖于 <code>.c</code> 文件， <code>rm -f $@</code> 的意思是删除所有的目标，也就是 <code>.d</code> 文件，第二行的意思是，为每个依赖文件 <code>$&lt;</code> ，也就是 <code>.c</code> 文件生成依赖文件， <code>$@</code> 表示模式 <code>%.d</code> 文件，如果有一个C文件是name.c，那么 <code>%</code> 就是 <code>name</code> ， <code>$$$$</code> 意为一个随机编号，第二行生成的文件有可能是“name.d.12345”，第三行使用sed命令做了一个替换，关于sed命令的用法请参看相关的使用文档。第四行就是删除临时文件。</p><p>目的：</p><p>将</p><pre class=" language-makefile"><code class="language-makefile"><span class="token symbol">main.o </span><span class="token punctuation">:</span> main.c defs.h</code></pre><p>转成：</p><pre class=" language-makefile"><code class="language-makefile"><span class="token symbol">main.o main.d </span><span class="token punctuation">:</span> main.c defs.h</code></pre><p>使得.d文件可以自动更新</p><h2 id="4-书写命令"><a href="#4-书写命令" class="headerlink" title="4. 书写命令"></a>4. 书写命令</h2><h3 id="4-1显示命令"><a href="#4-1显示命令" class="headerlink" title="4.1显示命令"></a>4.1显示命令</h3><p>若在命令行前加<code>@</code>，则该命令不会被显示出来。</p><pre class=" language-makefile"><code class="language-makefile"><span class="token operator">@</span>echo <span class="token string">'Compiling'</span></code></pre><p>make -n 只显示命令，但不会执行，方便查看命令执行顺序</p><p>make -s 全面禁止命令的显示</p><h3 id="4-2命令执行"><a href="#4-2命令执行" class="headerlink" title="4.2命令执行"></a>4.2命令执行</h3><p>如果需要上一条命令的结果被应用于下一条命令，则应用<code>;</code>间隔两条命令，而不是换行</p><pre class=" language-makefile"><code class="language-makefile"><span class="token symbol">exec</span><span class="token punctuation">:</span>    cd ~<span class="token punctuation">;</span> pwd</code></pre><p>make -i 忽略所有错误</p><p>make -k 若某命令出错，则终止该命令，但其他命令照常执行</p><h3 id="4-3-嵌套执行make"><a href="#4-3-嵌套执行make" class="headerlink" title="4.3 嵌套执行make"></a>4.3 嵌套执行make</h3><blockquote><p>主控make</p></blockquote><pre class=" language-makefile"><code class="language-makefile"><span class="token symbol">subsystem</span><span class="token punctuation">:</span>    cd subdir &amp;&amp; <span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span></code></pre><blockquote><p>传递变量</p></blockquote><pre class=" language-makefile"><code class="language-makefile"><span class="token keyword">export</span> variable <span class="token comment" spellcheck="true">#传递变量</span><span class="token keyword">export</span> <span class="token comment" spellcheck="true">#传递所有变量</span><span class="token keyword">unexport</span> variable <span class="token comment" spellcheck="true">#不传递</span></code></pre><p>有两个变量，一个是 <code>SHELL</code> ，一个是 <code>MAKEFLAGS</code> ，这两个变量不管你是否export，其总是要传递到下层 Makefile中，特别是 <code>MAKEFLAGS</code> 变量，其中包含了make的参数信息，如果我们执行“总控Makefile”时有make参数或是在上层 Makefile中定义了这个变量，那么 <code>MAKEFLAGS</code> 变量将会是这些参数，并会传递到下层Makefile中，这是一个系统级的环境变量。</p><p>但是make命令中的有几个参数并不往下传递，它们是 <code>-C</code> , <code>-f</code> , <code>-h</code>, <code>-o</code> 和 <code>-W</code></p><h3 id="4-4定义命令包"><a href="#4-4定义命令包" class="headerlink" title="4.4定义命令包"></a>4.4定义命令包</h3><p>如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以 <code>define</code> 开始，以 <code>endef</code> 结束</p><pre class=" language-makefile"><code class="language-makefile"><span class="token keyword">define</span> run-yaccyacc <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">firstword</span> <span class="token variable">$^</span><span class="token punctuation">)</span>mv y.tab.c <span class="token variable">$@</span><span class="token keyword">endef</span></code></pre><h2 id="5-变量"><a href="#5-变量" class="headerlink" title="5. 变量"></a>5. 变量</h2><h3 id="5-1-变量的基础"><a href="#5-1-变量的基础" class="headerlink" title="5.1 变量的基础"></a>5.1 变量的基础</h3><p>变量在声明时要赋初值，在使用时，在变量名前加<code>$</code>，并将变量名用()包起来。</p><p>若要使用真实的<code>$</code>，输入<code>$$</code></p><blockquote><p>变量的定义</p></blockquote><p>使用<code>:=</code>运算符来定义变量</p><pre class=" language-makefile"><code class="language-makefile">x <span class="token operator">:=</span> fooy <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> barx <span class="token operator">:=</span> later</code></pre><p>如此，前面的变量便不能使用后面变量的值。</p><p>如果直接用<code>=</code>赋值，则前面的变量就不可以使用后面的变量（不推荐）</p><p><code>#注释符可以用来表示变量定义的终止</code></p><pre class=" language-makefile"><code class="language-makefile">nullstring <span class="token operator">:=</span>space <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>nullstring<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#end of line</span>dir <span class="token operator">:=</span> /foo/bar    <span class="token comment" spellcheck="true"># 4 space left</span></code></pre><p><code>?=</code>在变量未被赋值的情况下给他赋值，否则略过这条语句</p><pre class=" language-makefile"><code class="language-makefile">foo <span class="token operator">?=</span> bar</code></pre><h3 id="5-2-变量高级用法"><a href="#5-2-变量高级用法" class="headerlink" title="5.2 变量高级用法"></a>5.2 变量高级用法</h3><blockquote><p>变量值的替换</p></blockquote><p><code>$(var:a=b)</code>将变量var中所有以字串a<strong>结尾</strong>的‘a’替换为字串’b’。此处结尾指的是空格或结束符</p><p><code>$(var:%.c=%.d)</code>作用同上，此种通过静态模式定义。</p><blockquote><p>使用变量的变量</p></blockquote><p>Makefile中的变量类似于宏，可以用于拼接任意东西</p><pre class=" language-makefile"><code class="language-makefile">x <span class="token operator">=</span> variable1variable2 <span class="token operator">:=</span> Helloy <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">subst</span> 1,2,<span class="token variable">$</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>z <span class="token operator">=</span> ya <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><pre class=" language-makefile"><code class="language-makefile">first_second <span class="token operator">=</span> Helloa <span class="token operator">=</span> firstb <span class="token operator">=</span> secondall <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token variable">$a_$b</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># $a_$b 拼接成变量名</span></code></pre><pre class=" language-makefile"><code class="language-makefile"><span class="token keyword">ifdef</span> do_sort    func <span class="token operator">:=</span> sort<span class="token keyword">else</span>    func <span class="token operator">:=</span> strip<span class="token keyword">endif</span>bar <span class="token operator">:=</span> a d b g q cfoo <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># $(func) $(bar) 分别拼接成函数名及其参数</span></code></pre><blockquote><p>追加变量值</p></blockquote><p><code>+=</code></p><pre class=" language-makefile"><code class="language-makefile">variable <span class="token operator">:=</span> valuevariable <span class="token operator">+=</span> more<span class="token comment" spellcheck="true">#=== 等价于 ===#</span>variable <span class="token operator">:=</span> valuevariable <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>variable<span class="token punctuation">)</span> more</code></pre><blockquote><p>多行变量</p></blockquote><p>利用<code>define</code>关键字设置变量的值可以有换行，便于定义一系列命令。</p><p>变量的值可以包含函数、命令、文字，或是其它变量。因为命令需要以[Tab]键开头，所以如果你用define定义的命令变量中没有以 <code>Tab</code> 键开头，那么make 就不会把其认为是命令。</p><pre class=" language-makefile"><code class="language-makefile"><span class="token keyword">define</span> two-linesecho fooecho <span class="token variable">$</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token keyword">endef</span></code></pre><blockquote><p>override</p></blockquote><p>如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在Makefile中设置这类参数的值，那么，你可以使用“override”指示符。其语法是:</p><pre class=" language-makefile"><code class="language-makefile"><span class="token keyword">override</span> &lt;variable><span class="token punctuation">;</span> <span class="token operator">=</span> &lt;value><span class="token punctuation">;</span><span class="token keyword">override</span> &lt;variable><span class="token punctuation">;</span> <span class="token operator">:=</span> &lt;value><span class="token punctuation">;</span></code></pre><p>当然，你还可以追加:</p><pre><code>override &lt;variable&gt;; += &lt;more text&gt;;</code></pre><h3 id="5-3-特殊变量"><a href="#5-3-特殊变量" class="headerlink" title="5.3 特殊变量"></a>5.3 特殊变量</h3><blockquote><p>环境变量</p></blockquote><p>make运行时的系统环境变量可以在make开始运行时被载入到Makefile文件中，但是如果Makefile中已定义了这个变量，或是这个变量由make命令行带入，那么系统的环境变量的值将被覆盖。（如果make指定了“-e”参数，那么，系统环境变量将覆盖Makefile中定义的变量）</p><p>因此，如果我们在环境变量中设置了 <code>CFLAGS</code> 环境变量，那么我们就可以在所有的Makefile中使用这个变量了。这对于我们使用统一的编译参数有比较大的好处。如果Makefile中定义了CFLAGS，那么则会使用Makefile中的这个变量，如果没有定义则使用系统环境变量的值，一个共性和个性的统一，很像“全局变量”和“局部变量”的特性。</p><p>当make嵌套调用时（参见前面的“嵌套调用”章节），上层Makefile中定义的变量会以系统环境变量的方式传递到下层的Makefile 中。当然，默认情况下，只有通过命令行设置的变量会被传递。而定义在文件中的变量，如果要向下层Makefile传递，则需要使用exprot关键字来声明。（参见前面章节）</p><blockquote><p>目标变量</p></blockquote><p>为某个目标设置局部变量，其作用范围只在这条规则及其连带的规则中。</p><p>语法：</p><pre class=" language-makefile"><code class="language-makefile"><span class="token symbol">&lt;target ...> </span><span class="token punctuation">:</span> &lt;variable-assignment><span class="token comment" spellcheck="true"># 主要用于处理环境变量</span><span class="token symbol">&lt;target ...> </span><span class="token punctuation">:</span> <span class="token keyword">override</span> &lt;variable-assignment> </code></pre><pre class=" language-makefile"><code class="language-makefile"><span class="token symbol">prog </span><span class="token punctuation">:</span> CFLAGS <span class="token operator">=</span> -g<span class="token symbol">prog </span><span class="token punctuation">:</span> prog.o foo.o bar.o    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> prog.o foo.o bar.o<span class="token symbol">prog.o </span><span class="token punctuation">:</span> prog.c    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> prog.c<span class="token symbol">foo.o </span><span class="token punctuation">:</span> foo.c    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> foo.c<span class="token symbol">bar.o </span><span class="token punctuation">:</span> bar.c    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> bar.c</code></pre><blockquote><p>模式变量</p></blockquote><p>将变量定义在所有符合模式的目标上</p><pre class=" language-makefile"><code class="language-makefile"><span class="token symbol">%.o </span><span class="token punctuation">:</span> CFLAGS <span class="token operator">=</span> -o</code></pre><p>语法同目标变量</p><h2 id="6-条件判断"><a href="#6-条件判断" class="headerlink" title="6. 条件判断"></a>6. 条件判断</h2><blockquote><p>语法</p></blockquote><pre><code>&lt;conditional-directive&gt;&lt;text-if-true&gt;endif&lt;conditional-directive&gt;&lt;text-if-true&gt;else&lt;text-if-false&gt;endif</code></pre><blockquote><p>ifeq &#x2F; ifneq</p></blockquote><p>比较两个参数的值是否相等&#x2F;不相等</p><pre class=" language-makefile"><code class="language-makefile">libs_for_gcc <span class="token operator">=</span> -lgnunormal_libs <span class="token operator">=</span><span class="token symbol">foo</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span><span class="token keyword">ifeq</span> <span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span>, gcc<span class="token punctuation">)</span>    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -o foo <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>libs_for_gcc<span class="token punctuation">)</span><span class="token keyword">else</span>    <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -o foo <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>normal_libs<span class="token punctuation">)</span><span class="token keyword">endif</span></code></pre><blockquote><p>ifdef &#x2F; ifndef</p></blockquote><pre class=" language-makefile"><code class="language-makefile"><span class="token keyword">ifdef</span> &lt;variable-name></code></pre><p>判断变量的值是否为空，非空为真，空为假</p><p>仅判断一个变量是否有值，而不会将其展开</p><pre class=" language-makefile"><code class="language-makefile">bar <span class="token operator">=</span>foo <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 此处判断为真 </span><span class="token keyword">ifdef</span> foo    frobozz <span class="token operator">=</span> yes<span class="token keyword">else</span>    frobozz <span class="token operator">=</span> no<span class="token keyword">endif</span></code></pre><p><strong>make在读取Makefile时就会计算条件表达式的值，因此不要在此处使用自动化变量</strong></p><h2 id="7-函数"><a href="#7-函数" class="headerlink" title="7. 函数"></a>7. 函数</h2><blockquote><p>调用语法</p></blockquote><pre class=" language-makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span>&lt;function-name> &lt;arguments><span class="token punctuation">)</span></code></pre><p>函数名与参数之间用空格分隔，参数之间用<code>,</code>分隔</p><h3 id="7-1-字符串处理函数"><a href="#7-1-字符串处理函数" class="headerlink" title="7.1 字符串处理函数"></a>7.1 字符串处理函数</h3><blockquote><p>subst</p></blockquote><pre class=" language-makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">subst</span> &lt;from>, &lt;to>, &lt;text><span class="token punctuation">)</span></code></pre><p>功能：将字串<code>&lt;text&gt;</code>中的<code>&lt;from&gt;</code>转换为<code>&lt;to&gt;</code></p><p>返回：替换后的字符串</p><blockquote><p>patsubst</p></blockquote><pre class=" language-makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">patsubst</span> &lt;pattern>,&lt;replacement><span class="token punctuation">)</span></code></pre><p>功能：查找 <code>&lt;text&gt;</code> 中的单词<strong>（单词以“空格”、“Tab”或“回车”“换行”分隔）</strong>是否符合模式 <code>&lt;pattern&gt;</code> ，如果匹配的话，则以 <code>&lt;replacement&gt;</code> 替换。这里， <code>&lt;pattern&gt;</code> 可以包括通配符 <code>%</code> ，表示任意长度的字串。如果 <code>&lt;replacement&gt;</code> 中也包含 <code>%</code> ，那么， <code>&lt;replacement&gt;</code> 中的这个 <code>%</code> 将是 <code>&lt;pattern&gt;</code> 中的那个 <code>%</code> 所代表的字串。（可以用 <code>\</code> 来转义，以 <code>\%</code> 来表示真实含义的 <code>%</code> 字符）</p><p>返回：替换后的字符串</p><blockquote><p>strip</p></blockquote><pre class=" language-makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">strip</span> &lt;string><span class="token punctuation">)</span></code></pre><p>功能：去掉<string>字串开头和结尾的空格</p><p>返回：被去掉空格的字符串</p><blockquote><p>findstring</p></blockquote><pre class=" language-makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">findstring</span> &lt;find>,&lt;in><span class="token punctuation">)</span></code></pre><p>功能：在字串<in>中查找<find>字串</p><p>返回：如果找到，返回<find>字串</p><blockquote><p>filter &#x2F; filterout</p></blockquote><pre class=" language-makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">filter</span> &lt;pattern...>, &lt;text><span class="token punctuation">)</span></code></pre><p>功能：以 <code>&lt;pattern&gt;</code> 模式过滤&#x2F;去除 <code>&lt;text&gt;</code> 字符串中的单词，保留符合模式 <code>&lt;pattern&gt;</code> 的单词。可以有多个模式。</p><p>返回：符合模式的字串</p><blockquote><p>sort</p></blockquote><pre class=" language-makefile"><code class="language-makefile"><span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">sort</span> &lt;list><span class="token punctuation">)</span></code></pre><p>功能：给字符串 <code>&lt;list&gt;</code> 中的单词排序（升序）。</p><p>返回：返回排序后的字符串。</p><p>示例： <code>$(sort foo bar lose)</code> 返回 <code>bar foo lose</code> 。</p><p>备注： <code>sort</code> 函数会去掉 <code>&lt;list&gt;</code> 中相同的单词。</p><blockquote><p>word</p></blockquote><pre><code>$(word &lt;n&gt;,&lt;text&gt;)</code></pre><p>名称：取单词函数</p><p>功能：取字符串 <code>&lt;text&gt;</code> 中第 <code>&lt;n&gt;</code> 个单词。（从一开始）</p><p>返回：返回字符串 <code>&lt;text&gt;</code> 中第 <code>&lt;n&gt;</code> 个单词。如果 <code>&lt;n&gt;</code> 比 <code>&lt;text&gt;</code> 中的单词数要大，那么返回空字符串。</p><p>示例： <code>$(word 2, foo bar baz)</code> 返回值是 <code>bar</code> 。</p><blockquote><p>wordlist</p></blockquote><pre><code>$(wordlist &lt;ss&gt;,&lt;e&gt;,&lt;text&gt;)</code></pre><p>名称：取单词串函数</p><p>功能：从字符串 <code>&lt;text&gt;</code> 中取从 <code>&lt;ss&gt;</code> 开始到 <code>&lt;e&gt;</code> 的单词串。 <code>&lt;ss&gt;</code> 和 <code>&lt;e&gt;</code> 是一个数字。</p><p>返回：返回字符串 <code>&lt;text&gt;</code> 中从 <code>&lt;ss&gt;</code> 到 <code>&lt;e&gt;</code> 的单词字串。如果 <code>&lt;ss&gt;</code> 比 <code>&lt;text&gt;</code> 中的单词数要大，那么返回空字符串。如果 <code>&lt;e&gt;</code> 大于 <code>&lt;text&gt;</code> 的单词数，那么返回从 <code>&lt;ss&gt;</code> 开始，到 <code>&lt;text&gt;</code> 结束的单词串。</p><p>示例： <code>$(wordlist 2, 3, foo bar baz)</code> 返回值是 <code>bar baz</code> 。</p><blockquote><p>firstword</p></blockquote><pre><code>$(firstword &lt;text&gt;)</code></pre><p>名称：首单词函数——firstword。</p><p>功能：取字符串 <code>&lt;text&gt;</code> 中的第一个单词。</p><p>返回：返回字符串 <code>&lt;text&gt;</code> 的第一个单词。</p><p>示例： <code>$(firstword foo bar)</code> 返回值是 <code>foo</code>。</p><p>备注：这个函数可以用 <code>word</code> 函数来实现： <code>$(word 1,&lt;text&gt;)</code> 。</p><h3 id="7-2-文件名处理函数"><a href="#7-2-文件名处理函数" class="headerlink" title="7.2 文件名处理函数"></a>7.2 文件名处理函数</h3><blockquote><p>dir</p></blockquote><pre><code>$(dir &lt;names...&gt;)</code></pre><p>名称：取目录函数——dir。</p><p>功能：从文件名序列 <code>&lt;names&gt;</code> 中取出目录部分。目录部分是指最后一个反斜杠（ <code>/</code> ）之前的部分。如果没有反斜杠，那么返回 <code>./</code> 。</p><p>返回：返回文件名序列 <code>&lt;names&gt;</code> 的目录部分。</p><p>示例： <code>$(dir src/foo.c hacks)</code> 返回值是 <code>src/ ./</code> 。</p><blockquote><p>notdir</p></blockquote><pre><code>$(notdir &lt;names...&gt;)</code></pre><p>名称：取文件函数——notdir。</p><p>功能：从文件名序列 <code>&lt;names&gt;</code> 中取出非目录部分。非目录部分是指最後一个反斜杠（ <code>/</code> ）之后的部分。</p><p>返回：返回文件名序列 <code>&lt;names&gt;</code> 的非目录部分。</p><p>示例: <code>$(notdir src/foo.c hacks)</code> 返回值是 <code>foo.c hacks</code> 。</p><blockquote><p>suffix</p></blockquote><pre><code>$(suffix &lt;names...&gt;)</code></pre><p>名称：取後缀函数——suffix。</p><p>功能：从文件名序列 <code>&lt;names&gt;</code> 中取出各个文件名的后缀。</p><p>返回：返回文件名序列 <code>&lt;names&gt;</code> 的后缀序列，如果文件没有后缀，则返回空字串。</p><p>示例： <code>$(suffix src/foo.c src-1.0/bar.c hacks)</code> 返回值是 <code>.c .c</code>。</p><blockquote><p>basename</p></blockquote><pre><code>$(basename &lt;names...&gt;)</code></pre><p>名称：取前缀函数——basename。</p><p>功能：从文件名序列 <code>&lt;names&gt;</code> 中取出各个文件名的前缀部分。</p><p>返回：返回文件名序列 <code>&lt;names&gt;</code> 的前缀序列，如果文件没有前缀，则返回空字串。</p><p>示例： <code>$(basename src/foo.c src-1.0/bar.c hacks)</code> 返回值是 <code>src/foo src-1.0/bar hacks</code> 。</p><blockquote><p>addsuffix</p></blockquote><pre><code>$(addsuffix &lt;suffix&gt;,&lt;names...&gt;)</code></pre><p>名称：加后缀函数——addsuffix。</p><p>功能：把后缀 <code>&lt;suffix&gt;</code> 加到 <code>&lt;names&gt;</code> 中的每个单词后面。</p><p>返回：返回加过后缀的文件名序列。</p><p>示例： <code>$(addsuffix .c,foo bar)</code> 返回值是 <code>foo.c bar.c</code> 。</p><blockquote><p> addprefix</p></blockquote><pre><code>$(addprefix &lt;prefix&gt;,&lt;names...&gt;)</code></pre><p>名称：加前缀函数——addprefix。</p><p>功能：把前缀 <code>&lt;prefix&gt;</code> 加到 <code>&lt;names&gt;</code> 中的每个单词后面。</p><p>返回：返回加过前缀的文件名序列。</p><p>示例： <code>$(addprefix src/,foo bar)</code> 返回值是 <code>src/foo src/bar</code> 。</p><blockquote><p>join</p></blockquote><pre><code>$(join &lt;list1&gt;,&lt;list2&gt;)</code></pre><p>名称：连接函数——join。</p><p>功能：把 <code>&lt;list2&gt;</code> 中的单词对应地加到 <code>&lt;list1&gt;</code> 的单词后面。如果 <code>&lt;list1&gt;</code> 的单词个数要比 <code>&lt;list2&gt;</code> 的多，那么， <code>&lt;list1&gt;</code> 中的多出来的单词将保持原样。如果 <code>&lt;list2&gt;</code> 的单词个数要比 <code>&lt;list1&gt;</code> 多，那么， <code>&lt;list2&gt;</code> 多出来的单词将被复制到 <code>&lt;list1&gt;</code> 中。</p><p>返回：返回连接过后的字符串。</p><p>示例： <code>$(join aaa bbb , 111 222 333)</code> 返回值是 <code>aaa111 bbb222 333</code> 。</p><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><pre><code>$(foreach &lt;var&gt;,&lt;list&gt;,&lt;text&gt;)</code></pre><p>这个函数的意思是，把参数 <code>&lt;list&gt;</code> 中的单词逐一取出放到参数 <code>&lt;var&gt;</code> 所指定的变量中，然后再执行 <code>&lt;text&gt;</code> 所包含的表达式。每一次 <code>&lt;text&gt;</code> 会返回一个字符串，循环过程中， <code>&lt;text&gt;</code> 的所返回的每个字符串会以空格分隔，最后当整个循环结束时， <code>&lt;text&gt;</code> 所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。</p><p>所以， <code>&lt;var&gt;</code> 最好是一个变量名， <code>&lt;list&gt;</code> 可以是一个表达式，而 <code>&lt;text&gt;</code> 中一般会使用 <code>&lt;var&gt;</code> 这个参数来依次枚举 <code>&lt;list&gt;</code> 中的单词。举个例子：</p><pre><code>names := a b c dfiles := $(foreach n,$(names),$(n).o)</code></pre><p>上面的例子中， <code>$(name)</code> 中的单词会被挨个取出，并存到变量 <code>n</code> 中， <code>$(n).o</code> 每次根据 <code>$(n)</code> 计算出一个值，这些值以空格分隔，最后作为foreach函数的返回，所以， <code>$(files)</code> 的值是 <code>a.o b.o c.o d.o</code> 。</p><p>注意，foreach中的 <code>&lt;var&gt;</code> 参数是一个临时的局部变量，foreach函数执行完后，参数 <code>&lt;var&gt;</code> 的变量将不在作用，其作用域只在foreach函数当中。</p><h3 id="call函数"><a href="#call函数" class="headerlink" title="call函数"></a>call函数</h3><p>call函数是唯一一个可以用来创建新的参数化的函数。你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，然后你可以call函数来向这个表达式传递参数。其语法是：</p><pre><code>$(call &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,...,&lt;parmn&gt;)</code></pre><p>当make执行这个函数时， <code>&lt;expression&gt;</code> 参数中的变量，如 <code>$(1)</code> 、 <code>$(2)</code> 等，会被参数 <code>&lt;parm1&gt;</code> 、 <code>&lt;parm2&gt;</code> 、 <code>&lt;parm3&gt;</code> 依次取代。而 <code>&lt;expression&gt;</code> 的返回值就是 call 函数的返回值。例如：</p><pre><code>reverse =  $(1) $(2)foo = $(call reverse,a,b)</code></pre><p>那么， <code>foo</code> 的值就是 <code>a b</code> 。当然，参数的次序是可以自定义的，不一定是顺序的，如：</p><pre><code>reverse =  $(2) $(1)foo = $(call reverse,a,b)</code></pre><p>此时的 <code>foo</code> 的值就是 <code>b a</code> 。</p><p>需要注意：在向 call 函数传递参数时要尤其注意空格的使用。call 函数在处理参数时，第2个及其之后的参数中的空格会被保留，因而可能造成一些奇怪的效果。因而在向call函数提供参数时，最安全的做法是去除所有多余的空格。</p><h3 id="origin函数"><a href="#origin函数" class="headerlink" title="origin函数"></a>origin函数</h3><p>origin函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是哪里来的？其语法是：</p><pre><code>$(origin &lt;variable&gt;)</code></pre><ul><li><p>注意， <code>&lt;variable&gt;</code> 是变量的名字，不应该是引用。所以你最好不要在 <code>&lt;variable&gt;</code> 中使用</p><p><code>$</code> 字符。Origin函数会以其返回值来告诉你这个变量的“出生情况”，下面，是origin函数的返回值:</p></li><li><p><code>undefined</code></p><p>如果 <code>&lt;variable&gt;</code> 从来没有定义过，origin函数返回这个值 <code>undefined</code></p></li><li><p><code>default</code></p><p>如果 <code>&lt;variable&gt;</code> 是一个默认的定义，比如“CC”这个变量，这种变量我们将在后面讲述。</p></li><li><p><code>environment</code></p><p>如果 <code>&lt;variable&gt;</code> 是一个环境变量，并且当Makefile被执行时， <code>-e</code> 参数没有被打开。</p></li><li><p><code>file</code></p><p>如果 <code>&lt;variable&gt;</code> 这个变量被定义在Makefile中。</p></li><li><p><code>command line</code></p><p>如果 <code>&lt;variable&gt;</code> 这个变量是被命令行定义的。</p></li><li><p><code>override</code></p><p>如果 <code>&lt;variable&gt;</code> 是被override指示符重新定义的。</p></li><li><p><code>automatic</code></p><p>如果 <code>&lt;variable&gt;</code> 是一个命令运行中的自动化变量。关于自动化变量将在后面讲述。</p></li></ul><p>这些信息对于我们编写Makefile是非常有用的，例如，假设我们有一个Makefile其包了一个定义文件 Make.def，在 Make.def中定义了一个变量“bletch”，而我们的环境中也有一个环境变量“bletch”，此时，我们想判断一下，如果变量来源于环境，那么我们就把之重定义了，如果来源于Make.def或是命令行等非环境的，那么我们就不重新定义它。于是，在我们的Makefile中，我们可以这样写：</p><pre><code>ifdef bletch    ifeq &quot;$(origin bletch)&quot; &quot;environment&quot;        bletch = barf, gag, etc.    endifendif</code></pre><p>当然，你也许会说，使用 <code>override</code> 关键字不就可以重新定义环境中的变量了吗？为什么需要使用这样的步骤？是的，我们用 <code>override</code> 是可以达到这样的效果，可是 <code>override</code> 过于粗暴，它同时会把从命令行定义的变量也覆盖了，而我们只想重新定义环境传来的，而不想重新定义命令行传来的。</p><h3 id="shell函数"><a href="#shell函数" class="headerlink" title="shell函数"></a>shell函数</h3><p>shell函数也不像其它的函数。顾名思义，它的参数应该就是操作系统Shell的命令。它和反引号“&#96;”是相同的功能。这就是说，shell函数把执行操作系统命令后的输出作为函数返回。于是，我们可以用操作系统命令以及字符串处理命令awk，sed等等命令来生成一个变量，如：</p><pre><code>contents := $(shell cat foo)files := $(shell echo *.c)</code></pre><p>注意，这个函数会新生成一个Shell程序来执行命令，所以你要注意其运行性能，如果你的Makefile中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是Makefile的隐晦的规则可能会让你的shell函数执行的次数比你想像的多得多。</p>]]></content>
      
      
      <categories>
          
          <category> Remake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Remake | 数据结构</title>
      <link href="/2022/06/29/DataStructure/"/>
      <url>/2022/06/29/DataStructure/</url>
      
        <content type="html"><![CDATA[<p>菜狗的Remake之路 – 数据结构篇</p><span id="more"></span><p>使用语言：Java</p><blockquote><p>实例化对象的过程</p></blockquote><p>首先根据构造函数传入的参数初始化对象中的属性，然后该对象的属性的首个bit所在的位置返回，作为该对象的地址被存入到对应的变量中。</p><p>所有地址长度位64位，null的地址为全0。</p><p>tips：所有的赋值操作都是将该变量存储的字节全部拷贝到另一个变量中。</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>尽量避免特判可有效提高代码健壮性。</p><p>表头添加哨兵结点的思想：让链表在任何情况下的状态都遵循同一套操作逻辑。</p><p>在单链表中添加头部哑节点的原因是，在某些情况下无法访问链表中结点的next属性，因此我们通过添加哑节点来使next属性在任何时刻都可以被访问。</p><p>而对于双向链表，又出现了某些结点的prev属性不能被访问或是说不应该被访问。例如，按照原先单链表的设计，我们将需要在前插时对是否是头部哑节点进行特判。</p><p>此时有两种解决方法：</p><ol><li>在尾部也添加一个哑节点。</li><li>将链表设计成循环链表。</li></ol><h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><blockquote><p>resize</p></blockquote><p>当顺序表需要进行resize操作时，将数组大小进行指数级更改，而非简单的加减。因为加减无法根据当前数据量的大小动态进行调整，导致在数据量过大时频繁地调用resize操作拖慢速度且占用大量空间。</p><p>若顺序表中数组存储的不是基本数据类型，则不推荐懒惰删除，因为被删除对象的引用仍然保存着，不会被gc回收，占用内存。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承会从父类继承所有的成员变量，静态变量，所有的方法和内部类。</p><p>但被private修饰的不可直接访问。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 调用父类方法</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">xxx</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>tips:构造器都不会被继承，但Java会默认在子类构造器中首先调用基类默认<em>无参</em>构造器。</p><blockquote><p>继承会破坏封装</p></blockquote><p>Java根据动态数据类型调用方法，若子类中覆写了一个方法，其中调用了从基类继承来的方法，但此方法调用了基类中被覆写的方法，则此时不会调用父类中被覆写的方法，而是子类的方法，最终陷入无限循环。</p><p>封装被破坏的直接体现：模组中的方法不再以整体的形式被调用</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="合并排序-选择排序"><a href="#合并排序-选择排序" class="headerlink" title="合并排序 (+ 选择排序)"></a>合并排序 (+ 选择排序)</h3><p>合并排序在处理有序数组时仅有O(N)的复杂度，因此可以选择将无序数组切分成若干部分，对其分别调用选择排序，再进行合并，实现排序加速。</p><p>但若将数组切分到只剩单个元素的小块，则可直接用合并排序实现一切，复杂度为O(NlogN)，代价是内存占用较大。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Sort</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * merge two sorted array to a sorted array     * @param &lt;T> type of data     * @param datas1 a sorted array and all of its elements are not null     * @param datas2 a sorted array and all of its elements are not null     * @param c The comparator of type T     * @return a sorted array containing all elements in datas1 and datas2     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> List<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">merge</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>T<span class="token operator">></span> datas1<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>T<span class="token operator">></span> datas2<span class="token punctuation">,</span> Comparator<span class="token operator">&lt;</span>T<span class="token operator">></span> cc<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>        i <span class="token operator">=</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// ret = (T[])(new Object[datas1.length + datas2.length]);</span>        List<span class="token operator">&lt;</span>T<span class="token operator">></span> ret <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> datas1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> datas2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> cmp <span class="token operator">=</span> cc<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>datas1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> datas2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                ret<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>datas1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">++</span>i<span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                ret<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>datas2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">++</span>j<span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            idx<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> datas1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            ret<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>datas1<span class="token punctuation">.</span><span class="token function">subList</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> datas1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">!=</span> datas2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            ret<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>datas2<span class="token punctuation">.</span><span class="token function">subList</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> datas2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">insertSort</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>T<span class="token operator">></span> datas<span class="token punctuation">,</span> Comparator<span class="token operator">&lt;</span>T<span class="token operator">></span> cc<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> datas<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            T elem <span class="token operator">=</span> datas<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> j<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> cc<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>datas<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> elem<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                datas<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> datas<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            datas<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> elem<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> List<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>T<span class="token operator">></span> datas<span class="token punctuation">,</span> Comparator<span class="token operator">&lt;</span>T<span class="token operator">></span> cc<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>datas<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token function">insertSort</span><span class="token punctuation">(</span>datas<span class="token punctuation">,</span> cc<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> datas<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> datas<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            List<span class="token operator">&lt;</span>T<span class="token operator">></span> sort1 <span class="token operator">=</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>datas<span class="token punctuation">.</span><span class="token function">subList</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">,</span> cc<span class="token punctuation">)</span><span class="token punctuation">;</span>            List<span class="token operator">&lt;</span>T<span class="token operator">></span> sort2 <span class="token operator">=</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>datas<span class="token punctuation">.</span><span class="token function">subList</span><span class="token punctuation">(</span>mid<span class="token punctuation">,</span> datas<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cc<span class="token punctuation">)</span><span class="token punctuation">;</span>            List<span class="token operator">&lt;</span>T<span class="token operator">></span> ret <span class="token operator">=</span> <span class="token function">merge</span><span class="token punctuation">(</span>sort1<span class="token punctuation">,</span> sort2<span class="token punctuation">,</span> cc<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> ret<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>划分域：在数组中选取一个元素，在对元素重新组织后，使得在该元素的左边均为</p><p>小于他的元素，右边均为大于他的元素。</p><p>划分域 -&gt; 被选取的元素已经就位</p><p>因此快排的思路就是，在数组中选取一个枢纽点，以他为中心重新组织数组，使其满足划分域的要求。然后对划分的左右两边继续调用快排直至数组中没有元素或只剩1个元素。</p><p>快排的本质仍旧是一棵以枢纽点为节点的二叉树，树的平均高度为logN，而在树的每一层中进行的重组织的时间复杂度为O(N)，因此快排的时间复杂度为O(NlogN)</p><p>但要注意的是，若枢纽点选取不当，会导致树退化成单链表，例如当数组基本有序或有大量重复元时，每次划分都只会划分出1个元素。</p><blockquote><p>优化方法</p></blockquote><ol><li>使用随机算法进行枢纽元选取，有大概率会选到在中间大小的元素</li><li>当数组元素数量不大时，切换为稳定的排序算法（插排&#x2F;归并），避免树的深度在最后大幅增加</li></ol><blockquote><p>Hora partition</p></blockquote><p>使一个指针i指向数组起点，一个指针j指向数组终点，当i所指的元素小于pivot时，右移i，当j所指元素大于pivot时，左移j。i和j都停下时，交换所指元素。重复上述步骤，直至i与j交叉，然后将pivot与j交换。（此时j必定处于最后一个小于pivot的位置，因此需要如此交换）</p><h3 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h3><p>若要选取数组中第k小的元素，则将数组中的最后一个元素作为pivot，初始化pivotloc于数组起点，然后遍历数组，若当前元素小于pivot，则将其与pivotloc交换，并移动pivotloc，最后交换pivotloc所指元素与pivot。这样就将数组切分成两块，然后检查获得的pivotloc是否与k相等，若大于，则对左半部分继续切分，若小于，则对右半部分继续切分。（此时，左半部分均小于pivotloc的元素，右半部分反之）</p><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>不实质性将两个结点连接，而是将其存储在同一个集合中，表明他们之间有链接。</p><p>这样在查询两个结点之间是否连接时只需要看他们是否在同一集合中。</p><p>re:我们不需要像图那样直到具体的连接情况，因此可以用逻辑上的连接代替。</p><blockquote><p>implement</p></blockquote><p>实现方式1：哈希表（通用）</p><p>对于整形</p><p>实现方式2：创建一个大小为N的数组，数组中存储的是其对应下标数组所属的集合的代表数字。</p><p>快速连接的方法：直接修改集合的代表元素指向的父级结点的值。但此时父级结点的计算仍可能是一个昂贵的操作。最坏情况会退化到O(N)。</p><p>因此我们选择将一个结合中所有的元素都指向结合代表元素，这样查询当前集合的父节点的时间就被大大压缩。</p><p>此时需要考虑在合并时应将小的集合并到大的集合来减少树的深度。</p><p>-&gt; 使用一个数组来追踪集合大小，确保每一次都是小的往大的合，这样树的深度永远被控制在logN。</p><p>路径压缩：在执行isConnect时，将单个集合中的所有结点指向其最高父结点。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Union</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> parent<span class="token punctuation">;</span>    Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> size<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*        AF(n) : a union containing n elements,         their parent nodes are stored in &amp;#123;parent&amp;#125;        every set's size is stored in size        Rep invarient:        parent != null, elements in parent are greater than or equal to 0, less than n        size != null, elements in size are not less than 1    */</span>    <span class="token keyword">public</span> <span class="token function">Union</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        parent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        size <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            parent<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            size<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * check if p and q are belong to the same set     * compress the path at the same time     * @param p node p     * @param q node q     * @return if they are belong to the same set     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isConnect</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> q<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> i <span class="token operator">==</span> j<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * find parent of p     * @param p node p     * @return its parent     */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> p<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * connect set containing p and set containing q together     * @param p node p     * @param q node q     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> q<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> parent<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> j<span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>size<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> size<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            parent<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            size<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> size<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            parent<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>            size<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> size<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><blockquote><p>前&#x2F;中&#x2F;后序遍历时间复杂度</p></blockquote><p>因为该遍历算法针对每一个结点作处理，其时间复杂度增长与结点个数有关。一次遍历要考虑N个节点，因此时间复杂度为O(N)</p><blockquote><p>层序遍历</p></blockquote><p>层序遍历的区别在于，该算法时间复杂度的增长与层数有关，假设层数为H，操作次数为1 + 2^1 + 2^2 + …</p><p>因此其时间复杂度为O(2^H)，而H&#x3D;logN，所以时间复杂度为O(N)</p><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>对于一张有序的顺序表，可以通过不断的将其二分来进行压缩，BST就是二分查找的显式表现。</p><p>根节点的左子树这种的元素均小于根节点的元素，右子树的均大于根节点元素。</p><blockquote><p>删除操作</p></blockquote><p>对于叶子节点，直接将其删除即可。</p><p>对于有单个孩子的结点，用其孩子结点顶替当前结点。</p><p>对于有两个孩子的结点，找到其左子树中最大的结点或右子树中最小的结点(必然是叶子结点或只有一个孩子的结点)来顶替它，然后删除用于顶替的结点。</p><p>tip：但是删除操作做的越多，树的高度就会不断增高，因为每次删除都相当于让树的某一端的结点数量减少，最后失去平衡。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BinSearchTree</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Node root<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>        <span class="token keyword">public</span> Integer <span class="token function">get</span><span class="token punctuation">(</span>Integer key<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">getHelper</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Integer <span class="token function">getHelper</span><span class="token punctuation">(</span>Integer key<span class="token punctuation">,</span> Node troot<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>troot <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>troot<span class="token punctuation">.</span>elem<span class="token punctuation">.</span>key <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> troot<span class="token punctuation">.</span>elem<span class="token punctuation">.</span>value<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>troot<span class="token punctuation">.</span>elem<span class="token punctuation">.</span>key <span class="token operator">&lt;</span> key<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token function">getHelper</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> troot<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">getHelper</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> troot<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> Node <span class="token function">insert</span><span class="token punctuation">(</span>Integer key<span class="token punctuation">,</span> Integer value<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        root <span class="token operator">=</span> <span class="token function">insertHelper</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Node <span class="token function">insertHelper</span><span class="token punctuation">(</span>Integer key<span class="token punctuation">,</span> Integer value<span class="token punctuation">,</span> Node troot<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>troot <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            size<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">,</span> null<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>troot<span class="token punctuation">.</span>elem<span class="token punctuation">.</span>key <span class="token operator">></span> key<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                troot<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">insertHelper</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> troot<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>troot<span class="token punctuation">.</span>elem<span class="token punctuation">.</span>key <span class="token operator">&lt;</span> key<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                troot<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">insertHelper</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> troot<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> troot<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">containsKey</span><span class="token punctuation">(</span>Integer key<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">getHelper</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> root<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span>Integer key<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token function">deleteHelper</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Node <span class="token function">deleteHelper</span><span class="token punctuation">(</span>Integer key<span class="token punctuation">,</span> Node troot<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>troot <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>troot<span class="token punctuation">.</span>elem<span class="token punctuation">.</span>key <span class="token operator">&lt;</span> key<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            troot<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">deleteHelper</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> troot<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>troot<span class="token punctuation">.</span>elem<span class="token punctuation">.</span>key <span class="token operator">></span> key<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            troot<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">deleteHelper</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> troot<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>troot<span class="token punctuation">.</span>left <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> troot<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                Node tmp <span class="token operator">=</span> <span class="token function">findMax</span><span class="token punctuation">(</span>troot<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                troot<span class="token punctuation">.</span>elem <span class="token operator">=</span> tmp<span class="token punctuation">.</span>elem<span class="token punctuation">;</span>                troot<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">deleteHelper</span><span class="token punctuation">(</span>troot<span class="token punctuation">.</span>elem<span class="token punctuation">.</span>key<span class="token punctuation">,</span> troot<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>troot<span class="token punctuation">.</span>left <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    troot <span class="token operator">=</span> troot<span class="token punctuation">.</span>right<span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>troot<span class="token punctuation">.</span>right <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    troot <span class="token operator">=</span> troot<span class="token punctuation">.</span>left<span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            size<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> troot<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Node <span class="token function">findMax</span><span class="token punctuation">(</span>Node troot<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>troot <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>troot<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            troot <span class="token operator">=</span> troot<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> troot<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">private</span> Pair elem<span class="token punctuation">;</span>        <span class="token keyword">private</span> Node left<span class="token punctuation">;</span>        <span class="token keyword">private</span> Node right<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">Node</span><span class="token punctuation">(</span>Pair elem<span class="token punctuation">,</span> BinSearchTree<span class="token punctuation">.</span>Node left<span class="token punctuation">,</span> BinSearchTree<span class="token punctuation">.</span>Node right<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>elem <span class="token operator">=</span> elem<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> left<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> right<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>           <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Pair</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">private</span> Integer key<span class="token punctuation">;</span>        <span class="token keyword">private</span> Integer value<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">Pair</span><span class="token punctuation">(</span>Integer key<span class="token punctuation">,</span> Integer value<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h3><p>在已知一组数据的情况下，若将其按随机顺序插入，则复杂度大概率是O(logN)，但若不提前知道数据，那么有可能会让树退化成单链表，因为先前并没有考虑该往哪里插入数据，基本都是插在底部，因此很有可能只往一端插入数据，让树的高度大幅增加。</p><p>因此我们需要在每一次插入与删除之后检查树的平衡，若失衡则进行调整。</p><blockquote><p>左旋</p></blockquote><p>右端大量的数据破坏了树的平衡，则将原来的根节点作为新根节点的左子树，新根节点原来的左子树接到原根结点的右端。右旋同理。</p><blockquote><p>B tree</p></blockquote><p>使一个结点能够存储多个数据，例如每个结点允许存储3个数据，当数据量大于3时，将当前结点拆分，将第2大的数据放到父节点中存储。这样之后每个结点都有4棵子树，分别存储 &lt; val1, &gt;val1 &amp;&amp; &lt; val2，…的数据。只有当根节点中的数据也超过上限时，树的高度才会增加，将第2大的数据作为新的根节点，然后重新分配子树。</p><blockquote><p>红黑树</p></blockquote><p>红黑树即是B树(2-3树)和二叉树的结合，对于含有两个数据的结点，<strong>逻辑上</strong>添加一个哑结点作为这两个数据的父节点，这样就将他们拆分成二叉树，这个哑结点即为红黑树中的红。</p><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>将数据本身当作索引，仅仅把数据看作是位，而在数组对应的位置存储布尔值。</p><p>但该方法会占用大量空间，且对于非数字类型不友好（但可以进行映射，确保任何值都会被分配到唯一的一个空间）。</p><p>将元素转换为下标的过程即为hash，注意不要让hash生成负数，或对其进行特殊处理。</p><p>对于超过2亿的数据量，必然会有多个元素共享空间的情况，因此我们不在数组中存储true&#x2F;false,而是对应的元素</p><p>哈希的速度取决于它存储的数据量（越多的数据量代表越多的冲突），N个数据分布在M个桶里时，其平均访问速度为O(N&#x2F;M), L&#x3D;N&#x2F;M即为装在因子。当装载因子超过阈值时，就要进行rehash操作，通过使用更多的桶来减少冲突。</p><p>但装载因子不是唯一需要考虑的东西，当一系列数据共享同一个空间时，其装载因子也可能非常小，因此哈希函数的涉及应确保哈希表中的数据分散存放。</p><h2 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h2><p>可以追踪或移除最大&#x2F;最小元素</p><p>堆用树的形式体现具有如下特质：</p><ol><li>所有的结点都要小于等于它的子节点</li><li>完全</li></ol><blockquote><p>add</p></blockquote><p>先将要插入的结点放在最后一个位置，若其父节点的值大于其值，则将父节点沉降，直到父节点的值小于该节点的值，此时空槽到达满足要求的位置。</p><blockquote><p>remove</p></blockquote><p>先将最后一个结点提升为root结点，然后沉降直到它的值小于它的孩子节点。</p><blockquote><p>用数组表示树</p></blockquote><ol><li><p>将键存储在一个数组中，将对应的父节点id存在另一个数组中</p></li><li><p>只存储数据，不存储结构，假设是一个完整二叉树。</p><p>父节点与子节点的下标关系：</p><p>从1开始存储</p><ul><li>parent &#x3D; k&#x2F;2</li><li>left child &#x3D; 2 * k</li><li>right child &#x3D; 2 *</li></ul></li></ol><h2 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h2><h3 id="图的实现方式"><a href="#图的实现方式" class="headerlink" title="图的实现方式"></a>图的实现方式</h3><blockquote><p>临接矩阵</p></blockquote><p>用二维数组存储图，其矩阵的行列分别表示起点与终点，矩阵中存储的内容表示两点是否连接，或者是两点间边的权重。</p><p>遍历的时间复杂度为O(V^2)</p><p>首先要将所有点当作起点展开一层循环，该层循环会持续执行V次，接着要检查当前起点所连接到的点，要遍历数组matrix[v][]，该层循环每轮要执行V次，由此可得时间复杂度为V^2次</p><blockquote><p>临接表</p></blockquote><p>维护一组链表，用数组下标表示起点，链表内容表示它连通的结点</p><p>遍历的时间复杂度为O(V + E)</p><p>首先仍要将所有结点都搜索一遍，但针对相邻点的处理有所不同，临接矩阵需要访问所有的点来确定是否连接，而临接矩阵只要访问对应下标上的链表长度的数据。对于没有相邻点的结点，其访问连接点只需要进行1次操作，即在图中没有边时，临接表只需进行V次操作，而当临接矩阵中出现边时，就需要再加上E次操作，因此总时间复杂度为O(V + E)</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><blockquote><p>深度优先搜索</p></blockquote><p>遍历完某一结点的所有子节点后再转向另一结点。需要一个数组来保存访问情况，避免重复访问导致无限递归。</p><blockquote><p>图论算法的设计模式</p></blockquote><p>将图的信息传递给专门进行处理的客户类，让客户直接从对应的类中获取需要的处理后的信息。</p><blockquote><p>Topological Sort</p></blockquote><p>拓扑排序是一个<strong>有向无环图</strong>的所有顶点的线性序列，且具有如下特质：</p><ol><li>每一个顶点出现且只出现一次</li><li>若存在一条从A到B的路径，则在序列中A出现在B之前。</li></ol><p>实现：</p><ol><li>维护一个存储入度为0的节点的数组</li><li>每次从该数组中取出一个节点并删除该顶点及所有相关的有向边。</li><li>更新图中其余节点的入度。</li><li>重复2，3直到图为空。</li></ol><p>应用：拓扑排序常用来排序具有依赖关系的任务。</p><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><blockquote><p>Shortest Path</p></blockquote><p>广度优先搜索不适合做最短路检索的原因：没有考虑边的权值。</p><p>最短路径最后的生成结果是一棵树</p><p>树的特性：</p><ol><li>没有环路(最短路径问题本身需要满足的条件)</li><li>每一个节点都最多只有一个父节点(对于图中的每一个节点来说，到达它的最短路径数永远&lt;&#x3D;1)</li></ol><p>Dijkstra算法</p><p>按照当前已知最短路的顺序访问各个节点，然后对该节点拥有的边进行松弛操作。</p><p>A*算法</p><p>基本和Dijkstra算法一致，但他访问节点的顺序是按照已知最短路再加上到达下一个节点的估计。和Dijkstra算法相比，该算法的速度会更快，因为D算法的执行顺序是根据到起点的距离，而A*算法加入了对终点距离的估计。</p><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><blockquote><p>Spanning tree</p></blockquote><p>最小生成树与最短路径树的区别：</p><p>最短路径树的生成与起点有关，而最小生成树与选取的起点无关。</p><blockquote><p> cut property</p></blockquote><p>对于两棵树来说，要生成他们融合后的最小生成树，那么连接他们的边中权重最小的那一条必然在最小生成树中。</p><p>利用该性质我们可以得出，先将一棵树分割成两部分，一部分有一个节点，另一部分有剩余的所有结点，找出权重最小的连接着两棵树的边加入到MST中，重复上述步骤知道没有节点在第二部分，MST就生成了。</p><p>和最短路径算法相比，最小生成树在增加节点时，更多的考虑该节点与树的距离，而非该节点与某一特定起点的距离。</p><blockquote><p>Kruskal</p></blockquote><p>每次都从图中抽取出权重最小的那条边，若没有构成环路，则将其加入MST中。</p><blockquote><p>判断图中有无环路的方法</p></blockquote><p>使用并查集存储已经连接起来的节点，若在检查某条边时，其对应的节点已经处于同一个集合中，则代表有环路。</p><h2 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h2><blockquote><p>Topological sort + Dijkstra</p></blockquote><p>拓扑排序会按照节点之间的依赖关系进行排序，也就是说，当某个节点被访问时，代表能到达它的边已经都被访问过了，因此，到达他的最短路径已经找到，可以在此基础上继续寻找最短路径。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>当一个问题的规模不断增大时，若其与对应的子问题有联系时，可以通过分割成子问题，然后通过子问题的答案推断出当前问题的答案。</p>]]></content>
      
      
      <categories>
          
          <category> Remake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/06/12/hello-world/"/>
      <url>/2022/06/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
